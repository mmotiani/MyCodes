
/*Check if Edit distance between two strings is 1 or lesser*/

public boolean getEditDistance(String s1, String s2){
	if(s1.length()-s2.length()>1)	
		return false;
	int count=0;
	int i=0,j=0;
	int m = s1.length(), n = s2.length();
	while(i<m && j<n){
		if(s1.charAt(i)!=s2.charAt(j)){
			if(count==1)
				return false;
			if(m<n)
				j++;
			else if (n<m)
				i++;
			else
				i++;
				j++;
			count++;
		} else{
		}
			i++;
			j++;
	}
	if(i<m||j<n)
		count++;
	return count==1;
}

/*Reverse an array without affecting special characters*/

public char[] reverseArray(char[] arr){
	if(arr==null||arr.length==0) return arr;
	int start =0;
	int end = arr.length-1;
	char temp = null;
	while(start<end){
		char firstChar = arr[start];
		char lastChar = arr[end];
		if(Character.isLetter(firstChar) && Character.isLetter(lastChar)){
			temp = firstChar;
			arr[start] = lastChar;
			arr[end] = temp;
			start++;
			end--;
		}else if(!Character.isLetter(firstChar)){
			start++;
		}else if(!Character.isLetter(lastChar)){
			end--;
		}
	}
	return arr;
}	

/*Isomorphic strings*/

public boolean checkIsomorphism(String s1, String s2){
	if(s1.lenght()!=s2.length())
		return false;
	StringBuilder sb = new StringBuilder();
	HashMap<Character,Character> map = new HashMap<>();

	for(int i=0;i<s1.length();i++){
		if(!map.containsKey(s1.charAt(i)) && !map.containsValue(s2.charAt(i))){
			map.put(s1.charAt(i),s2.charAt(i));
		}
	}
	for(int i=0;i<s1.length();i++){
		sb.append(map.get(s1.charAt(i)));
	}
	return sb.toString().equals(s2);
}

/*Remove spaces from a string*/
/*Example: "g ee ks for   gee k s"*/
    
public static String removeSpaces(String str){
	int space = 0;
	System.out.println(space);
	int j;
	char[] s = str.toCharArray();
	for(j=0;j<s.length;j++){
		if(s[j]!=' '){
			s[space] = s[j];
			space++;
		}		
	}
	System.out.println(space);
	return String.valueOf(s).substring(0,space);
}

/*Recursively print all sentences that can be formed from list of word lists*/

public class HelloWorld{
	public static void main (String[] args) throws java.lang.Exception
	{
		String[][] input = {{"you","we"},{"have", "are"},{"sleep", "eat", "drink"}};
		formStrings(input,0,new int[input.length]);
	}
	
	public static void formStrings(String[][] input, int i, int[] output){
		if(i>=input.length){
			for(int k=0;k<input.length;k++){
				System.out.print(input[k][output[k]]+" ");
			}
			System.out.println();
			return;
		}
		for(int k=0;k<input[i].length;k++){
			output[i]=k;
			formStrings(input,i+1,output);
		}
	}
}

/*Check if robot is moving in a circular path*/
#define N 0
#define E 1
#define S 2
#define W 3
 
// This function returns true if the given path is circular, else false
bool isCircular(char path[])
{
  // Initialize starting point for robot as (0, 0) and starting
  // direction as N North
  int x = 0, y = 0;
  int dir = N;
 
  // Travers the path given for robot
  for (int i=0; path[i]; i++)
  {
      // Find current move
      char move = path[i];
 
      // If move is left or right, then change direction
      if (move == 'R')
        dir = (dir + 1)%4;
      else if (move == 'L')
        dir = (4 + dir - 1)%4;
 
      // If move is Go, then change  x or y according to
      // current direction
      else // if (move == 'G')
      {
         if (dir == N)
            y++;
         else if (dir == E)
            x++;
         else if (dir == S)
            y--;
         else // dir == W
            x--;
      }
  }
 
   // If robot comes back to (0, 0), then path is cyclic
  return (x == 0 && y == 0);
}

/*Longest substring with k unique characters*/
public static String maxSubStringKUniqueChars(String s, int k) {
	//declare a counter
	HashMap<Character, Integer> map = new HashMap<Character, Integer>();		
	int start = 0;
	int maxLen = 0;
	String maxSubstring = null;
 
	for (int i = 0; i < s.length(); i++) {
		//add each char to the counter
		char c = s.charAt(i);
		if(map.containsKey(c)){
			map.put(c, map.get(c)+1);
		}else{
			map.put(c, 1);
		}
 
		if(map.size() == k+1){
			//get maximum
			int range = i-start;
			if(range > maxLen){
				maxLen = range;
				maxSubstring = s.substring(start, i);
			}
 
			//move left cursor toward right, so that substring contains only k chars
			while(map.size()>k){
				char first = s.charAt(start);
				int count = map.get(first);
				if(count>1){
					map.put(first,count-1);
				}else{
					map.remove(first);
				}
				start++;
			}
		}
	}
 
	if (map.size() == k && maxLen == 0) {
		return s;
	}
 
	return maxSubstring;
}

/*Find maximum depth of braces*/
public class HelloWorld{
	public static void main (String[] args) throws java.lang.Exception
	{
	    System.out.println(findDepthOfBraces("( p((q)) ((s)t) )"));
	}
	
	public static int findDepthOfBraces(String s){
	    int max=0;
	    int curMax=0;
	    for(int i=0;i<s.length();i++){
	        if(s.charAt(i)=='('){
	            curMax++;
	        }else if(s.charAt(i)==')'){
	            if(curMax==-1){
	                   return -1;
	            }
	            max = Math.max(curMax,max);
	            curMax--;
	        }
	    }
	    return max;
	}
}

/*Reverse of a string using recursion*/
public String reverseString(String s){
	if(s.length()<2){
		return s;
	}
	return reverseString(s.substring(1))+s.charAt(0);
}

/*Return the first non-repeating character in a string*/
public char firstNonRepeatingChar(String s){
	if(s.length()==0||s==null) return '\0';
	HashMap<Character,Integer> map = new HashMap<>();
	for(int i=0;i<s.length();i++){
		char cur = s.charAt(i);
		map.put(cur,map.getOrDefault(cur,0)+1);
	}
	for(int i=0;i<s.length();i++){
		if(map.get(s.charAt(i))==1)
			return s.charAt(i);
	}
	return '\0';
}

/*Reverse words in a string*/
public String reverseWords(String s){
	if(s.length()==0||s==null) return s;
	String[] words = s.split("\\s+");
	StringBuilder sb = new StringBuilder();
	int i;
	for(i = words.length-1;i>0;i--){
		sb.append(words[i]).append(" ");
	}
	sb.append(words[i]);
	return sb.toString();
}

/*Length encoding*/
public String encodeStringLength(String s){
	if(s.length()==0||s==null) return s;
	char cur =s.charAt(0);
	int count =1;
	StringBuilder sb = new StringBuilder();
	for(int i=1;i<s.length();i++){
		if(s.charAt(i)==cur)
			count++;
		else{
			sb.append(cur).append(count);
			count=1;
			cur=s.charAt(i);
		}
	}
	sb.append(cur).append(count);
	return sb.toString();
}


/*Find the smallest window in a string containing all characters of another string*/
public String findSmallestWindow(String s1, String s2){
	HashMap<Character,Integer> map = new HashMap<>();

	for(int i=0;i<s2.length();i++){
		map.put(s2.charAt(i),map.getOrDefault(s.charAt(i),0)+1);
	}
	int left = 0;
	int minLeft=0;
	int minLen = s.length()-1;
	int count =0;
	for(int right=0;right<s1.length();right++){
		char cur = s1.charAt(right);
		if(map.containsKey(cur)) {
			map.put(cur,map.get(cur)-1);
		}
		if(map.get(cur)>=0){
			count++;
		}
		while(count==s2.length()){
			if(right-left+1 < minLen ){
				minLen = right-left+1;
				minLeft = left;
			}
			if(map.containsKey(s.charAt(left))){
				map.put(s.charAt(left),map.get(s.charAt(left))+1);
				if(map.get(s.charAt(left))>0)
					count--;
			}
			left++;
		}
	}

}

/*Find all permutations with repition of characters*/
private static void printPermutationOfStrings(String str){
  printPermutation(str, "");
 }
  
 private static void printPermutation(String str, String stringToPrint){
  if(stringToPrint.length()==str.length()){
   System.out.println(stringToPrint);
   return;
  }
  for (int i = 0; i < str.length(); i++) {
   printPermutation(str, stringToPrint + str.charAt(i));
  }
 }

 /*Find all permutations without repition of characters*/

  
 private  void permutation(String string) {
  printPermutation(string,"");
 }
 
 private  void printPermutation(String string, String permutation) {
   
  if(string.length()==0){
   System.out.println(permutation);
   return;
  }
   
  for (int i = 0; i < string.length(); i++) {
   char toAppendToPermutation = string.charAt(i);
   String remaining = string.substring(0, i) + string.substring(i + 1);
    
   printPermutation( remaining,  permutation + toAppendToPermutation);
  }  
 }
 
}


/*Check if interleaving two strings forms the third string*/
public class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        if(s1.length()+s2.length()!=s3.length())
            return false;
        
        boolean[][] matrix = new boolean[s2.length()+1][s1.length()+1];
        matrix[0][0] = true;
        for(int i=1;i<matrix[0].length;i++){
            matrix[0][i] = matrix[0][i-1]&&(s1.charAt(i-1)==s3.charAt(i-1));
        }
        for(int i=1;i<matrix.length;i++){
            matrix[i][0] = matrix[i-1][0] &&(s2.charAt(i-1)==s3.charAt(i-1));
        }
        
        for(int i=1;i<matrix.length;i++){
            for(int j=1;j<matrix[0].length;j++){
                matrix[i][j] = (matrix[i-1][j]&&(s2.charAt(i-1)==s3.charAt(i+j-1)))||(matrix[i][j-1]&&(s1.charAt(j-1)==s3.charAt(i+j-1)));
            }
        }
        return matrix[matrix.length-1][matrix[0].length-1];
    }
}

/*Print all the interleavings of two strings*/
public static void printInterleavings(String s1,String s2){
		ArrayList<String> result = new ArrayList<>();
  		printInterleavings(s1,s2,"",result);
  		System.out.println(result);
	}
	
	
	public static void printInterleavings(String s1,String s2,String soFar,ArrayList<String> result){
		if((s1==null||s1.length()==0) && (s2==null||s2.length() == 0))
			return;
		if(s1==null || s1.length()==0){
			result.add(soFar+s2);
			return;
		}
		if(s2==null || s2.length()==0){
			result.add(soFar+s1);
			return;
		}
		printInterleavings(s1.substring(1), s2, soFar + s1.charAt(0),result);
		printInterleavings(s1, s2.substring(1), soFar + s2.charAt(0),result);
		
	}
/*Count number of words*/
#define OUT 0
#define IN  1
 
// returns number of words in str
unsigned countWords(char *str)
{
    int state = OUT;
    unsigned wc = 0;  // word count
 
    // Scan all characters one by one
    while (*str)
    {
        // If next character is a separator, set the state as OUT
        if (*str == ' ' || *str == '\n' || *str == '\t')
            state = OUT;
 
        // If next character is not a word separator and state is OUT,
        // then set the state as IN and increment word count
        else if (state == OUT)
        {
            state = IN;
            ++wc;
        }
 
        // Move to next character
        ++str;
    }
 
    return wc;
}

/*Find all the distinct palindrome substrings*/ O(n^2)
public HashSet<String> distinctPalindromes(String s){
    	 HashSet<String> set = new HashSet<String>();
    	 String temp = "";
    	 for(int i=0;i<s.length();i++){
    		getPalindrome(s,i,i,set);
    		getPalindrome(s,i,i+1,set);
    	 }
    	 return set;
     }
     
     public void getPalindrome(String s, int begin, int end, HashSet<String> set){
    	 while(begin>=0 && end<=s.length()-1 && s.charAt(begin)==s.charAt(end)){
    		 set.add(s.substring(begin,end+1));
    		 begin--;
    		 end++;
    	 }
    	 
     }


/*Check if one string is a subsequence of another*/

  public static boolean checkSubsequence(String s1, String s2){
  	if(s1.length()>s2.length()) return false;
    
    int i=0;
    for(int j=0;j<s2.length()&&i<s1.length();j++){
    	char s1Char = s1.charAt(i);
      	char s2Char = s2.charAt(j);
      	if(s1Char==s2Char)
          i++;      
    }
    if(i<s1.length())
      	return false;
    return true;
  }
  
/*word ladder */

public class Solution {
    public int ladderLength(String beginWord, String endWord, Set<String> wordList) {
        Set<String> beginSet = new HashSet<String>(), endSet = new HashSet<String>();

    int len = 1;
    int strLen = beginWord.length();
    HashSet<String> visited = new HashSet<String>();

    beginSet.add(beginWord);
    endSet.add(endWord);
    while (!beginSet.isEmpty() && !endSet.isEmpty()) {
        if (beginSet.size() > endSet.size()) {
            Set<String> set = beginSet;
            beginSet = endSet;
            endSet = set;
        }

        Set<String> temp = new HashSet<String>();
        for (String word : beginSet) {
            char[] chs = word.toCharArray();

            for (int i = 0; i < chs.length; i++) {
                for (char c = 'a'; c <= 'z'; c++) {
                    char old = chs[i];
                    chs[i] = c;
                    String target = String.valueOf(chs);

                    if (endSet.contains(target)) {
                        return len + 1;
                    }

                    if (!visited.contains(target) && wordList.contains(target)) {
                        temp.add(target);
                        visited.add(target);
                    }
                    chs[i] = old;
                }
            }
        }

        beginSet = temp;
        len++;
    }

    return 0;
    }
}

/*Function to generate a number with equal probability*/
public static int f29() {
	int start = 0;
	int randomPick = 0;
	while (start <= 29) {
		randomPick += f1();
		start++;
	}
	return randomPick;
}

/*Unique paths from top right of matrix to bottom left / can only travel right and down*/
public class Solution {
    public int uniquePaths(int m, int n) {
        int [][]matrix = new int[m][n];
        matrix[0][0]=1;
        for(int i=0; i<m; i++)
        {
            for(int j=0; j<n ;j++)
            {
                if(i==0 &&j!=0)
                {
                    matrix[i][j]+=matrix[i][j-1];
                }
                else if(i!=0&&j==0)
                {
                    matrix[i][j]+=matrix[i-1][j];
                }
                else if(i!=0&&j!=0)
                {
                    matrix[i][j] = matrix[i][j-1]+matrix[i-1][j];
                }
            }
        }
        return matrix[m-1][n-1];
    }
}
/* Unique path sum with obstacles*/
public class Solution {
    public int uniquePathsWithObstacles(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        if(matrix[0][0]==1 || matrix[m-1][n-1]==1)
            return 0;
        else
            matrix[0][0]=-1;
        
        
        for(int i=0; i<m ;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(matrix[i][j]==1)
                    continue;
                if(i==0&&j!=0&&matrix[i][j-1]!=1)
                    matrix[i][j]+=matrix[i][j-1];
                else if(i!=0&&j==0&&matrix[i-1][j]!=1)
                    matrix[i][j]+=matrix[i-1][j];
                else if(i!=0&&j!=0)
                {
                    if(matrix[i][j-1]!=1)
                        matrix[i][j]=matrix[i][j-1];
                    if(matrix[i-1][j]!=1)
                        matrix[i][j]=matrix[i][j]+matrix[i-1][j];
                }
                    
            }
        }
        return 0-matrix[m-1][n-1];
    }
}
/*First Missing Positive /optimal solution*/
public class Solution {
    public int firstMissingPositive(int[] nums) {
        if(nums == null || nums.length ==0)
        return 1;
        int i = 0, n = nums.length;
    while (i < n) {
        // If the current value is in the range of (0,length) and it's not at its correct position, 
        // swap it to its correct position.
        // Else just continue;
        if (nums[i] >= 0 && nums[i] < n && nums[nums[i]] != nums[i])
            swap(nums, i, nums[i]);
        else
            i++;
    }
    int k = 1;

    // Check from k=1 to see whether each index and value can be corresponding.
    while (k < n && nums[k] == k)
        k++;

    // If it breaks because of empty array or reaching the end. K must be the first missing number.
    if (n == 0 || k < n)
        return k;
    else   // If k is hiding at position 0, K+1 is the number. 
        return nums[0] == k ? k + 1 : k;
    }
    private void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
}
/* Minimum size subarray sum / minimum sum subarray equals to target value*/
public class Solution {
    public int minSubArrayLen(int s, int[] nums) {
        if(nums==null || nums.length==0)
            return 0;
        int i=0, j=0, sum=0, min = Integer.MAX_VALUE;
        while(j<nums.length)
        {
            sum = sum+nums[j++];
            while(sum>=s)
            {
                min = Math.min(min, j-i);
                sum=sum-nums[i++];
            }
        }
        return min==Integer.MAX_VALUE ? 0 : min;
    }
}
/* Longest Consecutive Sequence in an array*/
public class Solution {
    public int longestConsecutive(int[] nums) {
        if(nums==null || nums.length==0)
            return 0;
        int longest = 0;
        HashMap<Integer, Integer> map = new HashMap<>();
        for(int i=0; i<nums.length;i++)
        {
            if(map.containsKey(nums[i]))
                continue;
            map.put(nums[i],1);
            
            int begin = nums[i];
            int end = nums[i];
            
            if(map.containsKey(nums[i]+1))
                end = nums[i]+ map.get(nums[i]+1);
            
            if(map.containsKey(nums[i]-1))
                begin = nums[i] - map.get(nums[i]-1);
                
            longest=Math.max(longest, end-begin+1);
            
            map.put(end, end-begin+1);
            map.put(begin, end-begin+1);
        }
        return longest;
    }
}


/*Spiral Matrix*/
public class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
    List<Integer> spiralList = new ArrayList<>();
    if(matrix == null || matrix.length == 0) return spiralList;

    // declare indices
    int top = 0;
    int bottom = matrix.length - 1;
    int left = 0;
    int right = matrix[0].length - 1;

    while(true){
        // 1. print top row
        for(int j=left; j <=right;j++){
            spiralList.add(matrix[top][j]);
        }
        top++;
        if(boundriesCrossed(left,right,bottom,top))
            break;

        // 2. print rightmost column
        for(int i=top; i <= bottom; i++){
            spiralList.add(matrix[i][right]);
        }
        right--;
        if(boundriesCrossed(left,right,bottom,top))
            break;

        // 3. print bottom row
        for(int j=right; j >=left; j--){
            spiralList.add(matrix[bottom][j]);
        }
        bottom--;
        if(boundriesCrossed(left,right,bottom,top))
            break;    

        // 4. print leftmost column
        for(int i=bottom; i >= top; i--){
            spiralList.add(matrix[i][left]);
        }
        left++;
        if(boundriesCrossed(left,right,bottom,top))
            break;    
    }// end while true

    return spiralList;
}

private boolean boundriesCrossed(int left,int right,int bottom,int top){
    if(left>right || bottom<top)
        return true;
    else
        return false;
}
}
/*Spiral Matrix / generate matrix in spiral form*/
public class Solution {
    public int[][] generateMatrix(int n) {
        int [][] matrix = new int[n][n];
    int top = 0;
    int bottom = matrix.length - 1;
    int left = 0;
    int right = n - 1;
    int count=1;
    while(true)
    {
        for(int i =left ; i<=right;i++)
        {
            matrix[top][i] = count++;
        }
        top++;
        if(boundriesCrossed(left,right,bottom,top))
            break;

        for(int i=top; i <= bottom; i++)
        {
            matrix[i][right]=count++;
        }
        right--;
        if(boundriesCrossed(left,right,bottom,top))
            break;

        // 3. print bottom row
        for(int j=right; j >=left; j--)
        {
            matrix[bottom][j]=count++;
        }
        bottom--;
        if(boundriesCrossed(left,right,bottom,top))
            break;    

        // 4. print leftmost column
        for(int i=bottom; i >= top; i--)
        {
            matrix[i][left]=count++;
        }
        left++;
        if(boundriesCrossed(left,right,bottom,top))
            break;    


    }
return matrix;
    
}

    private boolean boundriesCrossed(int left,int right,int bottom,int top){
    if(left>right || bottom<top)
        return true;
    else
        return false;
}

}
/*all Subsets of a set including empty set ITERATIVE*/
public class Solution {
    public List<List<Integer>> subsets(int[] S) {
         List<List<Integer>> res = new ArrayList<>();
        res.add(new ArrayList<Integer>());

        Arrays.sort(S);
        for(int i : S) {
            List<List<Integer>> tmp = new ArrayList<>();
            for(List<Integer> sub : res) {
                List<Integer> a = new ArrayList<>(sub);
                a.add(i);
                tmp.add(a);
            }
            res.addAll(tmp);
        }
        return res;
    }
}
/*all Subsets of a set including empty set ITERATIVE*/
public class Solution {
    public List<List<Integer>> subsets(int[] nums) {
         Arrays.sort(nums);
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> each = new ArrayList<>();
    helper(res, each, 0, nums);
    return res;
    }
    public void helper(List<List<Integer>> res, List<Integer> each, int pos, int[] n) {
    if (pos <= n.length) {
        res.add(each);
    }
    for (int i = pos; i < n.length; i++) {
        each.add(n[i]);
        helper(res, new ArrayList<>(each), i + 1, n);
        each.remove(each.size() - 1);
    }
    return;
}
}
/*Add digits until you get the single digit*/
public class Solution {
    public int addDigits(int num) {
        return (num<10)?num:((num-1)%9)+1;
    }
}
/*number of 1 bits / number of 1 digits in unsigned 32 bit number*/
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int count=0;
        while(n!=0)
        {
            count=count+(n&1);
            n=n>>>1;
        }
        return count;
    }
}
/*Next Permutation*/
public class Solution {
    public void nextPermutation(int[] nums) {
        if(nums.length<=1){
          return;
      }

      int i= nums.length-1;

      for(;i>=1;i--){

         if(nums[i]>nums[i-1]){ //find first number which is smaller than it's after number
             break;
         }
      }

      if(i!=0){
          swap(nums,i-1); //if the number exist,which means that the nums not like{5,4,3,2,1}
      }

      reverse(nums,i);    
        
    }
    private void swap(int[] a,int i){
        for(int j = a.length-1;j>i;j--){
            if(a[j]>a[i]){
                int t = a[j];
                a[j] = a[i];
                a[i] = t;
                break;
            }
        }
    }
    
     private void reverse(int[] a,int i){//reverse the number after the number we have found
        int first = i;
        int last = a.length-1;
        while(first<last){
            int t = a[first];
            a[first] = a[last];
            a[last] = t;
            first ++;
            last --;
        }
    }
}
/*search in matrix / search in a 2D array
The basic idea is from right corner, if the current number greater than target col - 1 in same row, else if the current number less than target, row + 1 in same column, finally if they are same, we find it, and return return.
*/
public class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
       if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
        return false;
    }
    int row = 0;
    int col = matrix[0].length - 1;
    while (row < matrix.length && col >= 0) {
        if (matrix[row][col] == target) {
            return true;
        } else if (matrix[row][col] < target) {
            row++;
        } else {
            col--;
        }
    }
    return false;
    }
}
/* Strobogrammatic number  SOLUTION 1
Just checking the pairs, going inwards from the ends.
*/
public boolean isStrobogrammatic(String num) {
    for (int i=0, j=num.length()-1; i <= j; i++, j--)
        if (!"00 11 88 696".contains(num.charAt(i) + "" + num.charAt(j)))
            return false;
    return true;
}
/* Strobogrammatic number SOLUTION 2 */
public boolean isStrobogrammatic(String num) {
    Map<Character, Character> map = new HashMap<Character, Character>();
    map.put('6', '9');
    map.put('9', '6');
    map.put('0', '0');
    map.put('1', '1');
    map.put('8', '8');

    int l = 0, r = num.length() - 1;
    while (l <= r) {
        if (!map.containsKey(num.charAt(l))) return false;
        if (map.get(num.charAt(l)) != num.charAt(r))
            return false;
        l++;
        r--;
    }

    return true;
}
/*Combination Sum (with duplicates)*/
public class Solution {
    public List<List<Integer>> combinationSum(int[] cand, int target) {
        ArrayList<List<Integer>> result = new ArrayList<List<Integer>>();
        Arrays.sort(cand);
        helper(result, new ArrayList<Integer>(), 0, target, cand);
        return result;
    }
    public void helper(ArrayList<List<Integer>> result, ArrayList<Integer> list, int start, int target, int [] cand)
    {
        for(int i=start; i<cand.length ; i++)
        {
            list.add(cand[i]);
            if(cand[i]<target)
                 helper(result, list, i, target-cand[i], cand);
            else if(target==cand[i])
                result.add(new ArrayList<>(list));
                
            list.remove(list.size()-1);
                
        }
    }
}
/*Combination Sum2 (without duplicates) / Combination Sum 2 (without duplicates)*/
public class Solution {
    HashSet<ArrayList<Integer>> hs = new HashSet<ArrayList<Integer>>();
    public List<List<Integer>> combinationSum2(int[] cand, int target) {
        HashSet<List<Integer>> result = new HashSet<List<Integer>>();
         
        Arrays.sort(cand);
        helper(result, new ArrayList<Integer>(), 0, target, cand);
        return new ArrayList(result);   
    }
    public void helper(HashSet<List<Integer>> result, ArrayList<Integer> list, int start, int target, int [] cand)
    {
    
         for(int i=start; i<cand.length ; i++)
        {
            list.add(cand[i]);
            if(cand[i]<target)
                 helper(result, list, i+1, target-cand[i], cand);
    
            else if(target==cand[i])
                    result.add(new ArrayList<>(list));
                list.remove(list.size()-1);
                
        }
     
    }
}
/*Bulls and Cows*/
public class Solution {
    public String getHint(String secret, String guess) {
        if(secret.length()==0) return null;
        
        HashMap<Character,Integer> map = new HashMap<>();
        int A=0;
        int B=0;
        char c;
        for(int i=0;i<secret.length();i++){
            c=secret.charAt(i);
            map.put(c,map.getOrDefault(c,0)+1);
        }
        
        for(int i=0;i<guess.length();i++){
            c=guess.charAt(i);
            Integer value = map.get(c)==null ? 0 :map.get(c);
            if(c==secret.charAt(i)){
                A++;
                if(value<=0)
                    B--;
            }else if(value>0){
                B++;
                
            }
            map.put(c,value-1);
        }
      return A+"A"+B+"B";
      
    }
}
/*Repeated DNA Sequence
All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: "ACGAATTCCG". When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.
Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.
For example,
Given s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT",

Return:
["AAAAACCCCC", "CCCCCAAAAA"].

*/
public class Solution {
    public List<String> findRepeatedDnaSequences(String s) {
        HashSet<String> seen = new HashSet<>(), repeated = new HashSet<>();
        String c;
        for(int i=0 ; i<=s.length()-10 ; i++)
        {
            c = s.substring(i, i+10);
            if(!seen.add(c))
                repeated.add(c);
        }
        return new ArrayList(repeated);
    }
}
/*Fraction to Recurring Decimal
For example,
•	Given numerator = 1, denominator = 2, return "0.5".
*/
public class Solution {
    public String fractionToDecimal(int numerator, int denominator) {
        StringBuilder sb = new StringBuilder();
        String sign = numerator<0 == denominator<0 || numerator==0 ? "" : "-";
        sb.append(sign);
        long num = (long)numerator;
        long den = (long)denominator;
    
        num = Math.abs(num);
        den = Math.abs(den);
        
        sb.append(num/den);
        
        long rem = num%den;
        
        if(rem==0)
            return sb.toString();
            
        HashMap<Long, Integer> map = new HashMap<Long, Integer>();
        sb.append(".");
        
        while(rem!=0 && !map.containsKey(rem))
        {
            map.put(rem, sb.length());
            rem*=10;
            sb.append(rem/den);
            rem=rem%den;
        }
        if(map.containsKey(rem)){
        int index = map.get(rem);
        sb.insert(index, "(");
        sb.append(")");
            
        }
        return sb.toString();
    }
}
/*Word pattern
Given a pattern and a string str, find if str follows the same pattern.
Examples:
pattern = "abba", str = "dog cat cat dog" should return true.
*/
public class Solution {
    public boolean wordPattern(String pattern, String str) {
        String [] arr = str.split(" ");
HashMap<Character, String> map = new HashMap<Character, String>();
if(arr.length!=pattern.length())
	return false;
for (int i=0; i<arr.length; i++)
{
	char c = pattern.charAt(i);
	if(map.containsKey(c))
	{
		if(!map.get(c).equals(arr[i]))
			return false;
	}
	else
	{
		if(map.containsValue(arr[i]))
			return false;
		map.put(c, arr[i]);
	}
}
return true;
    }
}
/*Board game / live or dead / live / dead / matrix*/
public class Solution {
    public void gameOfLife(int[][] board) {
        int m = board.length;
        int n = board[0].length;
        
        for(int i=0 ; i<m ; i++)
        {
            for(int j=0 ; j<n ; j++)
            {
                int sum=0;
                int mn = board[i][j];
                
                sum = value(board, i-1, j-1) + value(board, i-1, j) + value(board, i-1, j+1) + value(board, i, j+1)
                        + value(board, i+1, j+1) + value(board, i+1, j) + value(board, i+1, j-1) + value(board, i, j-1);
                if(mn==0 && sum==3)
                {
                    board[i][j]=-1;
                }
                else if(mn==1 && sum<2)
                {
                    board[i][j]=-2;
                }
                else if(mn==1 && sum>3)
                {
                    board[i][j]=-2;
                }
            }
        }
        
        for(int i=0 ; i<m ;i++)
        {
            for(int j=0; j<n; j++)
            {
                int mn = board[i][j];
                if(mn==-1 || mn==-2)
                    board[i][j]  = mn+ 2;
            }
        }
    }
    public int value(int[][] board, int i, int j)
    {
        int m = board.length;
        int n = board[0].length;
        
        if(i<0 || j<0 || i>m-1 || j> n-1)
            return 0;
        else
        {
            int current = board[i][j];
            if(current==-2)
                return 1;
            else if(current==-1)
                return 0;
            else
                return current;
        }
    }
}
/*Word Search in a Matrix / check if word can be created from the matrix of characters (Using Backtracking)*/
public class Solution {
    public boolean exist(char[][] board, String word) {
        for(int i=0; i<board.length; i++)
        {
            for(int j=0; j<board[0].length; j++)
            {
                if(exist(board, i , j, word, 0))
                    return true;
            }
        }
        return false;
    }
    private boolean exist(char [][] board, int i , int j , String word, int ind)
    {
        if(ind==word.length())
            return true;
         if(i>board.length-1 || i<0 || j<0 || j>board[0].length-1 || board[i][j]!=word.charAt(ind))
            return false;
        board[i][j]='*';
        boolean result = exist(board, i-1, j, word, ind+1) || exist(board, i+1, j, word, ind+1) || exist(board, i, j-1, word, ind+1) || exist(board, i, j+1, word, ind+1);
            
        board[i][j]=word.charAt(ind);
        return result;
    }
}
/*Rotate an image 90 degree / clockwise (first transpose and then swap horizontally)*/
public class Solution {
    
        public void rotate(int[][] matrix) {
//Transpose Matrix
        for(int i = 0; i<matrix.length; i++){
            for(int j = i; j<matrix[0].length; j++){
                int temp = 0;
                temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
//Swap horizontally
        for(int i =0 ; i<matrix.length; i++){
            for(int j = 0; j<matrix.length/2; j++){
                int temp = 0;
                temp = matrix[i][j];
                matrix[i][j] = matrix[i][matrix.length-1-j];
                matrix[i][matrix.length-1-j] = temp;
            }
        }
    }
}
/* Rotate an image 90 degree / clockwise (using some technique)*/
public class Solution {
    public void rotate(int[][] M) {
        for (int i = 0; i < (M.length+1)/2; i++) {
            for (int j = 0; j < M.length/2; j++) {
                int tmp = M[i][j];
                M[i][j] = M[M.length-j-1][i];
                M[M.length-j-1][i] = M[M.length-i-1][M.length-j-1];
                M[M.length-i-1][M.length-j-1] = M[j][M.length-i-1];
                M[j][M.length-i-1] = tmp;
            }
        }
    }
}
/*Min Path Sum / minpathsum / minsumpath / min sum path / minimumsum / minimum path sum/ minimum sum of path from one corner of matrix to another corner*/
public class Solution {
    public int minPathSum(int[][] grid) {
        for(int i=0 ; i <grid.length; i++)
        {
            for(int j=0; j<grid[0].length ; j++)
            {
                if(i==0 && j==0)
                    grid[i][j]=grid[i][j];
                else if(i==0 && j!=0)
                    grid[i][j]=grid[i][j] + grid[i][j-1];
                else if(i!=0 && j==0)
                    grid[i][j]=grid[i][j] + grid[i-1][j];
                else
                    grid[i][j] += Math.min(grid[i-1][j],grid[i][j-1]);
            }
        }
        return grid[grid.length-1][grid[0].length-1];
    }
}
/*Set Matrix Zero / set rows and coloumn to zero if one element is zero/ setmatrix zero*/
public class Solution {
    public void setZeroes(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        boolean fr = false, fc=false;
        
        for(int i=0; i<m ; i++)
        {
            for(int j=0 ; j<n ; j++)
            {
                if(matrix[i][j]==0)
                {
                    if(i==0)
                        fr=true;
                    if(j==0)
                        fc=true;
                    matrix[0][j]=0;
                    matrix[i][0]=0;
                }
            }
        }
        
        for(int i=1; i<m; i++)
        {
            for(int j=1; j<n ; j++)
            {
                if(matrix[i][0]==0 || matrix[0][j]==0)
                    matrix[i][j]=0;
            }
        }
        
        if(fr)
        {
            for(int j=0 ; j<n ; j++)
                {
                    matrix[0][j]=0;
                }
        }
        
        if(fc)
        {
            for(int i=0 ; i<m ; i++)
                {
                    matrix[i][0]=0;
                }
        }
        
    }
}
/*All sorting algorithms*/
package hardik.code;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map.Entry;

public class Sorting {
	
	public static void countingSort(int[] arr, int k)
	{
		int[] counts = new int[k];
		
		for(int i =0; i<k;i++)
		{
			counts[i] = 0;
		}
		
		for(int i =0; i < arr.length; i++)
		{
			counts[arr[i]] += 1;
		}
		
		int j =0;
		for(int m=0; m < counts.length;m++)
		{
			for(int n =0; n < counts[m] && j < arr.length; j++, n++)
			{
				arr[j] = m;
			}
		}
		
	}

	public static int[] bubbleSort(int[] A, int n) {
		int temp = 0;
		for (int pass = n - 1; pass >= 0; pass++) {
			for (int i = 0; i < pass; i++) {
				if (A[i] > A[i + 1]) {
					temp = A[i];
					A[i] = A[i + 1];
					A[i + 1] = temp;
				}
			}
		}
		return A;
	}

	public static int[] mergeSort(int[] A, int[] temp, int left, int right) {
		if (left < right) {
			int mid = (left + right) / 2;
			mergeSort(A, temp, left, mid);
			mergeSort(A,temp, mid+1, right);
			//always use mid and mid+1 instead of mid-1 and mid as integer division will provide floor value
			//Eg: In array of size 2, mid-1 and mid will become -1 and 0. It will break the algorithm
			merge(A,temp, left, mid+1, right);
		}

		return A;
	}

	private static void merge(int[] A,int[] temp, int left, int mid, int right) {
		int temp_pos = left;
		int left_end = mid - 1;
		int size = right - left +1;
		while (left <= left_end && mid <= right) {
			if (A[left] <= A[mid]) {
				temp[temp_pos++] = A[left++];
			} else {
				temp[temp_pos++] = A[mid++];
			}
		}
		while (left <= left_end) {
			temp[temp_pos++] = A[left++];
		}
		while (mid <= right) {
			temp[temp_pos++] = A[mid++];
		}
		for (int i = 0; i < size; i++) {
			A[right] = temp[right];
			right--;
		}
	}

	private static int[] mergeSortedArrays(int[] A, int[] B, int[] C) {
		int size = A.length + B.length;
		int[] temp = new int[size];
		int[] result = new int[size + C.length];
		mergeArrays(A, B, temp, 0);
		mergeArrays(temp, C, result, 0);
		return result;
	}

	private static void mergeArrays(int[] A, int[] B, int[] temp,
			int temp_pointer_position) {
		int i = 0, j = 0;
		while (i < A.length && j < B.length) {
			if (A[i] < B[j]) {
				temp[temp_pointer_position++] = A[i++];
			} else {
				temp[temp_pointer_position++] = B[j++];
			}
		}
		if (i == A.length && j != B.length) {
			while (j < B.length) {
				temp[temp_pointer_position++] = B[j++];
			}
		} else if (j == B.length && i != B.length) {
			while (i < A.length) {
				temp[temp_pointer_position++] = A[i++];
			}
		}
	}

	public static void quickSort(int[] A, int low, int high) {
		if (low < high) {
			int pivot = partition(A, low, high);
			if (low < pivot-1) {
				quickSort(A, low, pivot - 1);
			}
			if (high > pivot) {
				quickSort(A, pivot, high);
			}
		}
	}

	public static int quickSortFindMedian(int[] A, int low, int high, int k) {
		if (low < high) {
			int pivot = partition(A, low, high) - 1;
			if(pivot == k)
				return A[k];
			if (pivot < k)
					return quickSortFindMedian(A, pivot+1, high, k);
			else
					return quickSortFindMedian(A, low, pivot-1, k);
		}
		return -1;
	}

	static void findMaxOccurenceInArray(int[] a) {
		HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
		for (int i : a) {
			if (!map.containsKey(i))
				map.put(i, 1);
			else {
				int count = map.get(i) + 1;
				map.put(i, count);
			}
		}
		Iterator<Entry<Integer, Integer>> itr = map.entrySet().iterator();
		int maxCount = Integer.MIN_VALUE;
		int maxNumber = Integer.MIN_VALUE;
		while (itr.hasNext()) {
			Entry<Integer, Integer> entry = itr.next();
			if (entry.getValue() > maxCount) {
				maxCount = entry.getValue();
				maxNumber = entry.getKey();
			}
		}
		System.out.println("Number is :" + maxNumber + " count is : " + maxCount);
	}
	private static int partition(int[] a, int low, int high) {
		int left = low, right = high; 
		int pivot_item = a[((low + high) / 2)];//take a random number between low and high for randomized quick sort
		while (left <= right) {
			while (a[left] < pivot_item)
				left++;
			while (a[right] > pivot_item)
				right--;
			if (left <= right) {
				int temp = a[right];
				a[right] = a[left];
				a[left] = temp;
				left++;
				right--;
			}
		}
		return left;// For median return mid = ((low + high)/2)
	}


	public static void main(String[] args) {
		
		int[] Ar = {2,1};
		int[] tempr = new int[Ar.length];
		mergeSort(Ar,tempr,0,Ar.length-1);
		
		int[] arr = new int[] {1,1,1,2,2,2,2,0,0,0,2,0,1,2,0,2,1,0,2,1,0,2,1,0,2,1 };
		countingSort(arr,3);
		
		int[] A = new int[] { 1, 3, 5, 7, 8 };
		int[] B = new int[] { 2, 3, 6, 9 };
		int[] C = new int[] { 3, 6, 8, 9 };
		int[] temp = mergeSortedArrays(A, B, C);
		for (int i : temp) {
			System.out.print(i);
		}
		System.out.println();
		int[] array = new int[] {1,9,-4,7,6,11,3,2,10};
		int mid = quickSortFindMedian(array, 0, array.length - 1, (array.length)/2);
		System.out.println(mid);
		
		 quickSort(array, 0, array.length-1); 
		 for (int i : array) {
			 System.out.print(i + " "); 
		 }
		 C = new int[] { 3, 6, 8, 9 , 9,3,5,6,1,6};
		 findMaxOccurenceInArray(C);
		 
		 	ListNode node6 = new ListNode(5, null);
			ListNode node5 = new ListNode(7, node6);
			ListNode node4 = new ListNode(9, node5);
			ListNode node3 = new ListNode(10, node4);
			ListNode node2 = new ListNode(12, node3);
			ListNode node1 = new ListNode(15, node2);
			ListNode head = new ListNode(2, node1);
			ListNode tempNode = merge_sort_LinkedList(head);
			while (tempNode != null) {
				System.out.print(tempNode.getData() + " ");
				tempNode = tempNode.getNext();
			}

	}
	
	
	public static ListNode merge_sort_LinkedList(ListNode head) {
	    if(head == null || head.getNext() == null) { return head; }
	    ListNode middle = getMiddle(head);      //get the middle of the list
	    ListNode sHalf = middle.next; middle.next = null;   //split the list into two halfs
	    
	    head = merge_sort_LinkedList(head);
	    sHalf = merge_sort_LinkedList(sHalf);

	    return merge(head,sHalf);  //recurse on that
	}

	//Merge subroutine to merge two sorted lists
	public static ListNode merge(ListNode a, ListNode b) {
	    ListNode dummyHead, curr; dummyHead = new ListNode(); curr = dummyHead;
	    while(a !=null && b!= null) {
	        if(a.data <= b.data)
	        	{ curr.next = a; a = a.next; }
	        else 
	        	{ curr.next = b; b = b.next; }
	        curr = curr.next;
	    }
	    curr.next = (a == null) ? b : a;
	    return dummyHead.next;
	}

	//Finding the middle element of the list for splitting
	public static ListNode getMiddle(ListNode head) {
	    if(head == null) { return head; }
	    ListNode slow, fast; slow = fast = head;
	    while(fast.next != null && fast.next.next != null) {
	        slow = slow.next; fast = fast.next.next;
	    }
	    return slow;
	}
}
/*String Manipulation Questions*/
package hardik.code;

import java.util.Arrays;

public class StringManipulation {

	public static void determineUniqueCharacters(String string) {
		
		//Assumption that string is ASCII
		if (string.length() > 256) {
			System.out.println("Not all characters unique");
			return;
		}
		boolean[] charArray = new boolean[256];
		boolean isUnique = true;
		for (int i=0; i < string.length() ; i++) {
			if (charArray[(string.charAt(i))]) {
				isUnique = false;
				break;
			}
			charArray[(string.charAt(i))] = true;
		}
		if (!isUnique) {
			System.out.println("Not unique characters in String");
		} else {
			System.out.println("All characters in string are unique");
		}
	}
	
	public static String stringReverse(String inputString) {
		char[] chaArray = new char[inputString.length()];
		int j =0 ;
		for (int i = (inputString.length()-1); i >=0 ; i-- ){
			chaArray[j++] = inputString.charAt(i); 
		}
		return new String(chaArray);
	}
	
	public static void stringPermutation(String actualString, String permuted) {
		char[] actualCharArray = actualString.toLowerCase().toCharArray();
		char[] permutedCharArray = permuted.toLowerCase().toCharArray();
		Arrays.sort(actualCharArray);
		Arrays.sort(permutedCharArray);
		if (Arrays.equals(actualCharArray, permutedCharArray)) {
			System.out.println("String permutation");
		} else {
			System.out.println("String not permutation");
		}
	}
	
	public static void stringReplace(String actualString, Character charToBeReplaced, Character charToReplace) {
		char[] charArray = actualString.toCharArray();
		int spaceCount = 0;
		for (int i =0 ; i <charArray.length; i++) {
			if (' ' == charArray[i]) {
				spaceCount++;
			}
		}
		int newLength = charArray.length + spaceCount * 2;
		char[] replaceCharArray = new char[newLength];
		for (int i= (actualString.length() - 1); i >= 0 ; i--) {
			if (charArray[i] == ' ') {
				replaceCharArray[--newLength] = '0';
				replaceCharArray[--newLength] = '2';
				replaceCharArray[--newLength] = '%';
			} else {
				replaceCharArray[--newLength] = charArray[i];
			}
		}
		System.out.println("Replcaed String is " + new String(replaceCharArray));
	}
	
	public static void stringReplaceByMe(String actualString, Character charToBeReplaced, Character charToReplace) {
		
		int spaceCount = 0;
		for(int i=0; i < actualString.length(); i++)
		{
			if(actualString.charAt(i) == ' ')
				spaceCount++;
		}
		
		char[] finalString = new char[actualString.length() + 2*spaceCount];
		int finalStringIndex = 0;
		
		for(int i=0; i < actualString.length(); i++)
		{
			if(actualString.charAt(i) == ' ')
			{
				finalString[finalStringIndex] = '%';
				finalStringIndex++;
				finalString[finalStringIndex] = '2';
				finalStringIndex++;
				finalString[finalStringIndex] = '0';
			}
			else
				finalString[finalStringIndex] = actualString.charAt(i);
			
			finalStringIndex++;
		}
		
		System.out.println("Replcaed String is " + new String(finalString));
	}
	
	
	public static void countOccurences(String inputString) {
		StringBuffer sb = new StringBuffer();
		char c = inputString.charAt(0);
		int count = 1;
		for (int i = 1 ; i < inputString.length() ; i++) {
			if (c == inputString.charAt(i)) {
				count++;
			} else {
				sb.append(c);
				sb.append(count);
				c = inputString.charAt(i);
				count = 1;
				
			}
		}
		sb.append(c).append(count);
		if(sb.toString().length() > inputString.length()) {
			System.out.println("Returned String is " + inputString);
		} else {
			System.out.println("Returned String is " + sb.toString());
		}
	}
	
	public static void countOccurencesByMe(String inputString) {
		
		StringBuffer str = new StringBuffer();
		char currentchar = ' ';
		int currentCount = 1;
		
		for(int i = 0; i < inputString.length(); i++)
		{
			currentchar = inputString.charAt(i);
			str.append(currentchar);
			
			i++;
			while(i < inputString.length() && currentchar == inputString.charAt(i))
			{
				i++;
				currentCount++;
			}
			
			str.append(currentCount);
			
			if(str.length() >= inputString.length())
				return;
			
			i--;
			currentCount = 1;
		}
		
		System.out.println("Returned String is " + str.toString());
	}
	
	
	public static void main(String[] args) {
		/*determineUniqueCharacters("abcda");
		System.out.println("Reverse string is " + stringReverse("abcdabcd"));
		stringPermutation("&*()", ")(&a");
		stringReplace("Mr Bean Is a Guy ", ' ', ' ');
		countOccurences("abcd");*/
		
		stringReplaceByMe("Mr Bean Is a Guy ", ' ', ' ');
		countOccurencesByMe("aabbccdd");
	}
	
	
}

/*Trees Questions of Hardik*/
package hardik.code;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Stack;

public class TreeExamples {
	
	public static int getDepthOfNode(BinaryTreeNode root, int data)
	{
		int left, right;
		if(root == null)
			return 0;
		else
		{
			if(root.getData() == data)
				return 1;
			else
			{
				left =getDepthOfNode(root.getLeft(), data);
				if(left >= 1)
					return left +1;
				right = getDepthOfNode(root.getRight(), data);
				if(right >= 1)
					return right +1;
				
				return 0;
			}
		}
	}
	
	private static int getMaxSum(BinaryTreeNode root, int sum)
	{
		int left, right;
		if(root == null)
			return sum;
		
		if(root.getData() + sum > sum)
			sum = root.getData() +sum;
		
		left = getMaxSum(root.getLeft(), sum);
		right = getMaxSum(root.getRight(), sum);
		
		
		return left>right?left:right;
	}
	
	public static void preOrder(BinaryTreeNode root) {
		Stack<BinaryTreeNode> s = new Stack<BinaryTreeNode>();
		while(true) {
			while (root != null) {
				System.out.println(root.getData());
				s.push(root);
				root = root.getLeft();
			}
			if (s.isEmpty())
				break;
			root = s.pop();
			root = root.getRight();
		}
		return;
	}
	
	public static void inOrder(BinaryTreeNode root) {
		Stack<BinaryTreeNode> s = new Stack<BinaryTreeNode>();
		while(true) {
			while (root != null) {
				s.push(root);
				root = root.getLeft();
			}
			if (s.isEmpty())
				break;
			root = s.pop();
			System.out.print(root.getData() + " ");
			root = root.getRight();
		}
	}
	
	public static void postOrder(BinaryTreeNode root) {
		Stack<BinaryTreeNode> s = new Stack<BinaryTreeNode>();
		while(true) {
			while (root != null) {
				if (root.getRight() != null)
					s.push(root.getRight());
				s.push(root);
				root = root.getLeft();
			}
			if (s.isEmpty())
				return;
			else {
				root = s.pop();
				if (root.getRight() != null && !s.isEmpty() && s.peek().equals(root.getRight())) {
					s.pop();
					s.push(root);
					root = root.getRight();
				} else {
					System.out.println(root.getData());
					root = null;
				}
			}
		}
	}
	
	public static void levelOrder(BinaryTreeNode root) {
		if (root == null) 
			return;
		Queue<BinaryTreeNode> q= new LinkedList<BinaryTreeNode>();
		q.add(root);
		while (!q.isEmpty()) {
			root = q.poll();
			System.out.print(root.getData() + " ");
			if (root.getLeft() != null) {
				q.add(root.getLeft());
			}
			if (root.getRight() != null)
				q.add(root.getRight());
		}
	}
	
	public static boolean findElement(BinaryTreeNode root, int data) {
		boolean temp; 
		if (root == null) 
			return false;
		if (root.getData() == data) {
			System.out.println("Data Found");
			return true;
		} else {
			temp = findElement(root.getLeft(), data);
			if (temp) {
				return true;
			} else {
				return findElement(root.getRight(), data);
			}
		}
	}
	
	public static int sizeofTree(BinaryTreeNode root) {
		if(root == null)
			return 0;
		else
			return (sizeofTree(root.getLeft()) + 1 + sizeofTree(root.getRight())); 
	}
	
	
	public static int hightofTreeRecursive(BinaryTreeNode root) {
		int left, right;
		if(root == null)
			return 0;
		else {
			left = hightofTreeRecursive(root.getLeft());
			right = hightofTreeRecursive(root.getRight());
			if (left >= right) 
				return (left + 1);
			else 
				return (right + 1);
		}
	}
	
	public static int hightofTreeIterative(BinaryTreeNode root) {
		int level =0;
		if(root == null)
			return 0;
		else {
			Queue<BinaryTreeNode> q = new LinkedList<BinaryTreeNode>();
			q.add(root);
			q.add(null);
			while (!q.isEmpty()) {
				root = q.poll();
				if (root == null) {
					if (!q.isEmpty()) {
						q.add(null);
					}
					level++;
				} else {
					if (root.getLeft() != null)
						q.add(root.getLeft());
					if (root.getRight() != null)
						q.add(root.getRight());
				}
			}
		}
		return level;
	}
	public static void levelOrderReverse(BinaryTreeNode root) {
		if (root == null) 
			return;
		Queue<BinaryTreeNode> q= new LinkedList<BinaryTreeNode>();
		Stack<BinaryTreeNode> s = new Stack<BinaryTreeNode>();
		q.add(root);
		while (!q.isEmpty()) {
			root = q.poll();
			s.push(root);
			if (root.getRight() != null)
				q.add(root.getRight());
			if (root.getLeft() != null) {
				q.add(root.getLeft());
			}
		}
		while (!s.isEmpty()) {
			System.out.println(s.pop().getData());
		}
	}
	
	public static BinaryTreeNode  deleteElementFromTree(BinaryTreeNode root, int data) {
		if (root == null)
			return root;
		if (root.getData() == data) {
			root = null;
			return root;
		}
			
		BinaryTreeNode lastNode = null, temp;
		Queue<BinaryTreeNode> q= new LinkedList<BinaryTreeNode>();
		q.add(root);
		lastNode = findDeepestNode(root);
		while (!q.isEmpty()) {
			temp = q.poll();
			if (temp.getData() == data) {
				System.out.println("Deepest node is :" + lastNode.getData());
				temp.setData(lastNode.getData());
				//find parent node
			}
			//System.out.println(temp.getData());
			if (temp.getLeft() != null && !temp.getLeft().equals(lastNode)) {
				q.add(temp.getLeft());
			} else if(temp.getLeft() != null && temp.getLeft().equals(lastNode)) {
				temp.setLeft(null);
			}
			if (temp.getRight() != null && !temp.getRight().equals(lastNode)) {
				q.add(temp.getRight());
			} else if(temp.getRight() != null && temp.getRight().equals(lastNode)) {
				temp.setRight(null);
			}
		}
		return root;
	}
	
	
	public static BinaryTreeNode findDeepestNode(BinaryTreeNode root) {
		if (root == null) 
			return null;
		Queue<BinaryTreeNode> q= new LinkedList<BinaryTreeNode>();
		q.add(root);
		while (!q.isEmpty()) {
			root = q.poll();
			if (root.getLeft() != null) {
				q.add(root.getLeft());
			}
			if (root.getRight() != null)
				q.add(root.getRight());
		}
		return root;
		
	}
		
	public static long getDiameter(BinaryTreeNode root) {
        if (root != null) {
            long leftDiameter = getDiameter(root.getLeft());
            long rightDiameter = getDiameter(root.getRight());
            long leftHeight = getHeight(root.getLeft());
            long rightHeight = getHeight(root.getRight());
            return Math.max(leftHeight + rightHeight + 1, Math.max(leftDiameter, rightDiameter));
        }
        return 0;
    }

    public static long getHeight(BinaryTreeNode root) {
        if (root != null) {
            long leftHeight = getHeight(root.getLeft());
            long rightHeight = getHeight(root.getRight());
            return  1 + Math.max(leftHeight, rightHeight);
        }
        return 0;
    }
    
    public static void printAllPaths(BinaryTreeNode root, int[] path, int pathLen) {
    	if (root == null) return;
    	path[pathLen++] = root.getData();
    	if (root.getLeft() == null && root.getRight() == null) {
    		for (int i = 0 ; i < pathLen; i++)
    			System.out.print(path[i]);
    		System.out.println();
    	} else {
    		printAllPaths(root.getLeft(), path, pathLen);
    		printAllPaths(root.getRight(), path, pathLen);
    	}
    	
    }
    
    static void printnPathToNode(BinaryTreeNode root, BinaryTreeNode node, int[] path, int len) {
    	if (root == null || node == null) {
    		return;
    	}
    	path[len++] = root.getData();
    	if (root == node) {
    		for (int i= 0; i < len; i++) {
    			System.out.print(path[i] + " ");
    		}
    	}
    	printnPathToNode(root.getLeft(), node, path, len);
    	printnPathToNode(root.getRight(), node, path, len);
    }
    
    public static BinaryTreeNode findLCA(BinaryTreeNode root, BinaryTreeNode node1, BinaryTreeNode node2) {
    	BinaryTreeNode left, right;
    	if (root == null)
    		return root;
    	if (root.equals(node1) || root.equals(node2)) {
    		return root;
    	}
    	left = findLCA(root.getLeft(), node1, node2);
    	right = findLCA(root.getRight(), node1, node2);
    	if (left != null && right != null)
    		return root;
    	else 
    		return (left != null ? left : right);
    }
    
    
    public static BinaryTreeNode preOrderChar(char[] ch, int i) {
    	if (ch == null) return null;
    	BinaryTreeNode node = new BinaryTreeNode();
    	node.setData(ch[i]);
    	if (ch[i] == 'L')
    		return node;
    	node.setLeft(preOrderChar(ch, ++i));
    	node.setRight(preOrderChar(ch, ++i));
    	return node;
    	
    }
    public static void zigZagTraversal(BinaryTreeNode root) {
    	if (root == null)
    		return;
    	Stack<BinaryTreeNode> s = new Stack<BinaryTreeNode>();
    	s.push(root);
    	boolean b = true;
    	while (!s.isEmpty()) {
    		Stack<BinaryTreeNode> t = new Stack<BinaryTreeNode>();
    		while (!s.isEmpty()) {
    			BinaryTreeNode temp = s.pop();
        		System.out.print(temp.getData() + "\t");
    			if (b) {
    				if (temp.getLeft() != null)
    					t.push(temp.getLeft());
    				if (temp.getRight() != null)
    					t.push(temp.getRight());
    			} else {
    				if (temp.getRight() != null)
    					t.push(temp.getRight());
    				if (temp.getLeft() != null)
    					t.push(temp.getLeft());
    			}
    		}
    		b = !b;
    		s = t;
    	}
    }
    
    public static boolean isBST(BinaryTreeNode root, int min, int max) {
    	if (root == null) return true;
    	if (root.getData() <= min || root.getData() >= max)
    		return false;
    	return (isBST(root.getLeft(), min, root.getData()) && isBST(root.getRight(), root.getData(), max));
    }
    
    public static BinaryTreeNode convertListToBST(Iterator<Integer> it, int start, int end) {
    	
    	if (start > end)
    		return null;
    	int mid = start + (end-start)/2;
    	BinaryTreeNode node = new BinaryTreeNode();
    	node.setLeft(convertListToBST(it, start, mid-1));
    	node.setData(it.next());
    	node.setRight(convertListToBST(it, mid + 1, end));
    	return node;
    	
    }
    
    public static BinaryTreeNode convertArrayToBST(int[] array, int start, int end) {
    	if (start > end) return null;
    	BinaryTreeNode node = new BinaryTreeNode();
   		int mid = start + (end - start)/2;
   		node.setLeft(convertArrayToBST(array, start, mid-1));
   		node.setData(array[mid]);
   		node.setRight(convertArrayToBST(array, mid + 1, end));
    	return node;
    }
    
    public static BinaryTreeNode convertToLL(BinaryTreeNode root, BinaryTreeNode currentNode)
    {
 	   if(root == null)
 		   return currentNode;
 	   else
 	   {
 		   currentNode = convertToLL(root.getLeft(), currentNode);
 		   if(currentNode != root)
 		   {
 			   currentNode.setRight(root);
 			   root.setLeft(currentNode);
 			   currentNode = root;
 		   }
 		   return convertToLL(root.getRight(), currentNode);
 	   }
    }
    
    public static BinaryTreeNode findPredecessor(BinaryTreeNode node)
    {
    	return null;
    	/*
        if (node == null)
            return null;
        
        if (node.getLeft() != null)
            return findMaximum(node.getLeft());
                
        TreeNode parent = node.getParent();
    
        TreeNode y = parent;
        TreeNode x = node;
        while (y != null && x == y.getLeft())
        {
            x = y;
            y = y.getParent();
        }
        
        return y;
        */
    }
    
    public static BinaryTreeNode findSuccessor(BinaryTreeNode node)
    {
    	return null;
    	/*
        if (node == null)
            return null;
        
        if (node.getRight() != null)
            return findMinimum(node.getRight());
        
        BinaryTreeNode y = node.getParent();
        BinaryTreeNode x = node;
        while (y != null && x == y.getRight())
        {
            x = y;
            y = y.getParent();
        }
        // Intuition: as we traverse left up the tree we traverse smaller values
        // The first node on the right is the next larger number
        return y;
        */
    }
    
    public static int isTreeBalanced (BinaryTreeNode root) {
    	if (root == null) {
    		return 0;
    	}
    	int leftHeight = isTreeBalanced(root.getLeft());
    	if (leftHeight == -1)
    		return -1;
    	int rightHeight = isTreeBalanced(root.getRight());
    	if (rightHeight == -1)
    		return -1;
    	if (Math.abs(leftHeight - rightHeight) > 1)
    		return -1;
    	else
    		return (Math.max(leftHeight, leftHeight) + 1);
    }
    
    public static void levelOrderLinkedList(BinaryTreeNode root, LinkedList<LinkedList<BinaryTreeNode>> list) {
		LinkedList<BinaryTreeNode> levelList = new LinkedList<BinaryTreeNode>(); 
		if (root != null)
			levelList.add(root);
		while (levelList.size() > 0) {
			list.add(levelList);
			LinkedList<BinaryTreeNode> parentLevel = levelList;
			levelList = new LinkedList<BinaryTreeNode>();
			for (BinaryTreeNode node : parentLevel) {
				if(node.getLeft() != null)
					levelList.add(node.getLeft());
				if(node.getRight() != null)
					levelList.add(node.getRight());
			}
		}
    }
    
    public static BinaryTreeNode findCommonAnsector(BinaryTreeNode root, BinaryTreeNode a, BinaryTreeNode b) {
    	if (root == null)
    		return root;
    	if (root == a || root == b)
    		return root;
    	BinaryTreeNode left = findCommonAnsector(root.getLeft(), a, b);
    	BinaryTreeNode right = findCommonAnsector(root.getRight(), a, b);
    	if (left!= null && right != null) 
    		return root;
    	else 
    		return (left != null?left : right);
    }
    
    public static boolean isSubTree(BinaryTreeNode tree1, BinaryTreeNode tree2) {
    	if (tree1 == null)
    		return false;
    	if (tree2 == null)
    		return true;
    	if (tree1.getData() == tree2.getData()) {
    		return (isSubTreeHelper(tree1, tree2));
    	} else {
    		return (isSubTree(tree1.getLeft(), tree2) || isSubTree(tree1.getRight(), tree2));
    	}
    }
	private static boolean isSubTreeHelper(BinaryTreeNode tree1,
			BinaryTreeNode tree2) {
		if (tree1 == null && tree2 == null)
			return true;
		if (tree1 == null || tree2 == null)
			return false;
		return (tree1.getData() == tree2.getData() && isSubTreeHelper(tree1.getLeft(), tree2.getLeft()) && isSubTreeHelper(tree1.getRight(), tree2.getRight()));
	}
	
	static void kThSmallest(BinaryTreeNode root, int count, int k) {
		if (root == null || k < 0) {
			return;
		}
		kThSmallest(root.getLeft(),count,k);
		--k;
		if(k == 0) {
			System.out.println("Kth smallest element is :" + root.getData());
			return;
		}
		kThSmallest(root.getRight(), count, k);
	}

	static void isCousine(BinaryTreeNode root, BinaryTreeNode node1, BinaryTreeNode node2) {
		if (node1 == null || node2 == null)
			System.out.println("Not cousine");
		if (findLevel(root, node1, 1) == findLevel(root, node2, 1)
				&& !isSiblings(root, node1, node2))
			System.out.println("Cousines of eachother");
		else 
			System.out.println("Not cousines");
	}
	
	static int findLevel(BinaryTreeNode root, BinaryTreeNode node, int level) {
		if (root == null) {
			return -1;
		}
		if (root == node)
			return level;
		int leftLevel = findLevel(root.getLeft(), node, level + 1);
		if (leftLevel != -1)
			return leftLevel;
		
		return findLevel(root.getRight(), node , level + 1);
	}
	
	static boolean isSiblings(BinaryTreeNode root, BinaryTreeNode node1, BinaryTreeNode node2) {
		if (root == null)
			return false;
		return ((root.getLeft() == node1 && root.getRight() == node2)
				||(root.getRight() == node1 && root.getLeft() == node2)
				|| isSiblings(root.getLeft(), node1, node2)
				|| isSiblings(root.getRight(), node1, node2));
	}
	
	public static void main(String[] args) {
		BinaryTreeNode root1 = new BinaryTreeNode();
		root1.setData(18);
		BinaryTreeNode root2 = new BinaryTreeNode();
		root2.setData(22);
		BinaryTreeNode root3 = new BinaryTreeNode();
		root3.setData(16);
		BinaryTreeNode root4 = new BinaryTreeNode();
		root4.setData(19);
		BinaryTreeNode root5 = new BinaryTreeNode();
		root5.setData(21);
		BinaryTreeNode root6 = new BinaryTreeNode();
		root6.setData(23);
		BinaryTreeNode root7 = new BinaryTreeNode();
		root7.setData(15);
		BinaryTreeNode root8 = new BinaryTreeNode();
		root8.setData(25);
		BinaryTreeNode root9 = new BinaryTreeNode();
		root9.setData(17);
		BinaryTreeNode root = new BinaryTreeNode();
		root.setData(20);
		root.setLeft(root1);
		root.setRight(root2);
		root1.setLeft(root3);
		root1.setRight(root4);
		root2.setLeft(root5);
		root2.setRight(root6);
		root3.setLeft(root7);
		root3.setRight(root9);
		root6.setRight(root8);
		zigZagTraversal(root);
		System.out.println("-----------Get max sum-------------");
		System.out.println(getMaxSum(root, 0));
		System.out.println("-----------Cousines-------------");
		isCousine(root, root9, root6);
		System.out.println("-----------Kth Smallest-------------");
		kThSmallest(root, 0, 1);
		System.out.println("-----------PreOrder-------------");
		preOrder(root);
		System.out.println("--------------------------------");
		System.out.println("-----------InOrder-------------");
		inOrder(root);
		System.out.println("--------------------------------");
		System.out.println("-----------PostOrder-------------");
		postOrder(root);
		System.out.println("--------------------------------");
		System.out.println("-----------LevelOrder-------------");
		levelOrder(root);
		System.out.println("--------------------------------");
		System.out.println("----------Find Element Recursive-----------");
		findElement(root, 40);
		System.out.println("--------------------------------");
		System.out.println("----------Size of tree Recursive-------------");
		System.out.println("Size of tree is " + sizeofTree(root));
		System.out.println("--------------------------------");
		System.out.println("-----------LevelOrderReverse-------------");
		levelOrderReverse(root);
		System.out.println("--------------------------------");
		System.out.println("----------Height of tree Recursive-------------");
		System.out.println("Height of tree is " + hightofTreeRecursive(root));
		System.out.println("--------------------------------");
		System.out.println("----------Height of tree Iterative-------------");
		System.out.println("Height of tree is " + hightofTreeIterative(root));
		System.out.println("--------------------------------");
		if(isBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE))
			System.out.println("It is binary search tree");
		else 
			System.out.println("Not a binary serarch tree");
		LinkedList<LinkedList<BinaryTreeNode>> result = new LinkedList<LinkedList<BinaryTreeNode>>();
		levelOrderLinkedList(root, result);
		for (LinkedList<BinaryTreeNode> l : result) {
			for (BinaryTreeNode btn : l) {
				System.out.print(btn.getData());
			}
			System.out.println();
		}
		BinaryTreeNode nd = findCommonAnsector(root, root5, root7);
		root = deleteElementFromTree(root, 17);
		levelOrder(root);
		BinaryTreeNode temp = new BinaryTreeNode();
		temp.setData(18);
		
		temp = deleteElementFromTree(temp, 18);
		levelOrder(temp);
		
		System.out.println("Diameter is " + getDiameter(root));
		printAllPaths(root, new int[256], 0);
		System.out.println("Path to node is ");
		printnPathToNode(root, root3, new int[256], 0);
		System.out.println();
		System.out.println("LCA is :" + findLCA(root, root3, root4).getData());
		System.out.println("-----------Zigzag-------------");
		zigZagTraversal(root);
		System.out.println();
		System.out.println("------------------------------");
		temp = preOrderChar(new char[] {'I', 'L', 'I', 'L', 'L'}, 0);
		levelOrder(temp);
		root7.setRight(root8);
		if(isBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE))
			System.out.println("It is binary search tree");
		else 
			System.out.println("Not a binary serarch tree");
		int[] array = new int[]{2,3,4,5,6,7,8,9,10};
		List<Integer> list = Arrays.asList(new Integer[]{2,3,4,5,6,7,8,9,10});
		BinaryTreeNode node1 = convertListToBST(list.iterator(), 0, list.size() - 1);
		levelOrder(node1);
		BinaryTreeNode node2 = convertArrayToBST(array, 0, array.length - 1);
		levelOrder(node2);
		
		BinaryTreeNode node = new BinaryTreeNode();
		node.setLeft(root1);
		//node.setRight(root2);
		root1.setLeft(root3);
		root3.setRight(root4);
		root4.setRight(root5);
		if(isTreeBalanced(node) != -1) {
			System.out.println("The Tree is balanced");
		} else {
			System.out.println("The tree is not balanced");
		}
		if (nd != null) {
			System.out.println("common ansector is : " + nd.getData());
		}
		if (isSubTree(root, node2)){
			System.out.println("Subtree of a given tree");
		} else {
			System.out.println("Not a subtree");
		}
		int[] array1 = new int[(int) getHeight(node1)];
		printPathWithSum(node1, 21 , array1, 0);
	}
	
	/*
	private static void findAllPathsOfSum(BinaryTreeNode root, int sum,
			int[] path, int level) {
		if(root == null)
			return;
		
		path[level] = root.getData();
	
		int currentSum = 0;
		for(int i = level; i >=0; i--)
		{
			currentSum += path[i];
		if(currentSum == sum)
			printPath(path, i, level);
		}
		findAllPathsOfSum(root.getLeft(),sum,  path, level +1);
		findAllPathsOfSum(root.getRight(),sum,  path, level + 1);
	}
	*/

	static void printPathWithSum(BinaryTreeNode root, int sum, int[] array, int len) {
		if (root == null) {
			return;
		} else {
			array[len] = root.getData();
			int pathSum = 0;
			for (int i = len ; i >=0 ; i--) {
				pathSum += array[i];
				if (pathSum == sum) {
					printPath(array, i, len);
				}
			}
			printPathWithSum(root.getLeft(), sum, array, len + 1);
			printPathWithSum(root.getRight(), sum, array, len + 1);
			array[len] = Integer.MIN_VALUE;
		}
		
	}
	

	private static void printPath(int[] array, int i, int len) {
		for (int j = i ; j <= len ; j++) {
			System.out.print(array[j] + " ");
		}
		System.out.println();
		
	}
	

}
/*Permute arraylist*/
public static ArrayList<ArrayList<Integer>> permuteArray(ArrayList<Integer> a){
			ArrayList<ArrayList<Integer>> arrL = new ArrayList<>();
			if(a.size()==1)
			{
				ArrayList<Integer> t = new ArrayList<>();
				t.add(a.get(0));
				arrL.add(t);
				return arrL;
			}
			int x = a.get(0);
			ArrayList<Integer> t = new ArrayList<>();
			for(int i=1;i<a.size();i++)
				t.add(a.get(i));
			ArrayList<ArrayList<Integer>> temp = permuteArray(t);
			for(int i=0;i<temp.size();i++){
				ArrayList<Integer> y = temp.get(i);
				for(int j=0;j<y.size();j++){
					ArrayList<Integer> z = new ArrayList<>();
					for(int k=0;k<y.size();k++){
						if(j==k)
							z.add(x);
						z.add(y.get(k));
					}
					arrL.add(z);
				}
				y.add(x);
				arrL.add(y);
			}
			return arrL;
		}

/*Permutation of Strings*/
public static ArrayList<String> getPermutations(String s){
			if(s==null)
				return null;
			ArrayList<String> a = new ArrayList<>();
			if(s.length()==1)
				a.add(s);
			else{
				char c = s.charAt(0);
				String str="";
				for(int j=0;j<s.length();j++)
					if(j!=0)
						str+=s.charAt(j);
				ArrayList<String> t = getPermutations(str);
				for(int j=0;j<t.size();j++){
					String string = t.get(j);
					String temp="";
					for(int k=0;k<string.length();k++){
						temp="";
						for(int l=0;l<string.length();l++){
							if(l==k)
								temp+=c;
							temp+=string.charAt(l);
						}
						a.add(temp);
					}
					a.add(string+c);
				}
			}
			return a;
		}

/*Questions related to Searching*/
package hardik.code;

public class Searching {

	//need a sorted array
	public static void searchMaxOccurence(int[] A) {
		int   currentElement = A[0], maxElement = 0;
		int currentCount = 0, maxCount = 0;
		for (int i = 0; i < A.length; i++) {
			if(A[i] == currentElement) {
				currentCount++;
			} else {
				currentElement = A[i];
				currentCount = 1;
			}
			if (currentCount > maxCount) {
				maxCount = currentCount;
				maxElement = currentElement;
			}
		}
		System.out.println("Max Element " + maxElement + "Max Count " + maxCount);
	}
	
	public static int indexOfFirstOccurence(int[] A, int left, int right, int data) {
		if(left<=right) {
			int mid = left + (right - left)/2;
			if ((A[mid] == data && mid == left) || (A[mid] == data && A[mid-1] < A[mid])) {
				return mid;
			} else if (A[mid] >= data) {
				return indexOfFirstOccurence(A, left, mid-1, data);
			} else {
				return indexOfFirstOccurence(A, mid+1, right, data);
			} 
		}
		return -1;
	}
	
	public static int singleElementWithAllOtherEven(int[] A) {
		int res = 0;
		for (int i=0; i < A.length ; i++ ) {
			res = res ^ A[i];
		}
		return res;
	}
	public static void main(String[] args) {
		int[] A = new int[] {1,2,2,2,2,3,3,3,4,4,4};
		searchMaxOccurence(A);
		System.out.println("Index of First Occurence" + indexOfFirstOccurence(A, 0, (A.length-1), 2));
		int[] B = new int[] {1,2,2,3,5,3,4,4,1};
		System.out.println("Alone element is :" + singleElementWithAllOtherEven(B));
	}
}

/*Longest palindrome in a string*/
package hardik.code;

public class LongestPalindrome {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
	String S= "abcdcba";
	printLongestPalindrome(S);
	}
	
	
	public static void printLongestPalindrome(String S)
	{
		int maxBack=-1;
		int maxFront = -1;
		int maxLength=0;
		for (int potentialCenter = 0 ; potentialCenter < S.length();potentialCenter ++ )
		{	
			int back = potentialCenter-1;
			int front = potentialCenter + 1;
			int longestPalindrome = 0;
			while(back >=0 && front<S.length() && S.charAt(back)==S.charAt(front))
			{
				back--;
				front++;
				longestPalindrome++;
				
			}
			if (longestPalindrome > maxLength)
			{
				maxLength = longestPalindrome+1;
				maxBack = back + 1;
				maxFront = front;
			}
			back = potentialCenter;
			front = potentialCenter + 1;
			longestPalindrome=0;
			while(back >=0 && front<S.length() && S.charAt(back)==S.charAt(front))
			{
				back--;
				front++;
				longestPalindrome++;
			}
			if (longestPalindrome > maxLength)
			{
				maxLength = longestPalindrome;
				maxBack = back + 1;
				maxFront = front;
			}
			
		}
		
		
		if (maxLength == 0) System.out.println("There is no Palindrome in the given String");
		else{
			System.out.println("The Longest Palindrome is " + S.substring(maxBack,maxFront) + "of " + maxLength);
		}
	}

}

/*List questions by hardik*/
package hardik.code;

import java.util.HashMap;
import java.util.Stack;

public class ListNodeExamples {

	static int findLength(ListNode head) {
		int length = 0;
		while (head != null) {
			head = head.getNext();
			length++;
		}
		return length;
	}
	
	static void printList(ListNode head) {
		while (head != null) {
			System.out.print(head.getData() + "->");
			head = head.getNext();
		}
	}
	
	public static ListNode mergeLinkedList(ListNode node1, ListNode node2)
	{
		if(node1 == null)
			return node2;
		if(node2 == null)
			return node1;
			
		ListNode head = new ListNode();
		ListNode currNode = head;
		ListNode node = null;
		while(node1 != null && node2 != null)
		{
			ListNode newNode = new ListNode();
			if(node1.getData() <= node2.getData())
			{
				newNode.setData(node1.getData());
				node1 = node1.getNext();
			}
			else
			{
				newNode.setData(node2.getData());
				node2 = node2.getNext();
			}	
			currNode.setNext(newNode);
			currNode =newNode;
		}
		
		if(node1 == null)
			 node = node2;	
		else
			 node = node1;	
		
		while(node!=null)
			{
				ListNode newNode = new ListNode();
				newNode.setData(node.getData());
				node = node.getNext();
				currNode.setNext(newNode);
				currNode =newNode;
			}
		
		node = head;
		head = head.getNext();
		currNode.next = null;
		node = null;
		
		printList(head);
		
		return head;
		
	}
	
	public static ListNode mergeSortUsingRecursion(ListNode node1, ListNode node2){
		
		ListNode result= null;
		if(node1 == null)
			return  node2;
		if(node2 == null)
			return node1;
		
		if(node1.getData() <= node2.getData())
		{
			result = node1;
			result.setNext(mergeSortUsingRecursion(node1.getNext(), node2));
		}
		else
		{
			result = node2;
			result.setNext(mergeSortUsingRecursion(node1, node2.getNext()));
		}
		
		return result;
	}
	
	public static ListNode mergeSortUsingIteration(ListNode a, ListNode b) {
	    ListNode dummyHead, curr; dummyHead = new ListNode(); curr = dummyHead;
	    while(a !=null && b!= null) {
	        if(a.data <= b.data)
	        	{ curr.next = a; a = a.next; }
	        else 
	        	{ curr.next = b; b = b.next; }
	        curr = curr.next;
	    }
	    curr.next = (a == null) ? b : a;
	    return dummyHead.next;
	}
	
	static ListNode insertElement(ListNode head, int position, ListNode newNode) {
		if (head == null) {
			head = newNode;
			return head;
		}
		if (position == 1) {
			newNode.setNext(head);
			return newNode;
		} else {
			ListNode temp = head, nextNode;
			int count = 1;
			while (count < position - 1) {
				temp = temp.getNext();
				count++;
			}
			nextNode = temp.getNext();
			newNode.setNext(nextNode);
			temp.setNext(newNode);
		}
		
		return head;
	}
	
	static void findNthNodeFromEnd(ListNode head, int n) {
		int length = findLength(head);
		if (n > length || n <=0 || head == null)
			return;
		for (int i =0 ; i < length - n ; i++) {
			head = head.getNext();
		}
		System.out.println("nth node is : " + head.getData());
	}
	
	static void findNthNodeFromEndInOneScan(ListNode head, int n) {
		if(head == null || n <0)
				return;
		ListNode intialPtr = head;
		ListNode finalPtr = head;
		
		for(int i=1; i <n; i++)
		{
			if(intialPtr!=null)
				intialPtr = intialPtr.next; 
		}
		
		if(intialPtr == null)
			System.out.println("Out of bounds");
		else
		{
			while(intialPtr.next != null)
			{
				intialPtr = intialPtr.next;
				finalPtr = finalPtr.next;
			}
			System.out.println("nth node is : " + finalPtr.getData());
		}
		
	}
	
	static int findKthNodeFromEndUsingRecursion(ListNode head, int k, Integer i) {
		if (head == null)
			return i;
		i = findKthNodeFromEndUsingRecursion(head.getNext(), k, i);
		i = i + 1;
		if (i == k) {
			System.out.println("Kth Node is :" + head.getData());
			return i;
		}
		return i;
	}
	static void findCycle(ListNode head) {
		if (head == null)
			System.out.println("No Cycle");
		ListNode fastPtr = head, slowPtr = head;
		boolean loopExists = false;
		while (fastPtr != null && fastPtr.getNext() != null) {
			fastPtr = fastPtr.getNext().getNext();
			slowPtr = slowPtr.getNext();
			if (slowPtr == fastPtr) {
				System.out.println("There is a Cycle");
				loopExists = true;
				break;
			}
		}
		if (!loopExists)
			System.out.println("No Cycle");
	}
	
	static void findStartOfCycle(ListNode head) {
		if (head == null)
			System.out.println("No Cycle");
		ListNode fastPtr = head, slowPtr = head;
		boolean loopExists = false;
		while (fastPtr != null && fastPtr.getNext() != null) {
			fastPtr = fastPtr.getNext().getNext();
			slowPtr = slowPtr.getNext();
			if (slowPtr == fastPtr) {
				System.out.println("There is a Cycle");
				loopExists = true;
				break;
			}
		}
		if (loopExists) {
			slowPtr = head;
			while (slowPtr != fastPtr) {
				slowPtr = slowPtr.getNext();
				fastPtr = fastPtr.getNext();
			}
			System.out.println("Start of the loop is : " + slowPtr.getData());
		}
			
	}
	static void findNodeCountInCycle(ListNode head) {
		if (head == null)
			System.out.println("No Cycle");
		ListNode fastPtr = head, slowPtr = head;
		boolean loopExists = false;
		while (fastPtr != null && fastPtr.getNext() != null) {
			fastPtr = fastPtr.getNext().getNext();
			slowPtr = slowPtr.getNext();
			if (slowPtr == fastPtr) {
				System.out.println("There is a Cycle");
				loopExists = true;
				break;
			}
		}
		if (loopExists) {
			int count = 1;
			fastPtr = fastPtr.getNext();
			while (slowPtr != fastPtr) {
				fastPtr = fastPtr.getNext();
				count++;
			}
			System.out.println("Node count in loop is : " + count);
		}
			
	}
	
	static void EvenOddLength(ListNode head) {
		if (head == null)
			System.out.println("No Cycle");
		ListNode fastPtr = head, slowPtr = head;
		while (fastPtr.next != null && fastPtr.getNext().getNext() != null) {
			fastPtr = fastPtr.getNext().getNext();
			slowPtr = slowPtr.getNext();
		}
		if (fastPtr.next == null) {
			System.out.println("Odd Length List");
		} else {
			System.out.println("Even Length List");
		}
	}
	
	static ListNode insertInSortedLinkedList(ListNode head, ListNode newNode) {
		if (head == null) {
			head = newNode;
			return head;
		}
		ListNode parent = head ,temp = head , nextNode;
		while (temp != null && temp.getData() < newNode.getData()) {
			parent = temp;
			temp = temp.getNext();
		}
		nextNode = parent.getNext();
		parent.setNext(newNode);
		newNode.setNext(nextNode);
		return head;
			
	}
	
	static ListNode reverseList(ListNode head) {
		ListNode temp = null, nextNode = null, current = head;
		while (current != null) {
			nextNode = current.getNext();
			current.setNext(temp);
			temp = current;
			current = nextNode;
			
		}
		return temp;
	}
	
	static void findMergingPoint(ListNode head1, ListNode head2) {
		if (head1 ==null || head2 == null) {
			System.out.println("No merging point");
			return;
		}
		int length1 = findLength(head1);
		int length2 = findLength(head2);
		int diff = Math.abs(length1 - length2);
		if (length1 > length2) {
			for (int i = 0 ; i < diff; i ++) {
				head1 = head1.getNext();
			}
		} else {
			for (int i = 0 ; i < diff; i ++) {
				head2 = head2.getNext();
			}
		}
		while (head1 != null && head2 != null) {
			if (head1 == head2) {
				System.out.println("Merging point is :" + head1.getData());
				return;
			} 
			head1 = head1.getNext();
			head2 = head2.getNext();
		}
	}
	
	static void findMiddleNode(ListNode head) {
		if (head == null)
			System.out.println("No Cycle");
		ListNode fastPtr = head, slowPtr = head;
		while (fastPtr != null && fastPtr.getNext() != null) {
			fastPtr = fastPtr.getNext().getNext();
			slowPtr = slowPtr.getNext();
		}
		if (fastPtr == null) {
			System.out.println("Middle Node- odd Length is : " + slowPtr.getData());
			return;
		}
		if (fastPtr.getNext() == null) {
			System.out.println("Middle Node - even length is : " + slowPtr.getNext().getData());
			return;
		}
			
	}
	
	static ListNode reverseListPair(ListNode head) {
		ListNode temp = null, tmp1 = null; 
		while (head != null && head.getNext() != null) {
			if (temp != null)
				temp.getNext().setNext(head.getNext());
			temp = head.getNext();
			head.setNext(temp.getNext());
			temp.setNext(head);
			if (tmp1 == null)
				tmp1 = temp;
			head = head.getNext();
		}
		return tmp1;
	}
	
	static ListNode reverseListByPairByHardik(ListNode head)
	{
		ListNode reverseFrom, reverseTo = null, currentNode, resultNode = null;
		currentNode = head;
		
		if(currentNode == null || currentNode.next == null)
			return currentNode;
		
		while(currentNode != null && currentNode.getNext() != null)
		{
			reverseTo = currentNode;
			reverseFrom = currentNode.getNext();
			
			if(resultNode == null)
				resultNode = reverseFrom;
			
			if(currentNode.getNext().getNext() != null)
			{
				currentNode = currentNode.getNext().getNext();
				reverseTo.next = currentNode.next;
			}	
				
			//reverse pair
			reverseFrom.next = reverseTo;
		}
		
		if(currentNode.next == null)
			reverseTo.next = currentNode;
		else
			reverseTo.next = null;
			
		return resultNode;
	}
	
	static void displayLinkedListReverse(ListNode head) {
		if (head == null)
			return;
		else {
			displayLinkedListReverse(head.getNext());
			System.out.print(head.getData() + "->");
		}
	}
	
	static void isListPalindrome(ListNode head) {
		if (head == null) {
			System.out.println("Not palindrom");
			return;
		}
		if (head.getNext() == null) {
			System.out.println("palindrom");
			return;
		}
		ListNode fastPtr = head, slowPtr = head;
		Stack<ListNode> stack = new Stack<ListNode>();
		while (fastPtr != null && fastPtr.getNext() != null) {
			fastPtr = fastPtr.getNext().getNext();
			slowPtr = slowPtr.getNext();
		}
		if (fastPtr == null) {
			while (slowPtr != null) {
				stack.push(slowPtr);
				slowPtr = slowPtr.getNext();
			}
		} else {
			slowPtr = slowPtr.getNext();
			while (slowPtr != null) {
				stack.push(slowPtr);
				slowPtr = slowPtr.getNext();
			}
		}
		while (!stack.isEmpty()) {
			if (head.getData() != stack.pop().getData()) {
				System.out.println("Not Palindrom");
				return;
			}
			head = head.getNext();
		}
		System.out.println("list is Palindrom");
			
	}
	
	static ListNode removeDuplicates(ListNode head) {
		if (head == null)
			return head;
		HashMap<Integer, Boolean> map = new HashMap<Integer, Boolean>();
		ListNode temp = head, previous = null;
		while (temp != null) {
			if (map.containsKey(temp.getData())) {
				previous.setNext(temp.getNext());
			} else {
				previous = temp;
				map.put(temp.getData(), true);
			}
			temp = temp.getNext();
		}
		return head;
	}
	
	static ListNode partitionList(ListNode head, int x) {
		if (head == null)
			return head;
		ListNode beforeStart = null, afterStart = null, next = null;
		while (head != null) {
			next = head.getNext();
			if (head.getData() < x) {
				head.setNext(beforeStart);
				beforeStart = head;
			} else {
				head.setNext(afterStart);
				afterStart = head;
			}
			head = next;
		}
		if (beforeStart == null)
			return afterStart;
		head = beforeStart;
		while (beforeStart.getNext() != null) {
			beforeStart = beforeStart.getNext();
		}
		beforeStart.setNext(afterStart);
		return head;
	}
	
	static ListNode removeDuplicatesWithoutBuffer(ListNode head) {
		if (head == null)
			return head;
		ListNode temp = null, current = head;
		while (current != null) {
			temp = current;
			while (temp.getNext() != null) {
				if (temp.getNext().getData() == current.getData()) {
					temp.setNext(temp.getNext().getNext());
				} else {
					temp = temp.getNext();
				}
			}
			current = current.getNext();
		}
		return head;
	}
	
	static ListNode addTwoList(ListNode head1, ListNode head2, int carry) {
		if (head1 == null && head2 ==null && carry ==0) {
			return null;
		}
		ListNode result = new ListNode();
		int value = carry;
		if (head2 != null) 
			value += head2.getData();
		if (head1 != null) 
			value += head1.getData();
		result.setData(value%10);
		if (head1 != null || head2 != null) {
			ListNode node = addTwoList(head1 != null ? head1.getNext() : null,
									   head2 != null ? head2.getNext() : null,
									   value > 9 ? 1 :0);
			result.setNext(node);
		}
		return result;
	}
	
	public static ListNode addTwoReversedList(ListNode head1,ListNode head2)
	{
		if(head1 == null)
			return head2;
		
		if(head2 == null)
			return head1;
		
		int l1 = findLength(head1);
		int l2 = findLength(head2);
		
		if(l1<l2)
			head1 = appendNode(head1, l2-l1);
		else if(l2<l1)
			head2 = appendNode(head2, l1-l2);
		
		AddObject addObject = addLinkedListRecursively(head1, head2, 0);
		
		if(addObject.carry == 0)
			return addObject.node;
		else
		{
			ListNode currentNode = new ListNode(1, addObject.node);
			return currentNode;
		}
	}
	
	private static AddObject addLinkedListRecursively(ListNode head1,
			ListNode head2, int carry) {
		
		if(head1== null && head2 == null && carry == 0)
		{
			AddObject nullObj = new AddObject();
			return nullObj;
		}
		
		AddObject previousObj = addLinkedListRecursively(head1.next, head2.next, carry);
		
		int addResult = head1.data + head2.data + previousObj.carry;
		if(addResult > 9)
			carry  = 1;
		else
			carry = 0;
		ListNode currentNode = new ListNode(addResult%10, previousObj.node);
		previousObj.node = currentNode;
		previousObj.carry = carry;
		
		return previousObj;
	}

	private static ListNode appendNode(ListNode head, int n) {
		ListNode newNode = null;
		
		for(int i = 0; i < n; i++)
		{
			newNode = new ListNode(0, head);
			head = newNode;
		}
		
		return head;
	}

	public static void main(String[] args) {
		System.out.println("----------------------Sum of linked list started-----------------------------------");
		ListNode add7 = new ListNode(4, null);
		ListNode add3 = new ListNode(3, add7);
		ListNode add2 = new ListNode(2, add3);
		ListNode add1 = new ListNode(1, add2);
		
		ListNode add6 = new ListNode(7, null);
		ListNode add5 = new ListNode(5, add6);
		ListNode add4 = new ListNode(9, add5);
		
		//ListNode sum = addTwoList(add1, add2, 0);
		ListNode sum = addTwoReversedList(add1, add4);
		while(sum != null) {
			System.out.print(sum.getData() + " ");
			sum = sum.getNext();
		}
		
		System.out.println("----------------------Sum of linked list completed-----------------------------------");
		
		ListNode node6 = new ListNode(5, null);
		ListNode node5 = new ListNode(7, node6);
		ListNode node4 = new ListNode(9, node5);
		ListNode node3 = new ListNode(10, node4);
		ListNode node2 = new ListNode(12, node3);
		ListNode node1 = new ListNode(15, node2);
		ListNode head = new ListNode(2, node1);
		
		ListNode head2node2 = new ListNode(3, null);
		ListNode head2node1 = new ListNode(2, head2node2);
		ListNode head2 = new ListNode(1, head2node1);
		
		System.out.println("----------------Merged list is ------------------");
		mergeLinkedList(head, head2);
		System.out.println();
		System.out.println("----------------Merged list using recursion ------------------");
		ListNode node = mergeSortUsingRecursion(head, head2);
		printList(node);
		System.out.println("Length is :" + findLength(head));
		EvenOddLength(head);
		printList(head);
		ListNode newNode = new ListNode(8, null);
		head = insertElement(head, 6, newNode);
		System.out.println();
		printList(head);
		ListNode temp = null;
		newNode = new ListNode(8, null);
		temp = insertElement(temp, 1, newNode);
		System.out.println();
		printList(temp);
		temp = insertElement(temp, 2, node6);
		System.out.println();
		printList(temp);
		System.out.println();
		findNthNodeFromEnd(head, 2);
		findNthNodeFromEndInOneScan(head, 15);
		System.out.println("-----------------------Using recursion------------------------------");
		findKthNodeFromEndUsingRecursion(head, 2, 0);
		System.out.println("Length is :" + findLength(head));
		EvenOddLength(head);
		findCycle(head);
		printList(head);
		System.out.println("After this head has cycle");
		node6.setNext(node3);
		newNode = new ListNode(2, node1);
		//printList(newNode);
		findCycle(newNode);
		findStartOfCycle(newNode);
		findNodeCountInCycle(newNode);
		ListNode sortedNode = new ListNode(6, null);
		ListNode sortedNode1 = new ListNode(5, null);
		ListNode sortedNode2 = new ListNode(4, sortedNode1);
		ListNode sortedHead = new ListNode(3, sortedNode2);
		sortedHead = insertInSortedLinkedList(sortedHead, sortedNode);
		printList(sortedHead);
		System.out.println();
		sortedHead = reverseList(sortedHead);
		printList(sortedHead);
		System.out.println();
		node6.setNext(null);
		sortedNode1 = new ListNode(5, node3);
		sortedNode2 = new ListNode(4, sortedNode1);
		sortedHead = new ListNode(3, sortedNode2);
		printList(sortedHead);
		System.out.println();
		printList(head);
		System.out.println();
		findMergingPoint(head, sortedHead);
		/*sortedNode2 = new ListNode(4, node3);
		sortedHead = new ListNode(3, sortedNode2);
		printList(sortedHead);*/
		System.out.println();
		findMiddleNode(head);
		displayLinkedListReverse(head);
		System.out.println("Remove duplicates ");
		sortedHead = removeDuplicatesWithoutBuffer(sortedHead);
		printList(sortedHead);
		System.out.println("List reversal in pair");
		printList(head);
		sortedHead = reverseListPair(head);
		System.out.println();
		printList(sortedHead);
		System.out.println();
		System.out.println("-------------Another approach by hardik for list reversal in pair----------------");
		printList(sortedHead);
		sortedHead = reverseListByPairByHardik(sortedHead);
		System.out.println();
		printList(sortedHead);
		System.out.println();
		ListNode d = new ListNode(4, null);
		ListNode a = new ListNode(3, d);
		ListNode b = new ListNode(3, a);
		ListNode c = new ListNode(4, b);
		isListPalindrome(c);
		
		System.out.println("---------------partition list-------------------------------");
		printList(sortedHead);
		System.out.println();
		sortedHead = partitionList(sortedHead, 8);
		printList(sortedHead);
		System.out.println();
		
		modularNode(head, 3);
		modularNodeFromEnd(head, 3);
		
		findMthPlayerByElimination(5,3);
		
		ListNode nnode10 = new ListNode(10, null);
		ListNode nnode9 = new ListNode(9, nnode10);
		ListNode nnode8 = new ListNode(8, nnode9);
		ListNode nnode7 = new ListNode(7, nnode8);
		ListNode nnode6 = new ListNode(6, nnode7);
		ListNode nnode5 = new ListNode(5, nnode6);
		ListNode nnode4 = new ListNode(4, nnode5);
		ListNode nnode3 = new ListNode(3, nnode4);
		ListNode nnode2 = new ListNode(2, nnode3);
		ListNode nnode1 = new ListNode(1, nnode2);
		ListNode headNew = new ListNode(0, nnode1);
		
		System.out.println();
		printList(headNew);
		ListNode tail =reverseByBlockSize(headNew, 1);
		System.out.println();
		printList(tail);
	}
	
	public static void modularNode(ListNode  head, int k)
	{
		printList(head);
		if(head == null)
			System.out.println("Not possible");
		
		if(k<0)
			System.out.println("Not possible");
		
		int i=1;
		ListNode modularNode = null;
		while(head != null)
		{
			if(i%k ==0)
				modularNode = head;
			
			i++;
			head =head.next;
		}
		
		System.out.println("Modular Node is " + modularNode.data);
	}
	
	public static void modularNodeFromEnd(ListNode head, int k)
	{
		if(head == null)
			System.out.println("Not possible");
		
		if(k<0)
			System.out.println("Not possible");
		ListNode fast = head;
		ListNode slow =head;
		for(int i=0; i<k; i++)
		{
			if(fast!=null)
				fast = fast.next;
		}
		
		while(fast.next!=null)
		{
			fast = fast.next;
			slow = slow.next;
		}
		
		System.out.println("Moduluar node from end is " + slow.data);
	}
	
	/* Find mth player by elemination of mth player every time from a circle*/
	public static void findMthPlayerByElimination(int n, int m)
	{
		// Create a circular linked list
		ListNode head = new ListNode();
		head.data = 1;
		
		ListNode currentNode = head;
		ListNode  newNode = null;
		for(int i =2; i <= n; i++)
		{
			newNode = new ListNode();
			newNode.data = i;
			currentNode.next = newNode;
			currentNode = newNode;
		}
		
		currentNode.next = head;
		
		//Eliminate the mth player
		 for(int i = n; i >1; i--)
		 {
			 for(int j = 1; j < m; j++)
			 {
				 currentNode = currentNode.next;
			 }
			 currentNode.next = currentNode.next.next;
		 }
		 
		 System.out.println("The final player to win is " + currentNode.getData()); 
	}

	public static ListNode reverseByBlockSize(ListNode head, int size)
	{
		if(head == null)
			return null;

		if(hasKNodes(head, size))
		{
			ListNode tail = reverse(head, size);
			head.setNext(reverseByBlockSize(head.next, size));
			return tail;
		}
		else
			return head;
	}
	
	static boolean hasKNodes(ListNode currentNode, int k)
	{
		int count = 1;
		while(currentNode.next != null && count < k)
		{
			currentNode = currentNode.next;
			count++;
		}
		
		if(count == k)
			return true;
		else
			return false;	
	}
	
	static ListNode reverse(ListNode head, int size)
	{
		ListNode previousNode = null, nextNode = null, currentNode = head;
		int count = 1;
		
		while(count <= size && currentNode != null)
		{
			nextNode = currentNode.next;
			currentNode.next = previousNode;
			previousNode = currentNode;
			currentNode = nextNode;
			count++;
		}
		head.next = currentNode;
		
		return previousNode;
	}
}

 class AddObject{
	 
	 public int carry = 0;
	 public ListNode node = null;
	
}
/*Stack of Stacks*/
package hardik.code;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class StackOfStacks<E> extends Stack<E>{

	private static final long serialVersionUID = 1L;
	List<Stack<E>> list;
	private int capacity;
	
	public StackOfStacks(int capacity) {
		this.capacity = capacity;
		list = new ArrayList<Stack<E>>(capacity);
	}
	
	private Stack<E> getLastStack() {
		if (list.size() ==0)
			return null;
		return (list.get(list.size() - 1));
	}
	
	public E push(E data) {
		Stack<E> lastStack = getLastStack();
		if (lastStack != null && lastStack.size() != capacity) {
			lastStack.push(data);
		} else {
			Stack<E> stack = new Stack<E>();
			stack.push(data);
			list.add(stack);
		}
		return data;
	}
	
	public E pop() {
		Stack<E> lastStack = getLastStack();
		if (lastStack == null) {
			return null;
		}
		E data = lastStack.pop();
		if (lastStack.size() == 0) 
			list.remove(lastStack);
		return data;
	}
	
	public boolean isEmpty() {
		return (list.size() == 0);
	}
}
/*Stack questions by hardik*/
package hardik.code;

import java.util.Stack;

public class StackExamples {
	
	static void reverseStack(Stack<Integer> s) {
		if (s.isEmpty())
			return;
		int temp = s.pop();
		reverseStack(s);
		insertAtBottom(s, temp);
	}

	private static void insertAtBottom(Stack<Integer> s, int data) {
		if (s.isEmpty()) {
			s.push(data);
			return;
		}
		int temp = s.pop();
		insertAtBottom(s, data);
		s.push(temp);
	}
	
	//working (descending order) For ascending order, reverse the sign
	static Stack<Integer> sortStackTest(Stack<Integer> s) {
		if (s.isEmpty())
			return null;
		Stack<Integer> reverseStack = new Stack<Integer>();
		while (!s.isEmpty()) {
			int temp = s.pop();
			while(!reverseStack.isEmpty() && reverseStack.peek() > temp) {
				s.push(reverseStack.pop());
			}
			reverseStack.push(temp);
		}
		return reverseStack;
	}
	
	static void sortStack(Stack<Integer> s) {
		if (s.isEmpty())
			return;
		int temp = s.pop();
		sortStack(s);
		insert(s, temp);
	}
	
	private static void insert(Stack<Integer> s, int data) {
		if(!s.isEmpty() && s.peek() < data) {
			int temp = s.pop();
			insert(s, data);
			s.push(temp);
		} else {
			s.push(data);
		}
	}
	
	public static int[] getSpanByMe(int[] arr)
	{
		if(arr.length < 0)
			return null;
		
		int[] result = new int[arr.length];
		
		result[0] =1;
		int currMax = arr[0];
		
		for(int i =1; i< arr.length; i++)
		{
			if(arr[i] < currMax)
			{
				result[i] = 1;
			}
			else
				result[i] = result[i-1] +1;
			
			currMax = arr[i];
		}
		for (int i : result) {
			System.out.print(i + " ");
		}
		return result;
	}

	static int[] findSpan(int[] array) {
		int[] spanArray = new int[array.length]; 
		for (int i = 0; i < array.length ; i++) {
			int span = 1;
			int j = i-1;
			while (j>=0 && array[j] <= array[j+1]) {
				span++;
				j--;
			}
			spanArray[i] = span;
		}
		for (int i : spanArray) {
			System.out.print(i + " ");
		}
		return spanArray;
	}
	
	public static void removeAdjacentDuplicateUsingStack(int[] arr)
	{
		if(arr == null)
			System.out.println("Array is null");
		else{

			Stack<Integer> st = new Stack<Integer>();
			st.push(arr[0]);
			boolean isDuplicate;

			for (int i = 1; i < arr.length; i++) {
				isDuplicate = false;

				while (!st.isEmpty() && arr[i] == st.peek()) {
					i++;
					isDuplicate = true;
				}

				if (isDuplicate) {
					st.pop();
					i--;
				} else
					st.push(arr[i]);
			}

			while (!st.isEmpty()) {
				System.out.print(st.pop() + "\t");
			}
		}
		
	}
	
	static void removeAdjacentDuplicates(int[] array) {
		int stackPointer = -1;
		for (int i =0; i < array.length;) {
			if (stackPointer == - 1 || array[stackPointer] != array[i]) {
				stackPointer++;
				array[stackPointer] = array[i];
				i++;
			} else {
				while(i < array.length && array[i] ==array[stackPointer]) {
					i++;
				}
				stackPointer--;
			}
		}
		for (int i = 0 ; i <=stackPointer; i ++) {
			System.out.print(array[i] + " ");
		}
		
	}
	
	public static void rectangleAreaFromHistogram()
	{
		int[] height = {2,1,2,3,2,3};
		Stack<Integer> st = new Stack<Integer>();
		int i=0;
		int max = 0;
		
		while(i<height.length)
		{
			if(st.isEmpty() || height[i] >= height[st.peek()])
			{
				st.push(i);
				i++;
			}
			else
			{
				int h = height[st.pop()];
				int w = st.empty()? i : i - st.peek() -1;
				max = Math.max(max, h*w);
			}
		}
		
		while(!st.empty())
		{
			int h = height[st.pop()];
			int w = st.empty()? i : i - st.peek() -1;
			max = Math.max(max, h*w);
		}
		
		System.out.println("The maximum area possible is " + max);
		
	}
	
	public static void main(String[] args) {
		int[] array = new int[] {1,3,2,2,0,0,3,1,0};
		removeAdjacentDuplicates(array);
		System.out.println();
		array = new int[] {1,3,2,2,0,0,3,1,0};
		removeAdjacentDuplicateUsingStack(array);
		System.out.println();
		System.out.println("-----------------Find span of stock market price------------------");
		int[] newArray = new int[] {6,3,4,5,1,2,3,6,7};
		findSpan(newArray);
		System.out.println();
		getSpanByMe(newArray);
		System.out.println();
		System.out.println("-----------------Reverse a stack------------------");
		Stack<Integer> s = new Stack<Integer>();
		s.push(2);s.push(7);s.push(6);s.push(4);s.push(1);s.push(3);s.push(9);
		reverseStack(s);
		while (!s.isEmpty())
			System.out.print(s.pop() + " ");
		System.out.println("Reverse end");
		s = new Stack<Integer>();
		s.push(2);s.push(7);s.push(6);s.push(4);s.push(1);s.push(3);s.push(9);
		Stack<Integer> stack=new Stack<Integer>();
		stack.push(3);stack.push(4);stack.push(1);stack.push(2);stack.push(2);stack.push(3);stack.push(4);stack.push(1);
		//sortStack(stack);
		stack = sortStackTest(stack);
		System.out.println("Stack sorting");
		while (!stack.isEmpty())
			System.out.print(stack.pop() + " ");
		System.out.println();
		sortStack(s);
		while (!s.isEmpty())
			System.out.print(s.pop() + " ");
		System.out.println();
		rectangleAreaFromHistogram();
	}

}

// Get minimun from stack in O(1)
class AdvancedStack {
	Stack<Integer> elementStack;
	Stack<Integer> minStack;
	
	public AdvancedStack() {
		elementStack = new Stack<Integer>();
		minStack = new Stack<Integer>();
	}
	
	public void push(int data) {
		elementStack.push(data);
		if (minStack.isEmpty() || minStack.peek() >= data) {
			minStack.push(data);
		}
	}
	
	public int pop() {
		if (elementStack.isEmpty()) {
			return -1;
		}
		int minTop = minStack.peek();
		int elementTop = elementStack.peek();
		if (minTop == elementTop)
			minStack.pop();
		return elementStack.pop();
	}
	
	public int min() {
		return minStack.peek();
	}
	
	public boolean isEmpty() {
		return elementStack.isEmpty();
	}
	
	public int peek() {
		if (elementStack.isEmpty())
			return -1;
		return elementStack.peek();
	}
}

/*Dynamic programming Hardik*/
package hardik.code;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;

public class DynamicProgramingAndStringAlgorithms {

	static String findLongestCommonSubString(String[] stringArray) {
		String smallestString = "";
		for (String string : stringArray) {
			if (string != null && smallestString.isEmpty())
				smallestString = string;
			else if (string != null && smallestString.length() > string.length())
				smallestString = string;
		}
		String longestCommonSubString = "";
		StringBuffer sb = new StringBuffer();
		for (int i = 0 ; i < smallestString.length() ; i++) {
			char c = smallestString.charAt(i);
			sb.append(c);
			for (String string : stringArray) {
				if (string != null && !string.contains(sb.toString())) {
					sb = sb.deleteCharAt(0);
					break;
				}
			}
			if (sb.length() != 0 && sb.length() > longestCommonSubString.length()) {
				longestCommonSubString = sb.toString();
			}
		}
		System.out.println("longest common substring is :" + longestCommonSubString);
		return longestCommonSubString;
	}
	
	
	static String findLongestCommonSubSequence(String string1, String string2) {
		int[][] lengthArray = new int[string1.length()+1][string2.length()+1];
		
		for (int i = 0 ; i < string1.length() ; i++) {
			for (int j =0 ; j < string2.length() ; j++) {
				if (string1.charAt(i) == string2.charAt(j)) {
					lengthArray[i+1][j+1] = 1 + lengthArray[i][j];
				} else {
					lengthArray[i+1][j+1] = Math.max(lengthArray[i][j+1], lengthArray[i+1][j]);
				}
			}
		}
		StringBuffer longestCommonSubSequence = new StringBuffer();
		for (int x=string1.length(), y =  string2.length(); x !=0 && y!=0;)
		{
			if (lengthArray[x][y] == lengthArray[x][y-1]) {
				y--;
			} else if (lengthArray[x][y] == lengthArray[x-1][y]) {
				x--;
			} else if (string1.charAt(x-1) == string2.charAt(y -1)) {
				longestCommonSubSequence.append(string1.charAt(x-1));
				x--;
				y--;
			}
		}
		System.out.println(longestCommonSubSequence.reverse().toString());
		return longestCommonSubSequence.reverse().toString();
	}
	
	
	//O(2^n)
	static ArrayList<ArrayList<Integer>> findSubSets(ArrayList<Integer> list, int index) {
		ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>(); 
		if (list.size() == index) {
			result.add(new ArrayList<Integer>());
		} else {
			int set = list.get(index);
			result = findSubSets(list, index + 1);
			ArrayList<ArrayList<Integer>> subResult1 = new ArrayList<ArrayList<Integer>>();
			for (ArrayList<Integer> temp : result) {
				ArrayList<Integer> subResult2 = new ArrayList<Integer>();
				subResult2.addAll(temp);
				subResult2.add(set);
				subResult1.add(subResult2);
				
			}
			result.addAll(subResult1);
		}
		return result;
	}
	
	static ArrayList<String> findAllPermutation(String string) {
		if (string == null)
			return null;
		ArrayList<String> array = new ArrayList<String>();
		if (string.length() == 0) {
			array.add("");
			return array;
		} 
		char c = string.charAt(0);
		ArrayList<String> words = findAllPermutation(string.substring(1));
		for (String word : words) {
			for (int j = 0; j <= word.length(); j++) {
				String start = word.substring(0, j);
				start += (c + word.substring(j));
				array.add(start);
			}
		}
		return array;
	}
	
	
	static void printAllParenthesisPattern(ArrayList<String> list, char[] s, int leftRem, int righRem, int count) {
		if (leftRem < 0 || righRem < leftRem) {
			return;
		}
		if (leftRem ==0 && righRem ==0) {
			String string = String.copyValueOf(s);
			list.add(string);
		} else {
			if (leftRem > 0) {
				s[count] = '(';
				printAllParenthesisPattern(list, s, leftRem -1, righRem, count+1);
			}
			
			if (righRem > leftRem) {
				s[count] = ')';
				printAllParenthesisPattern(list, s, leftRem, righRem - 1, count+1);
			}
		}
	}
	
	public static int countWaysDP(int n, int[] map) {
		if (n < 0) {
			return 0;
		} else if (n == 0) {
			return 1;
		} else if (map[n] > -1) {
			return map[n];
		} else {
			map[n] = countWaysDP(n - 1, map) + countWaysDP(n - 2, map)
					+ countWaysDP(n - 3, map);
			return map[n];
		}
	}
	
	//O(n) if all characters are same to O(n!) if all characters are distinct
		public static void permutate(String head, String tail) {
	        if (tail.isEmpty()) {
	            System.out.println(head);
	        } else {
	            Set<Character> seen = new HashSet<Character>();
	            for (int i = 0; i < tail.length(); i++) {
	                if (!seen.contains(tail.charAt(i))) {
	                    seen.add(tail.charAt(i));
	                    permutate(head + tail.charAt(i), tail.substring(0, i) + tail.substring(i + 1, tail.length()));
	                }
	            }
	        }
	    }
		
		static int lis( int arr[], int n )
		{
		   int  i, j, max = 0;
		   int[] lis = new int[n];
		 
		   /* Initialize LIS values for all indexes */
		   for ( i = 0; i < n; i++ )
		      lis[i] = 1;
		    
		   /* Compute optimized LIS values in bottom up manner */
		   for ( i = 1; i < n; i++ )
		      for ( j = 0; j < i; j++ )
		         if ( arr[i] > arr[j] && lis[i] < lis[j] + 1)
		            lis[i] = lis[j] + 1;
		    
		   /* Pick maximum of all LIS values */
		   for ( i = 0; i < n; i++ )
		      if ( max < lis[i] )
		         max = lis[i];
		 
		   /* Free memory to avoid memory leak */
		   lis = null;
		 
		   return max;
		}
	public static void main(String[] args) {
		String[] string = new String[] {"abcdab", "abcdababc", "abcdab", "ablcdabkacd"};
		findLongestCommonSubString(string);
		findLongestCommonSubSequence("ABCBDABC", "BDCABAC");
		findLongestCommonSubSequence("abcdababc", "ablcdabkacd");
		
		ArrayList<Integer> list = new ArrayList<Integer>();
		list.add(3);list.add(4);list.add(5);
		System.out.println(findSubSets(list, 0).toString());
		System.out.println(findAllPermutation("ab").toString());
		int count = 2;
		ArrayList<String> list1 = new ArrayList<String>();
		char[] chArray = new char[count*2];
		printAllParenthesisPattern(list1, chArray, count, count, 0);
		for (String s : list1) {
			System.out.print(s + " ");
		}System.out.println();
		
		int n = 3;
		int[] map = new int[] {-1,-1,-1,-1};
		System.out.println(countWaysDP(n, map));
		int arr[] = { 10, 22, 9, 33, 21, 50, 41, 60, 80 };
		System.out.println(lis(arr,arr.length-1));
			
	}
}
/*K closest points*/
package hardik.code;

public class kClosestPoints {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		CPoints newpoint;
		CPoints[] points = new CPoints[10];
		
		for(int i = 0; i < 10; i++)
		{
			newpoint = new CPoints();
			newpoint.x = 9-i+0.5;
			newpoint.y = 9-i+0.5;
			points[i] = newpoint;
		}
		
		getKClosestPoints(points, 5);

	}
	
	public static CPoints[] getKClosestPoints(CPoints[] points, int k)
	{
		if(k >= points.length)
			return points;
		
		if(k < 1)
			return null;
		
		
		findKPoints(points, k,  0, points.length - 1);
		
		CPoints[] result = new CPoints[k]; 
		int i = 0;
		for(CPoints point :points)
		{
			System.out.println(point.x + "  " + point.y);
			result[i] = point;
			i++;
			if(i == k)
				break;
		}
		
		return result;
	}

	private static void findKPoints(CPoints[] points, int k, int start, int end) {
		if(start < end)
		{
			int pivot = doPartition(points, start, end) - 1;
			if(pivot == k)
				return;
			else
			{
				if(pivot > k)
					findKPoints(points, k,  start, pivot-1);
				else
					findKPoints(points, k,  pivot+1, end);
			}
		}
}

private static int doPartition(CPoints[] points, int start, int end) {
		int left = start;
		int right = end;
		int mid = (left + right) /2;
		
		while(left <= right)
		{
			/*while(isCurrentPointMinor(points[left], points[mid]))
				left++;
			
			while(isCurrentPointMinor(points[mid],points[right] ))
				right--;
			*/
			while(points[left].compareTo(points[mid]) < 0)
				left++;
			
			while(points[mid].compareTo(points[right]) < 0)
				right--;
			
			if(left<=right)
			{
				swapPoints(points,left, right);
				left++;
				right--;
			}
		}
		return left;
	}

private static void swapPoints(CPoints[] points, int left, int right) {
	
	CPoints temp = points[left];
	points[left] = points[right];
	points[right] = temp;
	
}

private static boolean isCurrentPointMinor(CPoints currentPoint, CPoints nextPoint)
{
	double distanceOfCurrentPoint = getDistanceFromOrigin(currentPoint);
	double distanceOfNextPoint = getDistanceFromOrigin(nextPoint);
	
	if(distanceOfCurrentPoint < distanceOfNextPoint)
		return true;
	else
		return false;
}

private static double getDistanceFromOrigin(CPoints currentPoint) {
	return Math.hypot(currentPoint.x-0.0, currentPoint.y-0.0);
}
}

class CPoints implements Comparable<CPoints>{
	
	public double x;
	public double y;
	
	@Override
	public int compareTo(CPoints point) {
		double distanceOfNextPoint = Math.hypot(point.x-0.0, point.y-0.0);
		double distanceOfThisPoint = Math.hypot(this.x-0.0, this.y-0.0);
		
		return Double.valueOf(distanceOfThisPoint).compareTo(distanceOfNextPoint);
	}
	
}

/*Heap*/
package hardik.code;

public class Heap {

	int capacity;
	int count;
	int[] array;
	
	public Heap() {};
	public Heap(int capacity) {
		this.capacity = capacity;
		this.count = 0;
		this.array = new int[capacity];
	}
	
	public int getParent(int index) {
		if (index <=0 || index >= this.count)
			return -1;
		else
			return (index-1)/2;
	}
	
	public int getLeftChild(int i) {
		int left = 2*i+1;
		if (left >= this.count)
			return -1;
		else 
			return left;
	}
	
	public int getRightChild(int i) {
		int right = 2*i+2;
		if (right >= this.count)
			return -1;
		else 
			return right;
	}
	
	public int getMax() {
		if (this.count == 0)
			return -1;
		else 
			return this.array[0];
	}
	
	public void heapify(int i) {
		int left,right,temp ,max = i;
		if(i<=0 || i>= this.count)
			return;
		left = getLeftChild(i);
		right = getRightChild(i);
		if (left != -1 && this.array[left] > this.array[max]) {
			max = left;
		}
		if (right != -1 && this.array[right] > this.array[max]) {
			max = right;
		}
		if (max != i) {
			temp = this.array [i];
			this.array[i] = this.array[max];
			this.array[max] = temp;
			heapify(max);
		}
		
	}
	
	public void insert(Heap h, int data) {
		if(this.count == this.capacity) {
			resizeArray();
		}
		this.count++;
		int i = this.count -1;
		while (i>=0 && data > array[(i-1)/2]) {
			array[i] = array[(i-1)/2];
			i = (i-1)/2;
		}
		array[i] = data;
	}

	public void resizeArray() {
		int[] old_array = new int[this.capacity];
		System.arraycopy(this.array, 0, old_array, 0, this.count);
		this.array = new int[this.capacity*2];
		for (int i=0; i< this.capacity; i++) {
			this.array[i] = old_array[i];
		}
		this.capacity = this.capacity *2;
		old_array = null;
		
	}
	
	public int deleteMax() {
		if (this.count == 0)
			return -1;
		int data = this.array[0];
		this.array[0] = this.array[this.count - 1];
		heapify(0);
		return data;
	}
	
	public void buildHeap(Heap h , int[] A, int n) {
		if(h==null) return;
		if(n > h.capacity) {
			resizeArray();
		}
		for (int i=0; i <n ; i++) {
			h.array[i] = A[i];
		}
		this.count = n;
		h.count = n;
		for (int i =(n-1)/2; i >=0; i--) {
			h.heapify(i);
		}
		
	}
	
	public void heapSort(int[] A, int n) {
		Heap h = new Heap(n);
		int temp;
		buildHeap(h, A, n);
		for (int i= n-1; i>=0; i--) {
			temp = h.array[0];
			h.array[0] = h.array[this.count-1];
			h.array[this.count-1] = temp;
			h.count--;
			h.heapify(0);
		}
		h.count = n;
		for (int i=0; i < h.array.length; i++) {
			System.out.println(h.array[i]);
			A[i] = h.array[i];
		}
	}
	
	
}

/*Heap examples by hardik which includes building maximum heap / max heap and minimum heap/min heap / find kth largest element in array / find kth smallest element in array*/
package hardik.code;


public class HeapExamples {

	public static int heapSize;
	public static int getLeft(int i) {
		return 2*i + 1;
	}
	
	public static int getRight(int i) {
		return 2*i + 2;
	}
	
	public static int getMin(int[] A) {
		return A[0];
	}
	
	public static int getMax(int[] A) {
		return A[0];
	}
	
	public static void replaceMax(int[] A, int i) {
		A[0] = i;
		maxHeapify(A, 0);
	}
	
	public static void replaceMin(int[] A, int i) {
		A[0] = i;
		minHeapify(A, 0);
	}
	public static void buildMinHeap(int[] A) {
		heapSize = A.length;
		for (int i=(A.length-1)/2; i>=0; i--) {
			minHeapify(A, i);
		}
	}
	private static void minHeapify(int[] A, int i) {
		int left = getLeft(i);
		int right = getRight(i);
		int temp, min = Integer.MIN_VALUE;
		if (left < heapSize && A[left] < A[i]) 
			min = left;
		else
			min = i;
		if (right < heapSize && A[right] < A[min])
			min = right;
		if (min != i) {
			temp = A[i];
			A[i] = A[min];
			A[min] = temp;
			minHeapify(A, min);			
		}
	}

	public static void buildMaxHeap(int[] A) {
		heapSize = A.length;
		for (int i = (A.length-1)/2; i>=0; i--) {
			maxHeapify(A, i);
		}
	}
	public static void maxHeapify(int[] A, int i) {
		int left, right, max = -1, temp;
		left = getLeft(i);
		right = getRight(i);
		if (left < heapSize && A[left] > A[i])
			max = left;
		else 
			max = i;
		if (right < heapSize && A[right] > A[max])
			max = right;
		if (max != i) {
			temp = A[i];
			A[i] = A[max];
			A[max] = temp;
			maxHeapify(A, max);
		}
 	}
	
	
	public static void heapSort(int[] A, int n) {
		int temp;
		buildMaxHeap(A);
		for (int i=A.length-1; i>=0; i--) {
			temp = A[0];
			A[0] = A[i];
			A[i] = temp;
			heapSize--;
			maxHeapify(A, 0);
			
		}
	}
	
	public static void findKthLargestElement(int[] A, int k) {
		int[] B = new int[k];
		System.arraycopy(A, 0, B, 0, k);
		buildMinHeap(B);
		for (int i =k; i < A.length ; i++) {
			if (A[i] > getMin(B))
				replaceMin(B, A[i]);
		}
		System.out.println("Kth max is " + getMin(B));
	}
	
	public static void findKthSmallestElement(int[] A, int k) {
		int[] B = new int[k];
		System.arraycopy(A, 0, B, 0, k);
		buildMaxHeap(B);
		for (int i =k; i < A.length ; i++) {
			if (A[i] < getMax(B))
				replaceMax(B, A[i]);
		}
		System.out.println("Kth min is " + getMax(B));
	}
	
	
	public static void main(String[] args) {
		int A[] = new int[]{4,1,3,2,16,9,10,14,8,7};
		/*heapSort(A, A.length);
		System.out.println(Arrays.toString(A));*/
		findKthLargestElement(A, 3);
		findKthSmallestElement(A, 3);
		
	}
}

/*Java patterns*/
/*
1
111
11111
*/
for (int i = 1 ; i <=5; i++) {
			for (int j=1; j <= i; j++) {
				if(i%2 != 0)
					System.out.print(1);
			}
			if(i%2 != 0)
			System.out.println();
		}
/*
1
12
123
1234
12345
*/
for (int i = 1 ; i <=5; i++) {
			for (int j = 1; j <=i; j++) {
				System.out.print(j);
			}
			System.out.println();
		}
/*
A
AB
ABC
ABCD
ABCDE
*/
for (int i = 'A' ; i <='E'; i++) {
			for (int j = 'A'; j <=i; j++) {
				System.out.print("" + (char)j);
			}
			System.out.println();
		}
/*
                 *
               ***
             *****
           *******
         *********
       ***********
      *************
    ***************
  *****************
*******************
*/
for(int i=1;i<=10;i++){
             for(int j=1;j<10-(i-1);j++){
                 System.out.print(" ");
             }
             for(int k=1;k<=i;k++){
                 System.out.print("*");
                 for(int k1=1;k1<k;k1+=k){

                     System.out.print("*");
                 }
             }
             System.out.println();
         }



/*Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.

For example,
Assume that words = ["practice", "makes", "perfect", "coding", "makes"].

Given word1 = "coding", word2 = "practice", return 3.
Given word1 = "makes", word2 = "coding", return 1.

Note:
You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.
*/

class Solution {
 2 public:
 3     int shortestDistance(vector<string>& words, string word1, string word2) {
 4         int n = words.size(), idx1 = -1, idx2 = -1, dist = INT_MAX;
 5         for (int i = 0; i < n; i++) {
 6             if (words[i] == word1) idx1 = i;
 7             else if (words[i] == word2) idx2 = i;
 8             if (idx1 != -1 && idx2 != -1)
 9                 dist = min(dist, abs(idx1 - idx2));
10         }
11         return dist;
12     }
13 };

/*Palindrome Permutation using HashMap*//Permutation Palindrome*/
HashMap<Character,Integer> map = new HashMap<Character, Integer>();
    for (int i = 0; i < s.length(); i++){
        if (map.containsKey(s.charAt(i))){
            map.remove(s.charAt(i));
        }else{
            map.put(s.charAt(i), 1);
        }
    }
    if (map.size() > 1) return false;
    else return true;
    
/*Find the power set of a set*/
public static <T> List<List<T>> powerset(Collection<T> list) {
  List<List<T>> ps = new ArrayList<List<T>>();
  ps.add(new ArrayList<T>());   // add the empty set
 
  // for every item in the original list
  for (T item : list) {
    List<List<T>> newPs = new ArrayList<List<T>>();
 
    for (List<T> subset : ps) {
      // copy all of the current powerset's subsets
      newPs.add(subset);
 
      // plus the subsets appended with the current item
      List<T> newSubset = new ArrayList<T>(subset);
      newSubset.add(item);
      newPs.add(newSubset);
    }
 
    // powerset is now powerset of list.subList(0, list.indexOf(item)+1)
    ps = newPs;
  }
  return ps;
}
 
/*Given a string and number to letter mapping, find the number of possible combinations*/
void getMappingDp(String str)
	{
		int arr[]=new int[str.length()];
		long Dp[]=new long[str.length()];
		
		for(int i=0;i<arr.length;i++)
		{
			arr[i]=Integer.parseInt(""+str.charAt(i));
		}
	
		Dp[0]=1;
		if(arr[0]*10+arr[1]<;27)
			Dp[1]=2;
		else
			Dp[1]=1;
		
		for(int i=2;i<arr.length;i++)
		{
			long combinedLast2didgits=0;
			if(arr[i-1]*10+arr[i]<;27)
				combinedLast2didgits=Dp[i-2];
			Dp[i]=Dp[i-1]+combinedLast2didgits;	
		}
		System.out.println("Total mapping are:"+Dp[Dp.length-1]);
	}
	
/*Check if sum of two numbers is equal to sum of other two numbers*/
public static void printVal(int[] arr) { 
if (arr.length == 0 || arr.length < 4) return; 
HashMap<Integer, ArrayList<Pair>> map = new HashMap<Integer, ArrayList<Pair>>(); 
for (int i = 0; i < arr.length - 1; i++) { 
for (int j = i + 1; j < arr.length; j++) { 
Pair p = new Pair(i,j); 
if (map.containsKey(arr[i] + arr[j])) { 
map.get(arr[i] + arr[j]).add(p); 
} else { 
ArrayList<Pair> arrList = new ArrayList<Pair>(); 
arrList.add(p); 
map.put(arr[i] + arr[j], arrList); 
} 
} 
} 

for (Integer i : map.keySet()) { 
ArrayList<Pair> list = map.get(i); 
if (list.size() == 2) { 
System.out.println(list.get(0).one + " " + list.get(0).two + " " + 
list.get(1).one + " " + list.get(1).two); 
} 
if (list.size() > 2) { 
for (int k = 0; k < list.size() - 1; k++) { 
for (int m = k + 1; m < list.size(); m++) { 
System.out.println(list.get(k).one + " " + list.get(k).two 
+ " " + list.get(m).one + " " + list.get(m).two); 
} 
} 
} 
} 
} 

public class Pair { 
int one; 
int two; 
public Pair(int o, int t) { 
one = o; 
two = t; 
} 
}
/*Create a copy of the structure of the linked list with random pointer*/
private Node deepCopy(Node original) { 
		// We use the following map to associate newly created instances 
		// of Node with the instances of Node in the original list 
		Map<Node, Node> map = new HashMap<Node, Node>(); 
		// We scan the original list and for each Node x we create a new 
		// Node y whose data is a copy of x's data, then we store the 
		// couple (x,y) in map using x as a key. Note that during this 
		// scan we set y.next and y.random to null: we'll fix them in 
		// the next scan 
		Node x = original; 
		while (x != null) { 
			Node y = new Node(); 
			y.setData(new String(x.getData())); 
			y.setNext(null); 
			y.setRandom(null); 
			map.put(x, y); 
			x = x.getNext(); 
		} 
		// Now for each Node x in the original list we have a copy y 
		// stored in our map. We scan again the original list and 
		// we set the pointers buildings the new list 
		x = original; 
		while (x != null) { 
			// we get the node y corresponding to x from the map 
			Node y = map.get(x); 
			// let x' = x.next; y' = map.get(x') is the new node 
			// corresponding to x'; so we can set y.next = y' 
			y.setNext(map.get(x.getNext())); 
			// let x'' = x.random; y'' = map.get(x'') is the new 
			// node corresponding to x''; so we can set y.random = y'' 
			y.setRandom(map.get(x.getRandom())); 
			x = x.getNext(); 
		} 
		// finally we return the head of the new list, that is the Node y 
		// in the map corresponding to the Node original 
		return map.get(original); 	
	}
	
/*Check if a string is concatenaion of  strings in a given dictionary*/
public void findConcatenations(String key){
		
		System.out.println("For Key: " + key);
		boolean[] checkArray = new boolean[key.length()+1];
		
		int startPoint = 0;
		int iterator = 1;
		boolean wordMatched = false;
		
		while(iterator<=key.length())
		{
			String subWord = key.substring(startPoint, iterator);
			if(dictionary.contains(subWord))
				{
					checkArray[iterator] = true;
					wordMatched = true;
				}else if(wordMatched)
				{
					startPoint = --iterator;
					wordMatched = false;
				}
			iterator++;
		}

		
		if(checkArray[key.length()]==true)
			System.out.println("Answer: Perfect!");
		else
			System.out.println("Answer:  :(");
	}
/*Check if two strings are one edit distance apart*/
public static boolean onlyOneEdit(String first, String second)
{
  if(first.equals(second))
  {
    return false;
  }
    
  int l1 = first.length();
  int l2 = second.length();
    
  if(l1 - l2 > 1 || l2 - l1 > 1)
  {
    // At least two edits .. no need to continue
    return false;
  }
    
  String longer = (l1 > l2)? first : second;
  String shorter = (l1 > l2)? second : first;
    
  for(int i = 0; i < shorter.length(); i++)
  {
    if(longer.charAt(i) != shorter.charAt(i))
    {
        int shift = (l1 == l2)? 0 : 1;
        return longer.substring(i + 1 + shift).equals(shorter.substring(i + 1));
    }
  }
  // No difference detected until the end of the shorter string  
  return true;
}

/*Print all nodes that are k distnace away from a a given node in a binary tree*/
/* Recursive function to print all the nodes at distance k in the
   tree (or subtree) rooted with given root. See  */
void printkdistanceNodeDown(node *root, int k)
{
    // Base Case
    if (root == NULL || k < 0)  return;
 
    // If we reach a k distant node, print it
    if (k==0)
    {
        cout << root->data << endl;
        return;
    }
 
    // Recur for left and right subtrees
    printkdistanceNodeDown(root->left, k-1);
    printkdistanceNodeDown(root->right, k-1);
}
 
// Prints all nodes at distance k from a given target node.
// The k distant nodes may be upward or downward.  This function
// Returns distance of root from target node, it returns -1 if target
// node is not present in tree rooted with root.
int printkdistanceNode(node* root, node* target , int k)
{
    // Base Case 1: If tree is empty, return -1
    if (root == NULL) return -1;
 
    // If target is same as root.  Use the downward function
    // to print all nodes at distance k in subtree rooted with
    // target or root
    if (root == target)
    {
        printkdistanceNodeDown(root, k);
        return 0;
    }
 
    // Recur for left subtree
    int dl = printkdistanceNode(root->left, target, k);
 
    // Check if target node was found in left subtree
    if (dl != -1)
    {
         // If root is at distance k from target, print root
         // Note that dl is Distance of root's left child from target
         if (dl + 1 == k)
            cout << root->data << endl;
 
         // Else go to right subtree and print all k-dl-2 distant nodes
         // Note that the right child is 2 edges away from left child
         else
            printkdistanceNodeDown(root->right, k-dl-2);
 
         // Add 1 to the distance and return value for parent calls
         return 1 + dl;
    }
 
    // MIRROR OF ABOVE CODE FOR RIGHT SUBTREE
    // Note that we reach here only when node was not found in left subtree
    int dr = printkdistanceNode(root->right, target, k);
    if (dr != -1)
    {
         if (dr + 1 == k)
            cout << root->data << endl;
         else
            printkdistanceNodeDown(root->left, k-dr-2);
         return 1 + dr;
    }
 
    // If target was neither present in left nor in right subtree
    return -1;
}


/*Binary Tree to circular doubly linked list inorder*/
// This is a modified in-order traversal adapted to this problem.
// prev (init to NULL) is used to keep track of previously traversed node.
// head pointer is updated with the list's head as recursion ends.
void treeToDoublyList(Node p, Node prev, Node head) {
  if (p==null) return;
  treeToDoublyList(p.left, prev, head);
  // current node's left points to previous node
  p.left = prev;
  if (prev!=null)
    prev.right = p;  // previous node's right points to current node
  else
    head = p; // current node (smallest element) is head of
              // the list if previous node is not available
  // as soon as the recursion ends, the head's left pointer 
  // points to the last node, and the last node's right pointer
  // points to the head pointer.
  Node right = p.right;
  head.left = p;
  p.right = head;
  // updates previous node
  prev = p;
  treeToDoublyList(right, prev, head);
}

// Given an ordered binary tree, returns a sorted circular
// doubly-linked list. The conversion is done in-place.
Node treeToDoublyList(Node root) {
  Node prev = NULL;
  Node head = NULL;
  treeToDoublyList(root, prev, head);
  return head;
}

/*Minimum sliding window/ minimum substring containing all the letters in target*/
public String minWindow(String s, String t) {
    if(s == null || s.length() < t.length() || s.length() == 0){
        return "";
    }
    HashMap<Character,Integer> map = new HashMap<Character,Integer>();
    for(char c : t.toCharArray()){
        if(map.containsKey(c)){
            map.put(c,map.get(c)+1);
        }else{
            map.put(c,1);
        }
    }
    int left = 0;
    int minLeft = 0;
    int minLen = s.length()+1;
    int count = 0;
    for(int right = 0; right < s.length(); right++){
        if(map.containsKey(s.charAt(right))){
            map.put(s.charAt(right),map.get(s.charAt(right))-1);
            if(map.get(s.charAt(right)) >= 0){
                count ++;
            }
            while(count == t.length()){
                if(right-left+1 < minLen){
                    minLeft = left;
                    minLen = right-left+1;
                }
                if(map.containsKey(s.charAt(left))){
                    map.put(s.charAt(left),map.get(s.charAt(left))+1);
                    if(map.get(s.charAt(left)) > 0){
                        count --;
                    }
                }
                left ++ ;
            }
        }
    }
    if(minLen>s.length())  
    {  
        return "";  
    }  

    return s.substring(minLeft,minLeft+minLen);
}


/*Multiplying without using multiplication operator*/
public static int bitwiseMultiply(int n1, int n2) {
    int a = n1;
    int b = n2;
    int result = 0;
    while (b != 0)
    { 
        if ((b & 1) != 0)
        {
        result = result + a;
        }
        a <<= 1;
        b >>>= 1;
    }
return result;
}
/*Divide two integers without using division operator O(logn)-If it is overflow, return MAX_INT.*/
public int divide(int dividend, int divisor) {
    //handle special cases
    if(divisor==0) return Integer.MAX_VALUE;
    if(divisor==-1 && dividend == Integer.MIN_VALUE)
        return Integer.MAX_VALUE;
 
    //get positive values
    long pDividend = Math.abs((long)dividend);
    long pDivisor = Math.abs((long)divisor);
 
    int result = 0;
    while(pDividend>=pDivisor){
        //calculate number of left shifts
        int numShift = 0;    
        while(pDividend>=(pDivisor<<numShift)){
            numShift++;
        }
 
        //dividend minus the largest shifted divisor
        result += 1<<(numShift-1);
        pDividend -= (pDivisor<<(numShift-1));
    }
 
    if((dividend>0 && divisor>0) || (dividend<0 && divisor<0)){
        return result;
    }else{
        return -result;
    }
}

/*detect conflicts in meeting rooms*/
pubic boolean isConflict(List<Interval> slots){
    Collection.sort(slots,new Comparator<Interval>(){
                                       int compareto(Interval one , Interval two){
                                           return one.getStartTime().compareTo(two.getStartTime());
                                       } 
                                    }
                                   );
     Interval prev = null;                              
   for(Inteval el:slots){
       if(prev==null){
           prev == el;
           continue;
       }
       if(el.getStartTime()< prev.getEndTime()){
           return true;
       }
       prev = el;
   }                     
   return false;   
}
/*in-place palindrome check*/
public boolean is_palindrome(String word){
    for(int i=0; i< word.length()/2;i++){
        if(word.charAt(i) != word.charAt(word.length() - 1 - i)
            	return False
            }
    return True
    }
   
/* Local maxima or local minima O(1) time*/
A[0] +/- (A[ A.length -1 ] + A.length - A[0])/2

/*Local minima in O(logn) time */
The question just asks for one local minimum. 
mid=(start+end)/2; 
1. if(A[mid-1]>=A[mid] && A[mid+1]>=A[mid]) then A[mid] is a local minimum. 
2. else if(A[mid-1]<=A[mid] && A[mid]<=A[mid+1]) end=mid, do recursive search. 
3. else if(A[mid-1]>=A[mid] && A[mid]>=A[mid+1]) start=mid, do recursive search 
it is O(logn)


/*Search in rotated sorted array*/
public class Solution {
public int search(int[] A, int target) {
    int lo = 0;
    int hi = A.length - 1;
    while (lo < hi) {
        int mid = (lo + hi) / 2;
        if (A[mid] == target) return mid;

        if (A[lo] <= A[mid]) {
            if (target >= A[lo] && target < A[mid]) {
                hi = mid - 1;
            } else {
                lo = mid + 1;
            }
        } else {
            if (target > A[mid] && target <= A[hi]) {
                lo = mid + 1;
            } else {
                hi = mid - 1;
            }
        }
    }
    return A[lo] == target ? lo : -1;
}
}
/*Search in rotated sorted array with duplicates*/
public boolean search(int[] nums, int target) {
        int start = 0, end = nums.length - 1, mid = -1;
        while(start <= end) {
            mid = (start + end) / 2;
            if (nums[mid] == target) {
                return true;
            }
            //If we know for sure right side is sorted or left side is unsorted
            if (nums[mid] < nums[end] || nums[mid] < nums[start]) {
                if (target > nums[mid] && target <= nums[end]) {
                    start = mid + 1;
                } else {
                    end = mid - 1;
                }
            //If we know for sure left side is sorted or right side is unsorted
            } else if (nums[mid] > nums[start] || nums[mid] > nums[end]) {
                if (target < nums[mid] && target >= nums[start]) {
                    end = mid - 1;
                } else {
                    start = mid + 1;
                }
            //If we get here, that means nums[start] == nums[mid] == nums[end], then shifting out
            //any of the two sides won't change the result but can help remove duplicate from
            //consideration, here we just use end-- but left++ works too
            } else {
                end--;
            }
        }

        return false;
    }
/*Inorder successor in BST*/
public TreeNode successor(TreeNode root, TreeNode p) {
  if (root == null)
    return null;

  if (root.val <= p.val) {
    return successor(root.right, p);
  } else {
    TreeNode left = successor(root.left, p);
    return (left != null) ? left : root;
  }
}

/*Inorder predecessor in BST*/
public TreeNode predecessor(TreeNode root, TreeNode p) {
  if (root == null)
    return null;

  if (root.val >= p.val) {
    return predecessor(root.left, p);
  } else {
    TreeNode right = predecessor(root.right, p);
    return (right != null) ? right : root;
  }
}

/*//On a given array with N numbers, find subset of size M (exactly M elements) that equal to SUM.*/
public static void main(String[] args) throws Exception {
    int[] a = {5,3,2,1,0,4,9,7,8};
    subSeqSumSizeM(a,3,5);
  }
  private static void subSeqSumSizeM(int[] a, int m, int sum) {
   
    if(a == null || (a.length==0) || m<=0 || m>a.length)
      return;
    
    int answer = 0;
    
    for(int i=0; i<m; i++) {
      answer = answer + a[i];
    }
    
    for(int j=1; j<a.length-m; j++) {
      if(answer == sum)
        System.out.println((j-1)+ "-" + (j+m-2));
      
      answer = answer -a[j-1] + a[j+m-1];
    }    
  }
  
  
/* Upside down Binary Tree iterative*/
public class Solution{
	public TreeNode upside(TreeNode root){
		if(root==null) return root;
		TreeNode p = root, parent = null, pRight=null;
		while(p!=null){
		TreeNode left = p.left;
		p.left=null;
		pRight = p.right;
		p.right = parent;
		parent = p;
		p=left;
		}
		return parent;
	}
}

/* Upside down Binary Tree recursive*/
public class Solution{
	public TreeNode upside(TreeNode root){
		if(root==null) return root;
		TreeNode p = root, left = root.left, right = root.right;
		while(left!=null){
		TreeNode ret = upside(left);
		left.left = right;
		left.right=parent;
		return ret;
		}
		return root;
	}
}
/* Check whether string is palindrome or not*/
public class Solution {
    public boolean isPalindrome(String s) {
        if(s==null || s.length()<=1)
            return true;
        String original = s.replaceAll("[^A-Za-z0-9]","").toLowerCase();
        String reverse = new StringBuffer(original).reverse().toString();
        return original.equals(reverse);
    }
}
/* Reverse the words in sentence / Reverse the words in string */
public class Solution 
{
    public String reverseWords(String s) 
    {
         String [] words = s.split(" ");
         StringBuilder sb = new StringBuilder();
         int end = words.length - 1;
         for(int i = 0; i<= end; i++)
         {
            if(!words[i].isEmpty()) 
            {
                sb.insert(0, words[i]);
                if(i < end) 
                    sb.insert(0, " ");
            }
        }
        return sb.toString();
    }
}


/* Reverse the words in sentence / Reverse the words in string  ALTERNATIVE*/
public class Solution {
    public String reverseWords(String s) {
        StringBuilder sb = new StringBuilder();
        if(s==null || s.length()<1)
            return sb.toString();
        String[] arr = s.split("\\s{1,}");
        for(int i=arr.length-1; i>=0 ; i--)
        {
            sb.append(arr[i] + " ");
        }
        return sb.toString().trim();
        
    }
}
/* get the length of last word in string/ get the length of last word in sentence  */
public class Solution {
    public int lengthOfLastWord(String s) {
 String str = s.trim();
     if (str==null) {
        return 0;
    } 
 String[] k = str.split(" ");
 return k[k.length-1].length();    
        
    }
}
/*Longest substring without repeating characters*/
public int LongestSubstring(String s) {
        int n=s.length();
        int i=0,j=0;
        int maxlength=0;
        char[] string = s.toCharArray();
        boolean[] buffer = new boolean[256];
       
        while(j<n){
            if(buffer[string[j]]){
               //maxlength = Math.max(maxlength, j-i);
               while(string[i]!=string[j]){
                   buffer[string[i]]=false;
                   i++;
               }
               i++;
               j++;
            }
            else{
                buffer[string[j]]=true;
                j++;
            }
        }
       // maxlength = Math.max(maxlength, n-i);
        return s.substring(i,j);
    }
/*Length of longest substring with non-repetitive / repeating characters  */
public class Solution {
    public int lengthOfLongestSubstring(String s) {
          int i = 0, j = 0, max = 0;
    Set<Character> set = new HashSet<>();

    while (j < s.length()) {
        if (!set.contains(s.charAt(j))) {
            set.add(s.charAt(j++));
            max = Math.max(max, set.size());
        } else {
            set.remove(s.charAt(i++));
        }
    }

    return max;
    }
}
/*find the index of string in another string / substring */
public class Solution {
    public int strStr(String haystack, String needle) {
        if(haystack == null || needle == null || needle.length() > haystack.length()){
            return -1;
        }
        for(int i = 0; i < haystack.length() - needle.length() + 1; i ++){
            if(haystack.substring(i, i + needle.length()).equals(needle)){
                return i;
            }
        }
        return -1;
    }
}
/*Simplify path */
public class Solution {
    public String simplifyPath(String path) {
        Stack<String> st = new Stack<String>();
        String [] str = path.split("/");
        for (String s:str)
        {
            if(s==null || "".equals(s) || ".".equals(s))
                continue;
        
            if("..".equals(s))
                {
                    if(!st.isEmpty())
                        st.pop();
                }
                else
                        st.push(s);
                
        }
        if(st.isEmpty())
        {
            return "/";
        }
        StringBuilder str_build = new StringBuilder("");
        for(String newStr:st)
        {
            str_build.append("/"+newStr);
        }
        return str_build.toString();
    }
}
/* Implementation of Minimum stack / min stack*/
class MinStack {
    Stack<Integer> mainStack = new Stack<Integer>();
        Stack<Integer> minStack = new Stack<Integer>();

        public void push(int x) {
            mainStack.push(x);
            if (minStack.empty()) {
                minStack.push(x);
            } else if (minStack.peek() >= x) {
                minStack.push(x);
            }
        }

        public void pop() {
            int poppedElement = mainStack.pop();
            if (poppedElement == minStack.peek()) {
                minStack.pop();
            }
        }

        public int top() {
            return mainStack.peek();
        }

        public int getMin() {
            return minStack.peek();
        }
}
/*Largest Rectangle in a histogram */
public class Solution {
    public int largestRectangleArea(int[] height) {
        if(height == null || height.length==0)
            return 0;
        int len = height.length;
        Stack<Integer> s = new Stack<Integer>();
        int maxArea = 0;
        for(int i = 0; i <= len; i++){
            int h = (i == len ? 0 : height[i]);
            if(s.isEmpty() || h >= height[s.peek()]){
                s.push(i);
            }else{
                int tp = s.pop();
                maxArea = Math.max(maxArea, height[tp] * (s.isEmpty() ? i : i - 1 - s.peek()));
                i--;
            }
        }
        return maxArea;
    }
}
/*validate parenthesis */
public class Solution {
    public boolean isValid(String s) {
         if(s==null){ return true; }

    Stack<Character> s1=new Stack<Character>();
        char[] c = s.toCharArray();
        for(int i=0;i<c.length;i++){
            if(!s1.empty()){
                if((s1.peek()=='(' && c[i]==')' )||(s1.peek()=='{' && c[i]=='}' )||(s1.peek()=='[' && c[i]==']' ) )
                    s1.pop();
                else
                    s1.push(c[i]);
            
            }else
                s1.push(c[i]);
        }
        return s1.empty();
        }
    }
    
/* Implement stack using queue*/
class MyStack {
    Queue<Integer> qu = new LinkedList<Integer>();
    
    
    // Push element x onto stack.
    public void push(int x) {
        qu.add(x);
        for(int i=0; i<qu.size()-1; i++)
        {
            qu.add(qu.remove());
        }
        
    }

    // Removes the element on top of the stack.
    public void pop() {
        qu.remove();
    }

    // Get the top element.
    public int top() {
        return qu.peek();
    }

    // Return whether the stack is empty.
    public boolean empty() {
        return qu.isEmpty();
    }
}
/*Implement queue using stack */
class MyQueue {
    // Push element x to the back of queue.
    Stack<Integer> s1 = new Stack<Integer>();
    Stack<Integer> s2 = new Stack<Integer>();
    public void push(int x) {
        s1.push(x);
    }

    // Removes the element from in front of queue.
    public void pop() {
        if(!s2.isEmpty()){
            s2.pop();
        return;
        }
        while(!s1.isEmpty()){
            s2.push(s1.pop());
        }
        s2.pop();
    }

    // Get the front element.
    public int peek() {
        if(!s2.isEmpty())
            return s2.peek();
        while(!s1.isEmpty())
        {
            s2.push(s1.pop());
        }
        return s2.peek();
    }

    // Return whether the queue is empty.
    public boolean empty() {
        return s1.isEmpty()&&s2.isEmpty();
    }
}
/* Evaluate Reverse polish notation*/
public class Solution {
    public int evalRPN(String[] tokens) {
        
        Stack<Integer> stack = new Stack<Integer>();
    int temp;
    for (int i = 0; i < tokens.length; i++) {
        switch (tokens[i]) {
        case "+":
            temp = stack.pop();
            stack.push(temp + stack.pop());
            break;
        case "-":
            temp = stack.pop();
            stack.push(stack.pop() - temp);
            break;
        case "*":
            temp = stack.pop();
            stack.push(stack.pop() * temp);
            break;
        case "/":
            temp = stack.pop();
            stack.push(stack.pop() / temp);
            break;
        default:
            stack.push(Integer.parseInt(tokens[i]));
        }
    }

    return stack.peek();
        
    }
}
/*Binary tree zig zag level order traversal */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        
        Stack<TreeNode> s1 = new Stack<TreeNode>();
        Stack<TreeNode> s2 = new Stack<TreeNode>();
        TreeNode curr = root;
        s1.push(curr);
        List<List<Integer>> arlist = new ArrayList<List<Integer>>();
        if(root==null)
            return arlist;
        while(!s1.isEmpty() || !s2.isEmpty())
        {
            List<Integer> li1 = new ArrayList<Integer>();
            List<Integer> li2 = new ArrayList<Integer>();
            int flag1 = 0;
            int flag2 = 0;
            while(!s1.isEmpty())
            {
                flag1=1;
                li1.add(s1.peek().val);
                if(s1.peek().left!=null)
                    s2.push(s1.peek().left);
                if(s1.peek().right!=null)
                    s2.push(s1.peek().right);
                s1.pop();
                
            }
            if(flag1==1)
            arlist.add(li1);
            while(!s2.isEmpty())
            {
                flag2=1;
                li2.add(s2.peek().val);
                if(s2.peek().right!=null)
                    s1.push(s2.peek().right);
                if(s2.peek().left!=null)
                    s1.push(s2.peek().left);
                s2.pop();
                
            }
            if(flag2==1)
            arlist.add(li2);
        }
        return arlist;
    }
}
/* Binary search tree iterator / BST iterator*/
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

public class BSTIterator {
private Stack<TreeNode> stack = null;
    public BSTIterator(TreeNode root) {
        stack = new Stack<>();

    TreeNode curr = root;
    while(curr!=null){
        stack.push(curr);
        curr = curr.left;
    }
    }

    /** @return whether we have a next smallest number */
    public boolean hasNext() {
        return !stack.isEmpty();
    }

    /** @return the next smallest number */
    public int next() {
        if(hasNext()){
        int ret = stack.peek().val;
        TreeNode curr = stack.pop();
        if(curr.right!=null){
            curr = curr.right;

            while(curr!=null){
                stack.push(curr);
                curr = curr.left;
            }
        }
        return ret;
    }
    return -1;
    }
}

/**
 * Your BSTIterator will be called like this:
 * BSTIterator i = new BSTIterator(root);
 * while (i.hasNext()) v[f()] = i.next();
 */
/* Basic calculator to evaluate expression / contains only ( ) + - / basic calculator to evaluate string */
public class Solution {
    public int calculate(String s) {
     Stack<Integer> stack = new Stack<Integer>();
    int result = 0;
    int number = 0;
    int sign = 1;
    for(int i = 0; i < s.length(); i++){
        char c = s.charAt(i);
        if(Character.isDigit(c)){
            number = 10 * number + (int)(c - '0');
        }else if(c == '+'){
            result += sign * number;
            number = 0;
            sign = 1;
        }else if(c == '-'){
            result += sign * number;
            number = 0;
            sign = -1;
        }else if(c == '('){
            //we push the result first, then sign;
            stack.push(result);
            stack.push(sign);
            //reset the sign and result for the value in the parenthesis
            sign = 1;   
            result = 0;
        }else if(c == ')'){
            result += sign * number;  
            number = 0;
            result *= stack.pop();    //stack.pop() is the sign before the parenthesis
            result += stack.pop();   //stack.pop() now is the result calculated before the parenthesis

        }
    }
    if(number != 0) result += sign * number;
    return result;
}
}
/* Binary tree preorder traversal iterative*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
         List<Integer> answer = new LinkedList<Integer>();
         Stack<TreeNode> stack = new Stack<TreeNode>();

         if(root==null)
         {
             return answer;
         }

         stack.push(root);
         while(stack.isEmpty()==false)
         {
             TreeNode node = stack.pop();
             answer.add(node.val);
             if(node.right!=null)
             {
                 stack.push(node.right);
             }
             if(node.left!=null)
             {
                 stack.push(node.left);
             }
         }
         return answer;
    }
}
/* Binary tree preorder traversal recursion*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
         List<Integer> list = new ArrayList<Integer>();
    if (root!=null) {
        list.add(root.val);
        list.addAll(preorderTraversal(root.left));
        list.addAll(preorderTraversal(root.right));
    }
    return list;
    }
}
/* Binary tree postorder traversal recursion*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
                List<Integer> list = new ArrayList<Integer>();
    if (root!=null) {
        
        list.addAll(postorderTraversal(root.left));
        list.addAll(postorderTraversal(root.right));
        list.add(root.val);
        
    }
    return list;

    }
}
/* Binary tree postorder traversal iterative*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> list = new ArrayList<Integer>();
    if (root == null) {
        return list;
    }
    HashMap<TreeNode,Boolean> nodesPushedToStack = new HashMap<TreeNode,Boolean>();
    Stack<TreeNode> stack = new Stack<TreeNode>();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        if (!nodesPushedToStack.containsKey(node)) {
              nodesPushedToStack.put(node,true); 
              stack.push(node);
              if (node.right != null) {
                  stack.push(node.right);
              }
              if (node.left != null) {
                  stack.push(node.left);
              }
        } 
        else {
            list.add(node.val);
        }
    }
    return list;

    }
}
/* Binary tree inorder traversal iterative*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        
        List<Integer> ans = new ArrayList<>();
                Stack<TreeNode> stack = new Stack<>();
    TreeNode cur = root;
    while (!stack.isEmpty() || cur != null) {
        while (cur != null) {
            stack.push(cur);
            cur = cur.left;
        }
        cur = stack.pop();
        ans.add(cur.val);
        cur = cur.right;
    }
    return ans;

    }
}
/* Binary tree inorder traversal recursion	*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    List<Integer> ans = new ArrayList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
        
        
     if (root == null) return ans;
   inorderTraversal(root.left);
   ans.add(root.val);
   return inorderTraversal(root.right);

    }
}

/*Contains Duplicate. Two distinct indices. Difference between i and j is at most/ atmost k*/
public class Solution {
Map<Integer, Integer> map = new HashMap<Integer, Integer>();
    for (int i = 0; i < nums.length; i++) {
        if (map.containsKey(nums[i])) {
            if (i - map.get(nums[i]) <= k) return true;
        }
        map.put(nums[i], i);
    }
    return false;
}
}
/* Check if array contains any duplicate / array duplicate*/
public class Solution {
    public boolean containsDuplicate(int[] nums) {
        
        if (nums.length==0) return false;
        HashSet<Integer> hs = new HashSet<>();
        for(int n : nums) {
            if (!hs.add(n)) return true;
        }
        return false;
        }
}
/* Majority element in the array*/
public class Solution {
    public int majorityElement(int[] nums) {
        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();
        int majority = (int)Math.floor(nums.length/2);
        int highest = 0;
        for(int i : nums){
            if(map.containsKey(i))
                map.put(i,map.get(i)+1);
            else
                map.put(i,1);
        }
        
        for(Map.Entry<Integer,Integer> result : map.entrySet()){
            if(result.getValue()>majority){
                highest = result.getKey();
                majority = result.getValue();
            }
                
        }
        return highest;    
    }
}

/*Merger Intervals*/
public List<Interval> merge(List<Interval> intervals) {
    if (intervals.size() <= 1)
        return intervals;

    // Sort by ascending starting point using an anonymous Comparator
    Collections.sort(intervals, new Comparator<Interval>() {
        @Override
        public int compare(Interval i1, Interval i2) {
            return Integer.compare(i1.start, i2.start);
        }
    });

    List<Interval> result = new LinkedList<Interval>();
    int start = intervals.get(0).start;
    int end = intervals.get(0).end;

    for (Interval interval : intervals) {
        if (interval.start <= end) // Overlapping intervals, move the end if needed
            end = Math.max(end, interval.end);
        else {                     // Disjoint intervals, add the previous one and reset bounds
            result.add(new Interval(start, end));
            start = interval.start;
            end = interval.end;
        }
    }

    // Add the last interval
    result.add(new Interval(start, end));
    return result;
}

/* merge two sorted arrays at back of other array/ at back of first array/ without using extra space*/
public class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int num1Tail = m - 1;
    int num2Tail = n - 1;
    int newTail = m + n - 1;

    while(num2Tail >= 0) {
        //nums1: {4, }
        //nums2: {1}
        //so num1Tail >= 0 is very important!!!
        if(num1Tail >= 0 && nums1[num1Tail] > nums2[num2Tail]) {
            nums1[newTail] = nums1[num1Tail];
            num1Tail--;
        }
        else {
            nums1[newTail] = nums2[num2Tail];
            num2Tail--;
        }
        newTail--;
    }
    }
}
/*Move zeros / 0 to one end*/
public class Solution {
    public void moveZeroes(int[] nums) {
        
        int p = 0;
        for(int i : nums)
        {
            if(i!=0)
            {
                nums[p]=i;
                p++;
            }
            
        }
        
        while(p<nums.length)
            {
                nums[p]=0;
                p++;
            }
    }
}
/*Pascal triangle*/
public class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
    if (numRows == 0)
        return ans;

    LinkedList<Integer> sub = new LinkedList<Integer>();
    sub.add(1);
    ans.add(sub);

    for (int i = 1; i < numRows; i++) {
        LinkedList<Integer> subAns = new LinkedList<Integer>();
        List<Integer> list = ans.get(i - 1);
        subAns.addFirst(1);
        for (int j = 1; j < i; j++)
            subAns.addFirst(list.get(j - 1) + list.get(j));
        subAns.addFirst(1);
        ans.add(subAns);
    }

    return ans;
        
    }
}
/*Plus one to the array/at MSB*/
public class Solution {
    public int[] plusOne(int[] digits) {
        int n = digits.length;
    for(int i=n-1; i>=0; i--) {
        if(digits[i] < 9) {
            digits[i]++;
            return digits;
        }

        digits[i] = 0;
    }

    int[] newNumber = new int [n+1];
    newNumber[0] = 1;
return newNumber;
    }
}
/* Remove Duplicates from sorted array without using extra space*/
public class Solution {
    public int removeDuplicates(int[] nums) {
        int j = 0;
        for (int i = 0; i < nums.length; i++) {
            if (i > 0 && nums[i - 1] == nums[i]) 
                continue;
            nums[j] = nums[i];
            j++;
        }
        return j;
    }
}
/* remove duplicates from array with at most/atmost 2 same / 2 duplicates */
public class Solution {
    public int removeDuplicates(int[] nums) {
        if(nums.length<3)
            return nums.length;
        int count=2;
        for(int i=2 ; i <nums.length; i++)
        {
            nums[count] = nums[i];  
            if(!(nums[count]==nums[count-1] && nums[count]==nums[count-2]))
                count++;
        }
        return count;
        
    }
}

/*Serialize and de-serialize a tree*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        helper(root, sb);
        return sb.toString();
    }
    private void helper(TreeNode node, StringBuilder sb)
    {
        if(node==null){
            sb.append("null").append(",");
                return;
        }
        sb.append(node.val).append(",");
        helper(node.left, sb);
        helper(node.right, sb);
    }
    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        String[]  val = data.split(",");
        int[] index = new int[]{0};
        return helperD(val, index);
    }
    TreeNode helperD(String[] val, int[] index)
    {
        if(index[0]==val.length)
            return null;
        String visiting = val[index[0]++];
        if(visiting.equals("null"))
            return null;
        TreeNode node= new TreeNode(Integer.valueOf(visiting));
        node.left=helperD(val, index);
        node.right=helperD(val, index);
        
        return node;
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));
/* Add two numbers using linked list */
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        if(l1==null)
            return l2;
        if(l2==null)
            return l1;
        ListNode head =new ListNode(0);
        ListNode p=head;
        int temp=0;
        while(l1!=null || l2!=null || temp!=0)
        {
            if(l1!=null)
            {
                temp+=l1.val;
                l1=l1.next;
            }
            if(l2!=null)
            {
                temp+=l2.val;
                l2=l2.next;
            }
            p.next = new ListNode(temp%10);
            p=p.next;
            temp = temp/10;
        }
        return head.next;
    }
}
/* Create Binary search tree from sorted linked list / create bst from sorted list*/
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode sortedListToBST(ListNode head) {
            if(head==null)
        return null;
    ListNode slow = head;
    ListNode fast = head;
    ListNode temp=null;

    //find the mid node
    while(fast.next!=null && fast.next.next!=null){
        fast = fast.next.next;
        temp = slow;
        slow = slow.next;
    }

    if(temp!=null)
        temp.next = null; //break the link
    else
        head = null;

    TreeNode root = new TreeNode(slow.val);
    root.left = sortedListToBST(head);
    root.right = sortedListToBST(slow.next);
    return root;

    }
}
/* Flatten Binary tree to linked list*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public void flatten(TreeNode root) {
        if (root == null) return;

        TreeNode left = root.left;
        TreeNode right = root.right;

        root.left = null;

        flatten(left);
        flatten(right);

        root.right = left;
        TreeNode cur = root;
        while (cur.right != null) 
            cur = cur.right;
        cur.right = right;
    }
}
/*Binary Tree maximum path sum */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    int maxValue;
    public int maxPathSum(TreeNode root) {
        maxValue = Integer.MIN_VALUE;
        maxPathDown(root);
        return maxValue;
    }
     private int maxPathDown(TreeNode node) {
        if (node == null) return 0;
        int left = Math.max(0, maxPathDown(node.left));
        int right = Math.max(0, maxPathDown(node.right));
        maxValue = Math.max(maxValue, left + right + node.val);
        return Math.max(left, right) + node.val;
    }
    
}
/* Recover binary search tree / recover BST / indentify  2 swapped elements in BST*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {

    TreeNode firstElement = null;
    TreeNode secondElement = null;
    // The reason for this initialization is to avoid null pointer exception in the first comparison when prevElement has not been initialized
    TreeNode prevElement = new TreeNode(Integer.MIN_VALUE);

    public void recoverTree(TreeNode root) {

        // In order traversal to find the two elements
        traverse(root);

        // Swap the values of the two nodes
        int temp = firstElement.val;
        firstElement.val = secondElement.val;
        secondElement.val = temp;
    }

    private void traverse(TreeNode root) {

        if (root == null)
            return;

        traverse(root.left);

        // Start of "do some business", 
        // If first element has not been found, assign it to prevElement (refer to 6 in the example above)
        if (firstElement == null && prevElement.val >= root.val) {
            firstElement = prevElement;
        }

        // If first element is found, assign the second element to the root (refer to 2 in the example above)
        if (firstElement != null && prevElement.val >= root.val) {
            secondElement = root;
        }        
        prevElement = root;

        // End of "do some business"

        traverse(root.right);
}
}
/*Populating Next Right Pointers in each node of Binary tree / left node should make an arrow towards right node ITERATIVE*/
/**
 * Definition for binary tree with next pointer.
 * public class TreeLinkNode {
 *     int val;
 *     TreeLinkNode left, right, next;
 *     TreeLinkNode(int x) { val = x; }
 * }
 */
public class Solution {

    //based on level order traversal
    public void connect(TreeLinkNode root) {

        TreeLinkNode head = null; //head of the next level
        TreeLinkNode prev = null; //the leading node on the next level
        TreeLinkNode cur = root;  //current node of current level

        while (cur != null) {

            while (cur != null) { //iterate on the current level
                //left child
                if (cur.left != null) {
                    if (prev != null) {
                        prev.next = cur.left;
                    } else {
                        head = cur.left;
                    }
                    prev = cur.left;
                }
                //right child
                if (cur.right != null) {
                    if (prev != null) {
                        prev.next = cur.right;
                    } else {
                        head = cur.right;
                    }
                    prev = cur.right;
                }
                //move to next node
                cur = cur.next;
            }

            //move to next level
            cur = head;
            head = null;
            prev = null;
        }

    }
}
/* Populating Next Right Pointers in each node of Binary tree / left node should make an arrow towards right node RECURSIVE*/
/**
 * Definition for binary tree with next pointer.
 * public class TreeLinkNode {
 *     int val;
 *     TreeLinkNode left, right, next;
 *     TreeLinkNode(int x) { val = x; }
 * }
 */
public class Solution {
    public void connect(TreeLinkNode root) {
        if (root == null) return;

        // link root's child nodes
        link(root);

        // before we recurse to the next level
        // make sure all the child nodes of the nodes at current level are linked
        TreeLinkNode curr = root.next;
        while (curr != null) {
            link(curr);
            curr = curr.next;
        }

        connect(root.left);
        connect(root.right);
    }

    // helper function
    // link root node's left and right nodes
    void link(TreeLinkNode root) {
        if (root == null) return;

        if (root.left != null) {
            root.left.next = root.right != null ? root.right : getNext(root);
        } 

        if (root.right != null) {
            root.right.next = getNext(root);
        }
    }

    // get the left most node at the next level
    TreeLinkNode getNext(TreeLinkNode node) {
        TreeLinkNode next = node.next;

        while (next != null) {
            if (next.left != null) return next.left;
            if (next.right != null) return next.right;
            next = next.next;
        }

        return null;
    }
}

/*Group Anagrams / find all anagrams in list of string and return all anagrams in list. */
public class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> li = new ArrayList<List<String>>();
        if(strs==null || strs.length==0)
            return li;
        Arrays.sort(strs);
        
        HashMap<String, List<String>> hm = new HashMap<String, List<String>>();
        for(String s : strs)
        {
            char [] ch =  s.toCharArray();
            Arrays.sort(ch);
            String str= String.valueOf(ch);
            if(!hm.containsKey(str))
                hm.put(str, new ArrayList<String>());
            hm.get(str).add(s);
        }
        for (List<String> item: hm.values())   
            li.add(item);
        return li;
        
        // above three lines can be written as  return new ArrayList<List<String>>(hm.values());
        
    }
}
/* Valid Palindrome String*/
public class Solution {
    public boolean isPalindrome(String s) {
        if(s==null || s.length()<=1)
            return true;
        String original = s.replaceAll("[^A-Za-z0-9]","").toLowerCase();
        String reverse = new StringBuffer(original).reverse().toString();
        return original.equals(reverse);
    }
}

/*Zig zag conversion of string. Convert string to zig zag pattern and then write the zig zag string */
public class Solution {
    public String convert(String s, int n) {
        if (s.length()==0 || n==1)
            return s;
        StringBuilder[] sb = new StringBuilder[n];
        for(int m=0; m<sb.length;m++)
            sb[m] = new StringBuilder("");
        int j=0;
        int f=1;
        for(int i=0 ; i<s.length() ; i++)
        {
            if(f==1){
                sb[j].append(s.charAt(i));
                j++;
                if(j==n)
                {
                    j--;
                    f=0;
                }
                    
                }
            
            else
                {
                    j--;
                    sb[j].append(s.charAt(i));
                    if(j==0){
                        f=1;
                        j++;
                        
                    }
                }
            
        }
        StringBuilder result = new StringBuilder();
            for (StringBuilder sr : sb)
                result.append(sr);
    
        return result.toString();
    }
    
}
/* Reverse Words in a string */
public class Solution {
    public String reverseWords(String s) {
        StringBuilder sb = new StringBuilder();
        if(s==null || s.length()<1)
            return sb.toString();
        String[] arr = s.split("\\s{1,}");
        for(int i=arr.length-1; i>=0 ; i--)
        {
            sb.append(arr[i] + " ");
        }
        return sb.toString().trim();
        
    }
}
/*Decode Characters (A-1, B-2,..Z-26) ITERATIVE*/
public class Solution {
    public int numDecodings(String s) {
        int n1 =1, n2=1, n3=0;
    if(s.length()==0||s.charAt(0)=='0') return 0;
    for(int i=2; i<=s.length(); i++)
    {
        n3=0;
        if(s.charAt(i-1)!='0') n3=n2;
        int num = Integer.parseInt(s.substring(i-2,i));
        if(num>=10 && num<=26) n3+=n1;
        n1=n2;
        n2=n3;
    }
    return n2;
    }
}
/* Decode Characters (A-1, B-2,..Z-26) RECURSIVE */
	
/* If a word can be segmented into one or more dictionary workds.*/
public class Solution {
    public boolean wordBreak(String s, Set<String> wordDict) {
        if (s == null && wordDict == null)
        return true;
    if (s == null || wordDict == null)
        return false;
    //dp[i] represents if s.substring(0, i+1) is wordbreakable.
    boolean[] dp = new boolean[s.length()+1];
    dp[0] = true;
    for (int i = 1; i <= s.length(); i++) {
        for (int j = 0; j < i; j++) {
            if (dp[j] && wordDict.contains(s.substring(j, i))) {
                dp[i] = true;
                break;
            }
        }
    }
    return dp[s.length()];
    }
}
/* Compute and return square root of X (sqrt(x)) */
public class Solution {
    public int mySqrt(int x) {
         if(x <= 0) return 0;
        int l = 1, r = x, res = 1;
        while(l < r) {
            int mid = (l + r) / 2;
            if(mid > x/mid) {
                r = mid;
            } else {
                res = mid;
                l = mid + 1;
            }
        }
        return res;
    }
}
/*Indexes of numbers in array which on adding forms a target value / Two Sum (INDEX IS NOT ZERO BASED)  */
public class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int[] result = new int[2];
    Map<Integer, Integer> map = new HashMap<Integer, Integer>();
    for (int i = 0; i < numbers.length; i++) {
        if (map.containsKey(target - numbers[i])) {
            result[1] = i + 1;
            result[0] = map.get(target - numbers[i]);
            return result;
        }
        map.put(numbers[i], i + 1);
    }
    return result;
    }
}
/* Rotate an image or square matrix by  90 degree WITH EXPLAINATION 
The idea is to loop through the top-left quadrant of the matrix (including the middle column for odd N), and for each element make 4-element swap (rotation). Meaning that for example if we have 5x5 M, and the current element is M[1,2] then we memorize M[1,2] into tmp and make: M[1,2] = M[2,1]; M[2,1] = M[3,2]; M[3,2] = M[2,3]; M[2,3] = tmp
*/
public class Solution {
    public void rotate(int[][] M) {
        for (int i = 0; i < (M.length+1)/2; i++) {
            for (int j = 0; j < M.length/2; j++) {
                int tmp = M[i][j];
                M[i][j] = M[M.length-j-1][i];
                M[M.length-j-1][i] = M[M.length-i-1][M.length-j-1];
                M[M.length-i-1][M.length-j-1] = M[j][M.length-i-1];
                M[j][M.length-i-1] = tmp;
            }
        }
    }
}
/* Validate Number/ validate if given string is numeric METHOD 1*/
public class Solution {
    public boolean isNumber(String s) {
        return s.matches("(\\s*)[+-]?((\\.[0-9]+)|([0-9]+(\\.[0-9]*)?))(e[+-]?[0-9]+)?(\\s*)");
    }
}
/* Validate Number/ validate if given string is numeric METHOD 2 */
public class Solution {
    public boolean isNumber(String s) {
         try {
        s = s.trim();
        int n = s.length();
        if ( n == 0 || (s.charAt(n-1) != '.' && (s.charAt(n-1) - '0' < 0 || s.charAt(n-1) - '0' > 9 )) ) {
            return false;
        }
        double i = Double.parseDouble(s);
        return true;
    }
    catch (NumberFormatException e) {
        return false;
    }
    }
}
/* Validate Number/ validate if given string is numeric METHOD 3 */
public class Solution {
    public boolean isNumber(String s) {
             s = s.trim();
    if (s.length() == 0)
        return false;
    if (s.matches("[+-]?(([0-9]*\\.?[0-9]+)|([0-9]+\\.?[0-9]*))([eE][+-]?[0-9]+)?"))
        return true;
    else
        return false;
    }
}
/* Validate Number/ validate if given string is numeric METHOD 4*/
public class Solution {
    public boolean isNumber(String s) {
    
         if (s == null) return false;

        s = s.trim();
        int n = s.length();

        if (n == 0) return false;

        // flags
        int signCount = 0;
        boolean hasE = false;
        boolean hasNum = false;
        boolean hasPoint = false;

        for (int i = 0; i < n; i++) {
            char c = s.charAt(i);

            // invalid character
            if (!isValid(c)) return false;

            // digit is always fine
            if (c >= '0' && c <= '9') hasNum = true;

            // e or E
            if (c == 'e' || c == 'E') {
                // e cannot appear twice and digits must be in front of it
                if (hasE || !hasNum) return false;
                // e cannot be the last one
                if (i == n - 1) return false;

                hasE = true;
            }

            // decimal place
            if (c == '.') {
                // . cannot appear twice and it cannot appear after e
                if (hasPoint || hasE) return false;
                // if . is the last one, digits must be in front of it, e.g. "7."
                if (i == n - 1 && !hasNum) return false;

                hasPoint = true;
            }

            // signs
            if (c == '+' || c == '-') {
                // no more than 2 signs
                if (signCount == 2) return false;
                // sign cannot be the last one
                if (i == n - 1) return false;
                // sign can appear in the middle only when e appears in front
                if (i > 0 && !hasE) return false;

                signCount++;
            }
        }

        return true;
    
    }
    boolean isValid(char c) {
        return c == '.' || c == '+' || c == '-' || c == 'e' || c == 'E' || c >= '0' && c <= '9';
    }
}
/* Justify Text / Justification / Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified.*/
public class Solution {
    public List<String> fullJustify(String[] words, int L) {
        List<String> lines = new ArrayList<String>();

        int index = 0;
        while (index < words.length) {
            int count = words[index].length();
            int last = index + 1;
            while (last < words.length) {
                if (words[last].length() + count + 1 > L) break;
                count += words[last].length() + 1;
                last++;
            }

            StringBuilder builder = new StringBuilder();
            int diff = last - index - 1;
            // if last line or number of words in the line is 1, left-justified
            if (last == words.length || diff == 0) {
                for (int i = index; i < last; i++) {
                    builder.append(words[i] + " ");
                }
                builder.deleteCharAt(builder.length() - 1);
                for (int i = builder.length(); i < L; i++) {
                    builder.append(" ");
                }
            } else {
                // middle justified
                int spaces = (L - count) / diff;
                int r = (L - count) % diff;
                for (int i = index; i < last; i++) {
                    builder.append(words[i]);
                    if (i < last - 1) {
                        for (int j = 0; j <= (spaces + ((i - index) < r ? 1 : 0)); j++) {
                            builder.append(" ");
                        }
                    }
                }
            }
            lines.add(builder.toString());
            index = last;
        }
        return lines;
    }
}
/*Maximum numbers of points on a Line / maximum number of points that lie on the same straight line / Given n points in 2D plane METHOD 1 */
/**
 * Definition for a point.
 * class Point {
 *     int x;
 *     int y;
 *     Point() { x = 0; y = 0; }
 *     Point(int a, int b) { x = a; y = b; }
 * }
 */
public class Solution {
    public int maxPoints(Point[] points) {
         if(points.length <= 0) return 0;
        if(points.length <= 2) return points.length;
        int result = 0;
        for(int i = 0; i < points.length; i++){
            HashMap<Double, Integer> hm = new HashMap<Double, Integer>();
            int samex = 1;
            int samep = 0;
            for(int j = 0; j < points.length; j++){
                if(j != i){
                    if((points[j].x == points[i].x) && (points[j].y == points[i].y)){
                        samep++;
                    }
                    if(points[j].x == points[i].x){
                        samex++;
                        continue;
                    }
                    double k = (double)(points[j].y - points[i].y) / (double)(points[j].x - points[i].x);
                    if(hm.containsKey(k)){
                        hm.put(k,hm.get(k) + 1);
                    }else{
                        hm.put(k, 2);
                    }
                    result = Math.max(result, hm.get(k) + samep);
                }
            }
            result = Math.max(result, samex);
        }
        return result;
    }
}
/* /*Maximum numbers of points on a Line / maximum number of points that lie on the same straight line / Given n points in 2D plane METHOD 2*/
/**
 * Definition for a point.
 * class Point {
 *     int x;
 *     int y;
 *     Point() { x = 0; y = 0; }
 *     Point(int a, int b) { x = a; y = b; }
 * }
 */
public class Solution {
    public int maxPoints(Point[] points) {
         int n=points.length;
            if (n<2) return n;
            int currentL=0,maxL=2,x=0,y=0,dx=0,dy=0,overlap=0,upperB=n;
            for(int i=0; i<upperB; i++)
            {
                for(int j=i+1; j<n; j++)
                {
                    currentL=1; 
/*
 * Given two points: (a,b) and (c,d), the corresponding normal vector is (b-d,c-a)
 * If another point (s,t) is in the same line uniquely defined by (a,b) and (c,d),
 * then (s-a,t-b) dot (b-d,c-a) = 0
 */
                    x=points[i].y-points[j].y;
                    y=points[j].x-points[i].x;

/* If two points are the same, there is no need to check further, 
 * since a line has to be defined by exactly two distinct points.
 */
                    if(x==0 && y==0) 
                        overlap++;

/* Well, it might be the case that duplicates are not consecutive, 
 * but as long as we can have a non-trivial normal vector, it won't matter.
 */ 
                    else 
                    {
                        currentL++;

/*  Explaining (currentL+n-k>maxL):
 *  no further checking is necessary when there isn't enough left to make it surpass maxL. 
 */ 
                        for(int k=j+1; k<n && currentL+n-k>maxL; k++)
                        {
                            dx=points[k].x-points[i].x;
                            dy=points[k].y-points[i].y;
                            if(x*dx+y*dy==0)
                                currentL++;
                        }
                    }
                    maxL=Math.max(currentL+overlap,maxL);
                }

/* Explaining (upperB=n-maxL): 
 * it would be crystal clear as soon as you draw a table for combinations of case n>3.
 */
                upperB=n-maxL;
                overlap=0;
            }
            return maxL;
    }
}
/*Implement LRU Cache */
import java.util.*;
public class LRUCache {
    
    private LinkedHashMap<Integer, Integer> pairs;
private int capacity;
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
    this.pairs = new LinkedHashMap<Integer, Integer>() {
        protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
            return size() > capacity;
        }
    };
    }
    
    public int get(int key) {
        if (pairs.containsKey(key)) {
        int value = pairs.get(key);
        pairs.remove(key);
        pairs.put(key, value);
        return pairs.get(key);
    }
    else {
        return -1;
    }
    }
    
    public void set(int key, int value) {
        if (pairs.containsKey(key)) {
        pairs.remove(key);
    }
    pairs.put(key, value);   
    }
}
/* Substring with concatenation of all words / index of combination of words in a string.*/
public class Solution {
    public List<Integer> findSubstring(String S, String[] L) {
         List<Integer> res = new ArrayList<Integer>();
    if (S == null || L == null || L.length == 0) return res;
    int len = L[0].length(); // length of each word

    Map<String, Integer> map = new HashMap<String, Integer>(); // map for L
    for (String w : L) map.put(w, map.containsKey(w) ? map.get(w) + 1 : 1);

    for (int i = 0; i <= S.length() - len * L.length; i++) {
        Map<String, Integer> copy = new HashMap<String, Integer>(map);
        for (int j = 0; j < L.length; j++) { // checkc if match
            String str = S.substring(i + j*len, i + j*len + len); // next word
            if (copy.containsKey(str)) { // is in remaining words
                int count = copy.get(str);
                if (count == 1) copy.remove(str);
                else copy.put(str, count - 1);
                if (copy.isEmpty()) { // matches
                    res.add(i);
                    break;
                }
            } else break; // not in L
        }
    }
    return res;   
    }
}
/* Regular Expression Matching / String matching using regular expression RECURSIVE*/
public class Solution {
    public boolean isMatch(String s, String p) {
         if (p.isEmpty()) {
        return s.isEmpty();
    }

    if (p.length() == 1 || p.charAt(1) != '*') {
        if (s.isEmpty() || (p.charAt(0) != '.' && p.charAt(0) != s.charAt(0))) {
            return false;
        } else {
            return isMatch(s.substring(1), p.substring(1));
        }
    }

    //P.length() >=2
    while (!s.isEmpty() && (s.charAt(0) == p.charAt(0) || p.charAt(0) == '.')) {  
        if (isMatch(s, p.substring(2))) { 
            return true;                     
        }                                    
        s = s.substring(1);
    }

    return isMatch(s, p.substring(2));
    }
}
/* Regular Expression Matching / String matching using regular expression DP (ITERATIVE)*/
public class Solution {
    public boolean isMatch(String s, String p) {
int sL=s.length(), pL=p.length();

    boolean[][] dp = new boolean[sL+1][pL+1];
    dp[0][0] = true; // If s and p are "", isMathch() returns true;

    for(int i=0; i<=sL; i++) {

        // j starts from 1, since dp[i][0] is false when i!=0;
        for(int j=1; j<=pL; j++) {
            char c = p.charAt(j-1);

            if(c != '*') {
                // The last character of s and p should match;
                // And, dp[i-1][j-1] is true;
                dp[i][j] = i>0 && dp[i-1][j-1] && (c=='.' || c==s.charAt(i-1));
            }
            else {
                // Two situations:
                // (1) dp[i][j-2] is true, and there is 0 preceding element of '*';
                // (2) The last character of s should match the preceding element of '*';
                //     And, dp[i-1][j] should be true;
                dp[i][j] = (j>1 && dp[i][j-2]) ||
                           (i>0 && dp[i-1][j] && (p.charAt(j-2)=='.' || p.charAt(j-2)==s.charAt(i-1)));
            }
        }
    }

    return dp[sL][pL];
    }
}
/*Interleaving Strings ITERATIVE (DP)*/
public class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        int m = s1.length(), n = s2.length();
    if (n + m != s3.length()) return false;
    if (s3.length() == 0) return true;

    boolean[][] dp = new boolean[m+1][n+1];
    dp[0][0] = true;
    for (int i = 0; i <= m; i++) {
        if (s1.substring(0, i).equals(s3.substring(0, i))) 
            dp[i][0] = true;
        else 
            dp[i][0] = false;
    }
    for (int j = 0; j <= n; j++) {
        if (s2.substring(0, j).equals(s3.substring(0, j))) 
            dp[0][j] = true;
        else 
            dp[0][j] = false;
    }
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            dp[i][j] = (dp[i-1][j] && s1.charAt(i-1) == s3.charAt(i+j-1)) 
                    || (dp[i][j-1] && s2.charAt(j-1) == s3.charAt(i+j-1));
        }
    }
    return dp[m][n];
    }
}
/* Interleaving Strings RECURSIVE*/
public class Solution {
    int[][] checkedPaths;
    public boolean isInterleave(String s1, String s2, String s3) {
       if(s1.length() + s2.length() != s3.length())
            return false;       

        checkedPaths = new int[s1.length()][s2.length()];

        for(int i = 0 ; i < s1.length() ; i++){
            for(int j = 0 ; j < s2.length() ; j++){
                checkedPaths[i][j] = -1;
            }
        }

        return checkNext(s1, s2, s3);
    }
     private boolean checkNext(String s1, String s2, String s3){
        if(s3.length() == 0)
            return true;

        if(s1.length() == 0)
            return s2.equals(s3);

        if(s2.length() == 0)
            return s1.equals(s3);

        if(checkedPaths[s1.length() - 1][s2.length() - 1] == 1){
            return false;
        } else{
            checkedPaths[s1.length() - 1][s2.length() -1] = 1;
        }

        boolean s1Match = s1.charAt(0) == s3.charAt(0);
        boolean s2Match = s2.charAt(0) == s3.charAt(0);

        if(s1Match && s2Match){
            return ( checkNext(s1.substring(1), s2, s3.substring(1)) || checkNext(s1, s2.substring(1), s3.substring(1)) );
        } else if(s1Match){
            return checkNext(s1.substring(1), s2, s3.substring(1));
        } else if(s2Match){
            return checkNext(s1, s2.substring(1), s3.substring(1));
        } else {
            return false;
        }
    }
}
/*Longest Valid Parenthesis METHOD 1 */
public class Solution {
    public int longestValidParentheses(String s) {
     Stack<Integer> stack = new Stack<Integer>();
    int max=0;
    int left = -1;
    for(int j=0;j<s.length();j++){
        if(s.charAt(j)=='(') stack.push(j);            
        else {
            if (stack.isEmpty()) left=j;
            else{
                stack.pop();
                if(stack.isEmpty()) max=Math.max(max,j-left);
                else max=Math.max(max,j-stack.peek());
               }
            }
        }
    return max;   
    }
}
/* Longest Valid Parenthesis METHOD 2 */
public class Solution {
    public int longestValidParentheses(String s) {
        char[] S = s.toCharArray();
    int[] V = new int[S.length];
    int open = 0;
    int max = 0;
    for (int i=0; i<S.length; i++) {
        if (S[i] == '(') open++;
        if (S[i] == ')' && open > 0) {
            V[i] = 2 + V[i-1] + (i-2-V[i-1] > 0 ? V[i-2-V[i-1]] : 0);
            open--;
        }
        if (V[i] > max) max = V[i];
    }
    return max;
        }
}
/* Merge K sorted list RECURSION METHOD 1*/
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
         if(lists == null || lists.length == 0 ){
        return null;
    }
    return mergeKLists(lists,0,lists.length-1);
    }
    public ListNode mergeKLists(ListNode[] lists, int left, int right){
    if(left < right){
        int mid = (left + right)/2;
        return merge(mergeKLists(lists,left,mid),mergeKLists(lists,mid+1,right));
    }
    return lists[left];
}
public ListNode merge(ListNode n1, ListNode n2){
    ListNode head =  new ListNode(0);
    ListNode n = head;
    while(n1 != null && n2 != null){
        if(n1.val < n2.val){
            n.next = n1;
            n1 = n1.next;
            n = n.next;
        }else{
            n.next = n2;
            n = n.next;
            n2 = n2.next;
        }
    }
    if( n1 != null){
        n.next = n1;
    }else{
        n.next = n2;
    }
    return head.next;
}
}
/*Merge K sorted lists using RECURSION METHOD 2*/
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
 public class Solution{
public static ListNode mergeKLists(ListNode[] lists){
    return partion(lists,0,lists.length-1);
}

public static ListNode partion(ListNode[] lists,int s,int e){
    if(s==e)  return lists[s];
    if(s<e){
        int q=(s+e)/2;
        ListNode l1=partion(lists,s,q);
        ListNode l2=partion(lists,q+1,e);
        return merge(l1,l2);
    }else
        return null;
}

//This function is from Merge Two Sorted Lists.
public static ListNode merge(ListNode l1,ListNode l2){
    if(l1==null) return l2;
    if(l2==null) return l1;
    if(l1.val<l2.val){
        l1.next=merge(l1.next,l2);
        return l1;
    }else{
        l2.next=merge(l1,l2.next);
        return l2;
    }
}
}
/*Merge K sorted lists using Priority Queue */
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
      if (lists==null||lists.length==0) return null;

        PriorityQueue<ListNode> queue= new PriorityQueue<ListNode>(lists.length,new Comparator<ListNode>(){
            @Override
            public int compare(ListNode o1,ListNode o2){
                if (o1.val<o2.val)
                    return -1;
                else if (o1.val==o2.val)
                    return 0;
                else 
                    return 1;
            }
        });

        ListNode dummy = new ListNode(0);
        ListNode tail=dummy;

        for (ListNode node:lists)
            if (node!=null)
                queue.add(node);

        while (!queue.isEmpty()){
            tail.next=queue.poll();
            tail=tail.next;

            if (tail.next!=null)
                queue.add(tail.next);
        }
        return dummy.next;
}
}

/*Summary ranges */
public class Solution {
    public List<String> summaryRanges(int[] nums) {
        StringBuffer sb = new StringBuffer();
        List<String> res= new ArrayList<String>();
        if(nums == null || nums.length==0)
            return res;
        if(nums.length==1)
        {
            sb.append(nums[0]);
            res.add(sb.toString());
            return res;
        }
        int p=0;
        for (int i = 1; i < nums.length; i++) 
        {
            if (nums[i] == nums[i - 1] + 1) 
            {
                if (i == nums.length - 1) 
                {
                    res.add(nums[p] + "->" + nums[i]);
                }
            } 
            else 
            { 
                if (i == p + 1) 
                {
                    res.add(nums[p] + "");
                } 
                else 
                {
                    res.add(nums[p] + "->" + nums[i - 1]);
                }
                if (i == nums.length - 1) 
                {
                    res.add(nums[i] + "");
                }
                p = i;
            }
        }
        return res;
    }
}
/*3 Sum closest */
public class Solution {
    public int threeSumClosest(int[] nums, int target) {
        if(nums.length==3)
            return (nums[0]+nums[1]+nums[2]) ;
        Arrays.sort(nums);
        int diff = Integer.MAX_VALUE;
        int output=0;
        for(int i=0; i<nums.length-2;i++)
        {
            int low=i+1;
            int high = nums.length-1;
            while(low<high)
            {
                int sum = nums[i] + nums[low] + nums[high];
                if(Math.abs(target-sum)<diff)
                {
                    diff = Math.abs(target-sum);
                    output=sum;   
                }
                if(sum>target)
                    high--;
                else
                    low++;
            }
        }
        return output;
    }
}
/*3 Sum zero / 3sum zero / 3 numbers sum to zero*/
public class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
            List<List<Integer>> li = new ArrayList<List<Integer>>();
        Arrays.sort(nums);
        for(int i=0 ; i<=nums.length-3 ; i++)
        {
            if(i>0 && nums[i]==nums[i-1])
                continue;
            int start=i+1;
            int end= nums.length-1;
            while(start<end)
            {
                if(start>i+1 && nums[start]==nums[start-1])
                {
                    start++;
                    continue;
                }
                if(end<nums.length-1 && nums[end]==nums[end+1])
                {
                    end--;
                    continue;
                }
                int sum = nums[i]+ nums[start] +nums[end];
                if(sum==0)
                {
                    List<Integer> l = new ArrayList<Integer>();
                    l.add(nums[i]);
                    l.add(nums[start]);
                    l.add(nums[end]);
                    li.add(l);
                    start++;
                    end--;
                }
                else if(sum>0)
                    end--;
                else
                    start++;
            }
            
        }
        return li;        
    }
}

/* get the row of a pascal triangle (worst case)*/
public class Solution {
    public List<Integer> getRow(int k) {
        Integer[] arr = new Integer[k + 1];
        Arrays.fill(arr, 0);
        arr[0] = 1;

        for (int i = 1; i <= k; i++) 
            for (int j = i; j > 0; j--) 
                arr[j] = arr[j] + arr[j - 1];

        return Arrays.asList(arr);
    }
}
/* get the row of a pascal triangle (best case)*/
public class Solution {
    public List<Integer> getRow(int rowIndex) {
 List<Integer> result = new ArrayList<Integer>();
        result.add(1);
        long tmp = 1;
        for(int i=1;i<=rowIndex ; i++){
            tmp = tmp*(rowIndex-i+1)/i;
            result.add((int)(tmp));
        }
        return result;
    }
}
/* Replace element from an array and find the new length of array */
public class Solution {
    public int removeElement(int[] nums, int val) {
       int low=0;
       int high = nums.length-1;
       while(low<=high)
       {
           while(high>low && nums[high]==val)
           {
               high--;
           }
            if(nums[low]==val)
           {
               nums[low] = nums[high]; 
               high--;
           }
           low++;
       }
       return high+1;
    }
}
/* 4 Sum to a target value / 4sum target / 4 numbers sum to a given number */
public class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        Set<List<Integer>> resultSet = new HashSet<List<Integer>>();
        int a, b, c, d, start, end;
        Arrays.sort(nums);
        for(int i = 0; i < nums.length - 3; i++) {
            a = nums[i];
            for(int j = i + 1; j < nums.length - 2; j++) {
                b = nums[j];
                start = j + 1;
                end = nums.length - 1;
                while(start < end) {
                    c = nums[start];
                    d = nums[end];
                    if(a + b + c + d == target) {
                        List<Integer> quadruple = new ArrayList<Integer>();
                        quadruple.add(a);
                        quadruple.add(b);
                        quadruple.add(c);
                        quadruple.add(d);
                        resultSet.add(quadruple);
                        start++;
                        end--;
                    } else if(a + b + c + d < target)
                        start++;
                      else
                        end--;
                }
            }
        }
        List<List<Integer>> result = new ArrayList<List<Integer>>();
        result.addAll(resultSet);
        return result;
    }
}
/* index of Peak Element. Peak element is the element who is greater than his neighbours.*/
public class Solution {
    public int findPeakElement(int[] nums) {
        int max = Integer.MIN_VALUE;
        int j=0;
        for (int i=0; i<nums.length ; i++)
        {
            if(nums[i]>max)
            {
                max=nums[i];
                j=i;
            }
        }
        return j;
    }
}
/* Minimum element in rotated sorted array*/
public class Solution {
    public int findMin(int[] nums) {
         int l = 0, r = nums.length-1;
     while (l < r) {
         int mid = (l + r) / 2;
         if (nums[mid] < nums[r]) {
            //right side in order, and mid is smallest of right side,
            // min should be mid or in left.
             r = mid;   
         } else {
            //left side in order and it is the larger part,
            // min should be in right side.
             l = mid + 1; 
         }
     }
     return nums[l];
    }
}
/* First missing positive */
public class Solution {
    public int firstMissingPositive(int[] nums) {
        if(nums == null || nums.length ==0)
        return 1;
        int i = 0, n = nums.length;
    while (i < n) {
        // If the current value is in the range of (0,length) and it's not at its correct position, 
        // swap it to its correct position.
        // Else just continue;
        if (nums[i] >= 0 && nums[i] < n && nums[nums[i]] != nums[i])
            swap(nums, i, nums[i]);
        else
            i++;
    }
    int k = 1;

    // Check from k=1 to see whether each index and value can be corresponding.
    while (k < n && nums[k] == k)
        k++;

    // If it breaks because of empty array or reaching the end. K must be the first missing number.
    if (n == 0 || k < n)
        return k;
    else   // If k is hiding at position 0, K+1 is the number. 
        return nums[0] == k ? k + 1 : k;
    }
    private void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
}
/*Max / Maximum jump to reach the end of array */
public class Solution {
    public boolean canJump(int[] nums) {
        int maxIndex = nums.length-1;
    int maxJump  = nums[0];
    for(int i = 0; i <= maxJump; i++)
    {
        maxJump=Math.max(maxJump,i+nums[i]);
        if(maxJump>=maxIndex) return true;
    }
    return false;
    }
}
/* Valid / validate parenthesis using stack*/
if (s.length() == 0) return true;
        Stack<Character> stack = new Stack<Character>();

        for(int i = 0; i < s.length(); ++i){
            Character c = s.charAt(i);
            if (c == '(' || c == '[' || c == '{') stack.push(c);
            else if (stack.empty()) return false;
            else{
                Character c2 = stack.pop();
                if(c2 == '(' && c != ')' || c2 == '{' && c != '}' || c2 == '[' && c != ']') return false;
            }
        }

        return stack.empty();
/* Valid / validate parenthesis using both Hashmap and stack */
public class Solution {
    public boolean isValid(String s) {
         if(s==null){ return true; }

    Stack<Character> charStack = new Stack<>();
    Map<Character, Character> charMap = initCharMap();
    for(Character ch : s.toCharArray()){
        if(charStack.isEmpty()){
            if(charMap.keySet().contains(ch)){
                return false;
            }
            else{
                charStack.push(ch);
            }
        }
        else{
            if(charStack.peek()==charMap.get(ch)){
                charStack.pop();
            }
            else{
                charStack.push(ch);
            }
        }
    }
    if(charStack.isEmpty()){
        return true;
    }
    return false;

}
private Map<Character, Character> initCharMap(){
    Map<Character, Character> charMap = new HashMap<>();
    charMap.put(')','(');
    charMap.put(']','[');
    charMap.put('}','{');
    return charMap;

        }
    }
/* Trapping Rain Water */
public class Solution {
    public int trap(int[] heights) {
        if(heights == null || heights.length < 2){ return 0; }

    int res = 0;

    int min = 0;
    int max = heights.length - 1;

    int minVal = heights[min];
    int maxVal = heights[max];

    while(max - min > 1){
        if(minVal <= maxVal){
            if(heights[min+1] > minVal){
                minVal = heights[min+1];
                min ++;
            }
            else{
                res += minVal - heights[min+1];
                min ++;
            }
        }
        else{
            if(heights[max-1] > maxVal){
                maxVal = heights[max-1];
                max --;
            }
            else{
                res += maxVal - heights[max-1];
                max --;
            }
        }
    }

    return res;

    }
}
/* Trapping Rain Water using stack*/
public class Solution {
    public int trap(int[] A) {
        Stack<Integer> stack = new Stack<Integer>();
        int sum = 0;
        int pre = 0;
        int i = -1;
        while(++i < A.length){
            if(A[i]==0){pre = 0;continue;}
            while(!stack.isEmpty() && A[i] >= A[stack.peek()]){
                sum += (A[stack.peek()] - pre) * (i-stack.peek()-1);
                pre = A[stack.pop()];
            }
            if(!stack.isEmpty()){
                sum += (A[i] - pre) * (i-stack.peek()-1);
                pre = A[i];
            }
            stack.push(i);
        }
        return sum;
    }
}

/* Min stack / Minimum stack*/
class MinStack {
    Stack<Integer> mainStack = new Stack<Integer>();
        Stack<Integer> minStack = new Stack<Integer>();

        public void push(int x) {
            mainStack.push(x);
            if (minStack.empty()) {
                minStack.push(x);
            } else if (minStack.peek() >= x) {
                minStack.push(x);
            }
        }

        public void pop() {
            int poppedElement = mainStack.pop();
            if (poppedElement == minStack.peek()) {
                minStack.pop();
            }
        }

        public int top() {
            return mainStack.peek();
        }

        public int getMin() {
            return minStack.peek();
        }
}
/*Preorder traversal of BST recursion*/
public class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<Integer>();
    if (root!=null) {
        list.add(root.val);
        list.addAll(preorderTraversal(root.left));
        list.addAll(preorderTraversal(root.right));
    }
    return list;
    }
}
/*Preorder traversal of BST iterative solution*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
         List<Integer> answer = new LinkedList<Integer>();
         Stack<TreeNode> stack = new Stack<TreeNode>();

         if(root==null)
         {
             return answer;
         }

         stack.push(root);
         while(stack.isEmpty()==false)
         {
             TreeNode node = stack.pop();
             answer.add(node.val);
             if(node.right!=null)
             {
                 stack.push(node.right);
             }
             if(node.left!=null)
             {
                 stack.push(node.left);
             }
         }
         return answer;
    }
}
/*Postorder traversal of BST iterative solution*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        LinkedList<Integer> ans = new LinkedList<>();
    Stack<TreeNode> stack = new Stack<>();
    if (root == null) return ans;

    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode cur = stack.pop();
        ans.addFirst(cur.val);
        if (cur.left != null) {
            stack.push(cur.left);
        }
        if (cur.right != null) {
            stack.push(cur.right);
        } 
    }
    return ans;
    }
}
/*Postorder traversal of BST recursive solution*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
                List<Integer> list = new ArrayList<Integer>();
    if (root!=null) {
        
        list.addAll(postorderTraversal(root.left));
        list.addAll(postorderTraversal(root.right));
        list.add(root.val);
        
    }
    return list;

    }
}
/*Inorder traversal of BST recursive solution*/

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
                   List<Integer> list = new ArrayList<Integer>();
    if (root!=null) {
        
        list.addAll(inorderTraversal(root.left));
        list.add(root.val);
        list.addAll(inorderTraversal(root.right));
        
        
    }
    return list;

    }
}
/*Inorder traversal of BST iterative solution*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        
        List<Integer> ans = new ArrayList<>();
                Stack<TreeNode> stack = new Stack<>();
    TreeNode cur = root;
    while (!stack.isEmpty() || cur != null) {
        while (cur != null) {
            stack.push(cur);
            cur = cur.left;
        }
        cur = stack.pop();
        ans.add(cur.val);
        cur = cur.right;
    }
    return ans;

    }
}
/*Binary Search tree BST Iterator*/
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

public class BSTIterator {
private Stack<TreeNode> stack = null;
    public BSTIterator(TreeNode root) {
        stack = new Stack<>();

    TreeNode curr = root;
    while(curr!=null){
        stack.push(curr);
        curr = curr.left;
    }
    }

    /** @return whether we have a next smallest number */
    public boolean hasNext() {
        return !stack.isEmpty();
    }

    /** @return the next smallest number */
    public int next() {
        if(hasNext()){
        int ret = stack.peek().val;
        TreeNode curr = stack.pop();
        if(curr.right!=null){
            curr = curr.right;

            while(curr!=null){
                stack.push(curr);
                curr = curr.left;
            }
        }
        return ret;
    }
    return -1;
    }
}

/**
 * Your BSTIterator will be called like this:
 * BSTIterator i = new BSTIterator(root);
 * while (i.hasNext()) v[f()] = i.next();
 */
/*Basic maths calculator using stack / evaluate arithmetic expression.*/
public class Solution {
    public int calculate(String s) {
     Stack<Integer> stack = new Stack<Integer>();
    int result = 0;
    int number = 0;
    int sign = 1;
    for(int i = 0; i < s.length(); i++){
        char c = s.charAt(i);
        if(Character.isDigit(c)){
            number = 10 * number + (int)(c - '0');
        }else if(c == '+'){
            result += sign * number;
            number = 0;
            sign = 1;
        }else if(c == '-'){
            result += sign * number;
            number = 0;
            sign = -1;
        }else if(c == '('){
            //we push the result first, then sign;
            stack.push(result);
            stack.push(sign);
            //reset the sign and result for the value in the parenthesis
            sign = 1;   
            result = 0;
        }else if(c == ')'){
            result += sign * number;  
            number = 0;
            result *= stack.pop();    //stack.pop() is the sign before the parenthesis
            result += stack.pop();   //stack.pop() now is the result calculated before the parenthesis

        }
    }
    if(number != 0) result += sign * number;
    return result;
}
}
/* Zig zag traversal of binary search tree BST */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        
        Stack<TreeNode> s1 = new Stack<TreeNode>();
        Stack<TreeNode> s2 = new Stack<TreeNode>();
        TreeNode curr = root;
        s1.push(curr);
        List<List<Integer>> arlist = new ArrayList<List<Integer>>();
        if(root==null)
            return arlist;
        while(!s1.isEmpty() || !s2.isEmpty())
        {
            List<Integer> li1 = new ArrayList<Integer>();
            List<Integer> li2 = new ArrayList<Integer>();
            int flag1 = 0;
            int flag2 = 0;
            while(!s1.isEmpty())
            {
                flag1=1;
                li1.add(s1.peek().val);
                if(s1.peek().left!=null)
                    s2.push(s1.peek().left);
                if(s1.peek().right!=null)
                    s2.push(s1.peek().right);
                s1.pop();
                
            }
            if(flag1==1)
            arlist.add(li1);
            while(!s2.isEmpty())
            {
                flag2=1;
                li2.add(s2.peek().val);
                if(s2.peek().right!=null)
                    s1.push(s2.peek().right);
                if(s2.peek().left!=null)
                    s1.push(s2.peek().left);
                s2.pop();
                
            }
            if(flag2==1)
            arlist.add(li2);
        }
        return arlist;
    }
}
/* Stack implementation using queue*/
class MyStack {
    Queue<Integer> qu = new LinkedList<Integer>();
    
    
    // Push element x onto stack.
    public void push(int x) {
        qu.add(x);
        for(int i=0; i<qu.size()-1; i++)
        {
            qu.add(qu.remove());
        }
        
    }

    // Removes the element on top of the stack.
    public void pop() {
        qu.remove();
    }

    // Get the top element.
    public int top() {
        return qu.peek();
    }

    // Return whether the stack is empty.
    public boolean empty() {
        return qu.isEmpty();
    }
}
/* queue implementation using stack*/
class MyQueue {
    // Push element x to the back of queue.
    Stack<Integer> s1 = new Stack<Integer>();
    Stack<Integer> s2 = new Stack<Integer>();
    public void push(int x) {
        s1.push(x);
    }

    // Removes the element from in front of queue.
    public void pop() {
        if(!s2.isEmpty()){
            s2.pop();
        return;
        }
        while(!s1.isEmpty()){
            s2.push(s1.pop());
        }
        s2.pop();
    }

    // Get the front element.
    public int peek() {
        if(!s2.isEmpty())
            return s2.peek();
        while(!s1.isEmpty())
        {
            s2.push(s1.pop());
        }
        return s2.peek();
    }

    // Return whether the queue is empty.
    public boolean empty() {
        return s1.isEmpty()&&s2.isEmpty();
    }
}
/* Reverse Polish Notation */
public class Solution {
    public int evalRPN(String[] tokens) {
        
        Stack<Integer> stack = new Stack<Integer>();
    int temp;
    for (int i = 0; i < tokens.length; i++) {
        switch (tokens[i]) {
        case "+":
            temp = stack.pop();
            stack.push(temp + stack.pop());
            break;
        case "-":
            temp = stack.pop();
            stack.push(stack.pop() - temp);
            break;
        case "*":
            temp = stack.pop();
            stack.push(stack.pop() * temp);
            break;
        case "/":
            temp = stack.pop();
            stack.push(stack.pop() / temp);
            break;
        default:
            stack.push(Integer.parseInt(tokens[i]));
        }
    }

    return stack.peek();
        
    }
}
/* Largest Rectangle in Histogram*/

public class Solution {
    public int largestRectangleArea(int[] height) {
        if(height == null || height.length==0)
            return 0;
        int len = height.length;
        Stack<Integer> s = new Stack<Integer>();
        int maxArea = 0;
        for(int i = 0; i <= len; i++){
            int h = (i == len ? 0 : height[i]);
            if(s.isEmpty() || h >= height[s.peek()]){
                s.push(i);
            }else{
                int tp = s.pop();
                maxArea = Math.max(maxArea, height[tp] * (s.isEmpty() ? i : i - 1 - s.peek()));
                i--;
            }
        }
        return maxArea;
    }
}
/* Simplify path to get the home directory*/

public class Solution {
    public String simplifyPath(String path) {
        Stack<String> st = new Stack<String>();
        String [] str = path.split("/");
        for (String s:str)
        {
            if(s==null || "".equals(s) || ".".equals(s))
                continue;
        
            if("..".equals(s))
                {
                    if(!st.isEmpty())
                        st.pop();
                }
                else
                        st.push(s);
                
        }
        if(st.isEmpty())
        {
            return "/";
        }
        StringBuilder str_build = new StringBuilder("");
        for(String newStr:st)
        {
            str_build.append("/"+newStr);
        }
        return str_build.toString();
    }
}
/*Zig Â Zag conversion of string*/
public class Solution {
    public String convert(String s, int n) {
        if (s.length()==0 || n==1)
            return s;
        StringBuilder[] sb = new StringBuilder[n];
        for(int m=0; m<sb.length;m++)
            sb[m] = new StringBuilder("");
        int j=0;
        int f=1;
        for(int i=0 ; i<s.length() ; i++)
        {
            if(f==1){
                sb[j].append(s.charAt(i));
                j++;
                if(j==n)
                {
                    j--;
                    f=0;
                }
                    
                }
            
            else
                {
                    j--;
                    sb[j].append(s.charAt(i));
                    if(j==0){
                        f=1;
                        j++;
                        
                    }
                }
            
        }
        StringBuilder result = new StringBuilder();
            for (StringBuilder sr : sb)
                result.append(sr);
    
        return result.toString();
    }
    
}
/*Reverse an integer number */
public class Solution {
    public int reverse(int x) {
        
        int f=0;
        if(x<0)
        {
            x=x* (-1);
            f=1;
        }
        if(x%10==x)
            return x;
        int y = x;
        int n; 
        long r=0;
        while(y>0)
        {
            r = r*10; 
            n=y%10;
            r=n+r;
            y=y/10;
        }
        if(r>Integer.MAX_VALUE || r<Integer.MIN_VALUE)
            return 0;
            if(f==1)
            return (int)r*(-1);
        else
            return (int)r;
    }
}
/*String to integer / atoi */
public class Solution {
    public int myAtoi(String str) {
        int index = 0, sign = 1, total = 0;
    //1. Empty string
    if(str.length() == 0) return 0;

    //2. Remove Spaces
     
    while(str.charAt(index) == ' ' && index < str.length())
        index ++;

    //3. Handle signs
    if(str.charAt(index) == '+' || str.charAt(index) == '-'){
        sign = str.charAt(index) == '+' ? 1 : -1;
        index ++;
    }

    //4. Convert number and avoid overflow
    while(index < str.length()){
        int digit = str.charAt(index) - '0';
        if(digit < 0 || digit > 9) break;

        //check if total will be overflow after 10 times and add digit
        if(Integer.MAX_VALUE/10 < total || Integer.MAX_VALUE/10 == total && Integer.MAX_VALUE %10 < digit)
            return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;

        total = 10 * total + digit;
        index ++;
    }
    return total * sign;
    }
}
/*check if integer is palindrome or not*/
public class Solution {
    public boolean isPalindrome(int x) {
         int xx = x;
        int reversed = 0;

        while(xx > 0) {
            reversed = reversed * 10 + xx % 10;
            xx /= 10;
        }
        return x == reversed;
    }
}
/*Roman to Integer*/
public class Solution {
    public int romanToInt(String s) {
          int result = 0;
        char[] sChar = s.toCharArray();
        HashMap<Character, Integer> map = new HashMap<Character, Integer>();
        map.put('I',1);
        map.put('V',5);
        map.put('X',10);
        map.put('L',50);
        map.put('C',100);
        map.put('D',500);
        map.put('M',1000);
        if(sChar.length == 1) return map.get(sChar[0]);
        for(int i = 0; i < sChar.length-1; i++){
            if( map.get(sChar[i]) >= map.get(sChar[i+1]) )
                result += map.get(sChar[i]);
            else
                result -= map.get(sChar[i]);
         }
         result += map.get(sChar[sChar.length-1]);
         return result;
    }
}

/*Roman to Integer -2*/
public class Solution {
    public int romanToInt(String s) {
       

        if(s == null || s.length() == 0) return 0;
        int len = s.length();
        HashMap<Character,Integer> map = new HashMap<Character,Integer>();
        map.put('I',1);
        map.put('V',5);
        map.put('X',10);
        map.put('L',50);
        map.put('C',100);
        map.put('D',500);
        map.put('M',1000);
        int result = map.get(s.charAt(len -1));
        int pivot = result;
        for(int i = len -2; i>= 0;i--){
            int curr = map.get(s.charAt(i));
            if(curr >=  pivot){
                result += curr;
            }else{
                result -= curr;
            }
            pivot = curr;
        }
        return result;
    }
}
/*Prefix string among all strings*/
public class Solution {
    public String longestCommonPrefix(String[] strs) {
      StringBuilder result = new StringBuilder();

        if (strs!= null && strs.length > 0){

            Arrays.sort(strs);

            char [] a = strs[0].toCharArray();
            char [] b = strs[strs.length-1].toCharArray();

            for (int i = 0; i < a.length; i ++){
                if (b.length > i && b[i] == a[i]){
                    result.append(b[i]);
                }
                else {
                    return result.toString();
                }
            
            }    
    }
        return result.toString();
    }
}
/*Remove Nth node from last in List / Linked List / LinkedList*/
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        if(head == null)
            return head ;
        ListNode result= new ListNode(0);
        result.next = head;
        
        ListNode fast = result;
        ListNode slow = result;
        for(int i=0 ; i<n ; i++)
        {
            if(fast==null)  
                return null;
            fast= fast.next;
        }
        while(fast.next!=null)
            {
                fast=fast.next;
                slow=slow.next;
            }
            slow.next = slow.next.next;
    
        return result.next;
    }
    
}
/*check for valid parenthesis */
public class Solution {
    public boolean isValid(String s) {
         if(s==null){ return true; }

    Stack<Character> s1=new Stack<Character>();
        char[] c = s.toCharArray();
        for(int i=0;i<c.length;i++){
            if(!s1.empty()){
                if((s1.peek()=='(' && c[i]==')' )||(s1.peek()=='{' && c[i]=='}' )||(s1.peek()=='[' && c[i]==']' ) )
                    s1.pop();
                else
                    s1.push(c[i]);
                    }else
                s1.push(c[i]);
        }
        return s1.empty();
        }
    }
/*Merge two sorted lists iteratively */
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1==null)
            return l2;
        if(l2==null)
            return l1;
        ListNode l3 = new ListNode(Integer.MIN_VALUE);
        ListNode result= l3;
       
        while(l1!=null && l2!=null)
        {
            if(l1.val>l2.val)
            {
                l3.next = new ListNode(l2.val);
                l2=l2.next;
                l3=l3.next;
            }
            else
            {
                l3.next = new ListNode(l1.val);
                l1 = l1.next;
                l3=l3.next;
            }
    }
    if(l1!=null)
    {
        while(l1!=null)
        {
            l3.next = new ListNode(l1.val);
            l1=l1.next;
            l3=l3.next;
        }
    }
    if(l2!=null)
    {
        while(l2!=null)
        {
            l3.next = new ListNode(l2.val);
            l2=l2.next;
            l3=l3.next;
        }
    }
    return result.next;
}
}
/*Merge two sorted lists recursively */
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1==null && l2==null) return null;
        else if(l1==null) return l2;
        else if(l2==null) return l1;
        
        if(l1.val<=l2.val){
            l1.next = mergeTwoLists(l1.next,l2);
            return l1;
        }
        else{
            l2.next = mergeTwoLists(l1,l2.next);
            return l2;
        }
    
    }
    
}

/*Remove duplicates from sorted array */
public class Solution {
    public int removeDuplicates(int[] nums) {
        int j = 0;
        for (int i = 0; i < nums.length; i++) {
            if (i > 0 && nums[i - 1] == nums[i]) 
                continue;
            nums[j] = nums[i];
            j++;
        }
        return j;
    }
}
/*remove all instances of that value in place and return the new length */
public class Solution {
    public int removeElement(int[] nums, int val) {
       int low=0;
       int high = nums.length-1;
       while(low<=high)
       {
           while(high>low && nums[high]==val)
           {
               high--;
           }
            if(nums[low]==val)
           {
               nums[low] = nums[high]; // replacing low value with the last because order can be changed
               high--;
           }
           low++;
       }
       return high+1;
    }
}
/*check if suduko sudoko is valid or not */
public class Solution {
    public boolean isValidSudoku(char[][] board) {
        HashSet[] row = new HashSet[9];
        HashSet[] column = new HashSet[9];
        HashSet[] ceil = new HashSet[9];
    
    for(int i=0; i<9; i++)
    {
        row[i] = new HashSet<Character>();
        column[i] = new HashSet<Character>();
        ceil[i] = new HashSet<Character>();
    }
    
    for(int i=0 ; i<9 ; i++)
    {
        for(int j=0 ; j<9; j++)
        {
            if(board[i][j]!='.'){
                if(row[i].contains(board[i][j]) || column[j].contains(board[i][j]) || ceil[3 *(i/3)+(j/3)].contains(board[i][j]))
                {
                    return false;
                }
                else
                {
                    row[i].add(board[i][j]);
                    column[j].add(board[i][j]);
                    ceil[3*(i/3)+(j/3)].add(board[i][j]);
                }
            }
        }
    }
return true;
        
    }
}
/*count and say iterative like 1, 11, 21, 1211Â */
public class Solution {
    public String countAndSay(int n) {
        String result = "1";
        for(int i=1; i<n; i++)
        {
            StringBuilder sb= new StringBuilder();
            int  j=0;
            while(j<result.length())
            {
                char temp = result.charAt(j);
                int count=0;
                while(j<result.length()&&result.charAt(j)==temp)
                {
                    j++;
                    count++;
                }
                sb.append(count);
                sb.append(temp);
            }
            result=sb.toString();
        }
        return result;
    }
}
/*count and say recursive like 1, 11, 21, 1211Â */
	public class Solution {
    public String countAndSay(int n) {
        return helper("1", n);
    }
     public String helper(String step, int count) {
        if(count <= 1) {
            return step;
        }

        // process step
        char currentChar = step.charAt(0);
        int currentCount = 0;
        StringBuilder result = new StringBuilder();
        for(char ch : step.toCharArray()) {
            if(ch != currentChar) {
                // hitting a different sequence
                // need to add to result
                result.append(currentCount).append(currentChar);

                currentChar = ch;
                currentCount = 1;
            } else {
                currentCount++;
            }
        }

        result.append(currentCount).append(currentChar);

        return helper(result.toString(), count-1);
    }

}
/* Length of last word in string / sentence*/
public class Solution {
    public int lengthOfLastWord(String s) {
 String str = s.trim();
     if (str==null) {
        return 0;
    } 
 String[] k = str.split(" ");
 return k[k.length-1].length();    
        
    }
}
/*plus one to the digit */
public class Solution {
    public int[] plusOne(int[] digits) {
        int n = digits.length;
    for(int i=n-1; i>=0; i--) {
        if(digits[i] < 9) {
            digits[i]++;
            return digits;
        }

        digits[i] = 0;
    }

    int[] newNumber = new int [n+1];
    newNumber[0] = 1;
return newNumber;
    }
}
/*Add binary numbers / sum of binary numbers */
public class Solution {
    public String addBinary(String a, String b) {
        int na = a.length()-1;
        int nb = b.length()-1;
        int sum=0 ;
        int carry =0;
        StringBuilder sb =new StringBuilder();
        while(na>=0 || nb>=0)
        {
            int x = na>=0 ? a.charAt(na) - '0' : 0;
            int y = nb>=0 ? b.charAt(nb) - '0' : 0;
            sum=x^y^carry;
            carry = x+y+carry>1 ? 1 : 0;
            sb.insert(0, sum);
            na--;
            nb--;
        }
        if(carry==1)
            sb.insert(0, 1);
        
        return sb.toString();
        
    }
    
}
/*climbing stairs in distinct ways */
public class Solution {
    public int climbStairs(int n) {
        if(n==0 || n==1 || n==2)
            return n;
        int sum=2, prev=1, current=0;
        for(int i=2;i<n;i++)
        {
            current=sum;
            sum=sum+prev;
            prev=current;
        }
        return sum;
    }
}
/* Remove duplicates from sorted list */
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode deleteDuplicates(ListNode head) {
     if(head==null)
        return head;
     ListNode current = head;   
     ListNode comingPointer;
     while(current.next!=null)
     {
         comingPointer = current.next;
         if(current.val==comingPointer.val)
         {
          current.next = comingPointer.next;
         }
         else
         {
             current=current.next;
         }
     }
     return head;
    }
}
/* check if trees are equal*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p==null && q==null)
            return true;
        if(p==null || q==null)
            return false;
        if(p.val!=q.val)
            return false;
        return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));
    }
}
/*check if tree is symmetric or not / mirror/ mirror image of tree*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root==null)
            return true;
        return (isSymSubtree(root.left, root.right));
        }
        
        public boolean isSymSubtree(TreeNode left, TreeNode right)
        {
            if(left==null)
                return (right==null);
            if(right==null)
                return false;
            return (left.val==right.val && isSymSubtree(left.left, right.right) && isSymSubtree(left.right, right.left));
        }
}
/* Tree level order traversal iterative*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<List<Integer>>();
    if(root==null) return result;
    ArrayList<TreeNode> level = new ArrayList<TreeNode>();
    level.add(root);

    while(!level.isEmpty()){
        ArrayList<Integer> values = new ArrayList<Integer>();
        for(int i=0; i<level.size(); i++){
            values.add(level.get(i).val);
        }
        result.add(values);
        ArrayList<TreeNode> nextlevel = new ArrayList<TreeNode>();
        for(int j=0 ;j<level.size(); j++){
            if(level.get(j).left!=null) nextlevel.add(level.get(j).left);
            if(level.get(j).right!=null) nextlevel.add(level.get(j).right);
        }
        level = nextlevel;
    }
    return result;
     }
}
/* Tree level order traversal recursive*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> list = new ArrayList<List<Integer>>();
        helper(root, list, 0);
        return list;

    }
    private void helper(TreeNode root,List<List<Integer>> list, int level){
        if(root==null) return;
        if(list.size()==level) list.add(new ArrayList<Integer>());
        list.get(level).add(root.val);
        helper(root.left, list, level+1);
        helper(root.right, list, level+1);

    }
}
/* Compare version numbers*/
public class Solution {
    public int compareVersion(String version1, String version2) {
     String [] v1 = version1.split("\\.");
     String [] v2 = version2.split("\\.");
     
     for(int i=0; i<Math.max(v1.length, v2.length); i++)
     {
         int n1 = i<v1.length ? Integer.parseInt(v1[i]) : 0;
         int n2 = i<v2.length ? Integer.parseInt(v2[i]) : 0;
         
         if(n1>n2)
            return 1;
        if(n2>n1)
            return -1;
     }
     return 0;
    }
}
/*Rotate an array*/
public class Solution {
    public void rotate(int[] nums, int k) {
        if(nums == null || nums.length < 2){
        return;
    }

    k = k % nums.length;
    reverse(nums, 0, nums.length - k - 1);
    reverse(nums, nums.length - k, nums.length - 1);
    reverse(nums, 0, nums.length - 1);

    }
    private void reverse(int[] nums, int i, int j){
    int tmp = 0;       
    while(i < j){
        tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
        i++;
        j--;
    }
}
    
}
/*Excel sheet column title*/
public class Solution {
    public String convertToTitle(int n) {
        StringBuilder sb = new StringBuilder();
        while(n!=0)
        {
            sb.insert(0, (char)('A'+(n-1)%26));
            n=(n-1)/26;
        }
        return sb.toString();
    }
}
/*first bad version*/
/* The isBadVersion API is defined in the parent class VersionControl.
      boolean isBadVersion(int version); */

public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
       
  int l = 1, r = n, mid;
        while (l <= r) {
            mid = l + (r-l) / 2;
            if (isBadVersion(mid))
                r = mid - 1;
            else
                l = mid + 1;
        }
        return l;
    }
}
/*Design a stack that supports push, pop, top, and retrieving the minimum element in constant time / Min Stack*/
class MinStack {
    Stack<Integer> mainStack = new Stack<Integer>();
        Stack<Integer> minStack = new Stack<Integer>();

        public void push(int x) {
            mainStack.push(x);
            if (minStack.empty()) {
                minStack.push(x);
            } else if (minStack.peek() >= x) {
                minStack.push(x);
            }
        }

        public void pop() {
            int poppedElement = mainStack.pop();
            if (poppedElement == minStack.peek()) {
                minStack.pop();
            }
        }

        public int top() {
            return mainStack.peek();
        }

        public int getMin() {
            return minStack.peek();
        }
}
/*Summary ranges*/
public class Solution {
    public List<String> summaryRanges(int[] nums) {
        StringBuffer sb = new StringBuffer();
        List<String> res= new ArrayList<String>();
        if(nums == null || nums.length==0)
            return res;
        if(nums.length==1)
        {
            sb.append(nums[0]);
            res.add(sb.toString());
            return res;
        }
        int p=0;
        for (int i = 1; i < nums.length; i++) 
        {
            if (nums[i] == nums[i - 1] + 1) 
            {
                if (i == nums.length - 1) 
                {
                    res.add(nums[p] + "->" + nums[i]);
                }
            } 
            else 
            { 
                if (i == p + 1) 
                {
                    res.add(nums[p] + "");
                } 
                else 
                {
                    res.add(nums[p] + "->" + nums[i - 1]);
                }
                if (i == nums.length - 1) 
                {
                    res.add(nums[i] + "");
                }
                p = i;
            }
        }
        return res;
    }
}
/*All paths in binary tree / binary tree paths*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        
        List<String> list = new ArrayList<String>();
        if(root!=null)
        {
            if(root.left==null && root.right==null)
            {
                list.add(root.val+"");
            }
            else
            {
                if(root.left!=null)
                {
                    list.addAll(binaryTreePaths(root.left));
                }
                if(root.right!=null)
                {
                    list.addAll(binaryTreePaths(root.right));
                }
                for(int i=0;i<list.size();i++)
                {
                    list.set(i, root.val + "->" +list.get(i));
                }
            }
        }
        return list;
    }
}
/*Remove a given element / value from a linked list */
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */

public class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode store = new ListNode(0);
        store.next = head;
        ListNode current = store;
        while(current.next!=null)
        {
            if(current.next.val == val)
                current.next = current.next.next;
            else
                current=current.next;
        }
        return store.next;
    }
}
/* count prime numbers / prime nos exclusive the given number*/
public class Solution {
    public int countPrimes(int n) {
     
     boolean [] m = new boolean[n];
     int count=0;
     for(int i=2; i<n ; i++)
     {
         if(m[i])
            continue;
        count++;
        for(int j=i ; j<n ; j+=i)
            m[j] = true;
     }
     return count; 
    }
}
/* Nim Game*/
public class Solution {
    public boolean canWinNim(int n) {
        return ((n%4)!=0);
    }
}
/* Maximum depth of binary tree / max depth of binary tree*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null)
            return 0;
        return (Math.max(maxDepth(root.left) + 1,maxDepth(root.right)+1));
    }   
}
/*Delete node in a linkedList / linked list */
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public void deleteNode(ListNode node) {
        node.val = node.next.val;
        node.next = node.next.next;
    }
}
/*Invert Binary Tree recursion */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root==null)
            return root;
            
        TreeNode temp = root.left;
        root.left = invertTree(root.right);
        root.right = invertTree(temp);
        
        return root;
    }
}
/*Invert Binary Tree iterative */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) return root;

    Queue q = new LinkedList<TreeNode>();
    q.add(root);

    while(!q.isEmpty()){
        TreeNode node = (TreeNode)q.remove();
        TreeNode tempRight = null, tempLeft = null;
        if(node.right != null){
            q.add(node.right);
            tempRight = node.right; 
        } 
        if(node.left != null){
            q.add(node.left);
            tempLeft = node.left;
        }
        node.left = tempRight;  
        node.right = tempLeft;
    }

    return root;
    }
}
/*Excel sheet column Number*/
public class Solution {
    public int titleToNumber(String s) {
         {
        int sum = 0;
        s = s.toUpperCase();
        for (int i = 0; i < s.length(); i++)
        {
            sum = 26 * sum + (s.charAt(i) - 'A'+1);
        }
        return sum;
    }
    }
}
/* Lowest common ancestors in Binary search tree */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null || p==root || q==root)
            return root;
        if((p.val<root.val && q.val>root.val) || (p.val>root.val && q.val<root.val))
            return root;
        else if(p.val<root.val && q.val<root.val)
            return lowestCommonAncestor(root.left, p, q);
        else
            return lowestCommonAncestor(root.right, p, q);
     
            
    }
}
/* check if two strings are anagram ( less optimize)*/
public class Solution {
    public boolean isAnagram(String s, String t) {
        if(s==null || t==null)
            return true;
        if(s.length()!=t.length())
            return false;
        char [] c1 = s.toCharArray();
        Arrays.sort(c1);
        char [] c2 = t.toCharArray();
        Arrays.sort(c2);
        
        String s1 = String.valueOf(c1);
        String s2 = String.valueOf(c2);
        
        if(s1.equals(s2))
            return true;
        else
            return false;
    }
}
/* check if two strings are anagram (more optimize using map)*/
public class Solution {
    public boolean isAnagram(String s, String t) {
        if(s.length() != t.length() ){
            return false;
        }

        if(s == null && t == null){
            return false;
        }

        if(s.equals(t)){
            return true;
        }

        Map<Character, Integer> map = new HashMap<Character, Integer>();

        for(char a : s.toCharArray()){
            map.put(a, map.getOrDefault(a, 0) + 1);
        }

        for(char b : t.toCharArray()){
            if(map.containsKey(b)){
                map.put(b, map.get(b) - 1);
                if(map.get(b) == 0){
                    map.remove(b);
                }
            }else{
                map.put(b, map.getOrDefault(b, 0) + 1);
            }
        }

        if(map.isEmpty()){
            return true;
        }else{
            return false;
        }
    }
}
/*Ugly Number */
public class Solution {
    public boolean isUgly(int num) {
        if(num<=0)
            return false;
        if(num==1)
            return true;
        while(num%5==0)
            num/=5;
        while(num%3==0)
             num/=3;
        while(num%2==0)
             num/=2;
            
        return (num==1);
    }
}
/*happy number */
public class Solution {
    public boolean isHappy(int n) {
        int result = 0;
        while (n > 9) {
            result += Math.pow(n % 10, 2);
            n = n / 10;
        }
        result += Math.pow(n, 2);
        if (result > 9) {return isHappy(result);}
        if (result == 1) {
            return true;
        } else {
            return false;
        }
    }
}
/* Minimum Depth of binary tree / min depth of binary tree */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int minDepth(TreeNode root) {
        if(root==null)
            return 0;
        if(root.left==null && root.right==null)
            return 1;
        if(root.right==null)
            return 1+minDepth(root.left);
        if(root.left==null)
            return 1+minDepth(root.right);
        return (Math.min(minDepth(root.left) , minDepth(root.right)))+1 ;
    }
}
/* Intersection of 2 linked lists*/
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        
        if(headA==null || headB==null)  //boundary check
            return null;
        ListNode a = headA;
        ListNode b = headB;
        
        //if a and b have different lengths, then we will stop the loop after the second iteration
        while(a!=b) 
        {
            //for the end of first iteration, we just reset the pointer to the head of another linkedlist
            a= a==null? headB : a.next;
            b= b==null? headA : b.next;
        }
    return a;
    }
}
/* Balanced Binary Tree*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean isBalanced(TreeNode root) {
        if(root==null || (root.left==null&&root.right==null))
            return true;
        return Math.abs(height(root.left)-height(root.right))<=1 && isBalanced(root.left) && isBalanced(root.right)? true : false;
    }
    public int height(TreeNode node)
    {
        if (node==null)
            return 0;
        return 1+Math.max(height(node.left), height(node.right));
    }
}
/* check if strings are isomorphic or not */
public class Solution {
    public boolean isIsomorphic(String s, String t) {
       
       if(s.length()!=t.length())
            return false;
       
       if(s.length()==0)
            return true;
            
        Map<Character, Integer> m1 = new HashMap<Character, Integer>();
        Map<Character, Integer> m2 = new HashMap<Character, Integer>();
        
        for(int i=0; i<s.length(); i++)
        {
            if(!m1.containsKey(s.charAt(i)))
                m1.put(s.charAt(i), i);
            if(!m2.containsKey(t.charAt(i)))
                m2.put(t.charAt(i), i);
                
            if(m1.size()!=m2.size())
                return false;
            else
                if(m1.get(s.charAt(i))!=m2.get(t.charAt(i)))
                    return false;
        }
        return true;
    }
}
/*check if the number is power of two / power of 2*/
public class Solution {
    public boolean isPowerOfTwo(int n) {
        if(n==1)
            return true;
        if(n%2 != 0)
            return false;
        int sum = 1;
        for(int i=0 ; i<n/2 ; i++)
        {
            if(sum>n)
                return false;
            if(sum==n)
                return true;
            sum *= 2;
        }
        if(sum == n)
            return true;
        return false;
    }
}
/* Level order traversal of binary tree in reverse order */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> list1 = new ArrayList<List<Integer>>();
        helper(root, list1, 0);
        Collections.reverse(list1);
        return list1;
        
        //List reversal can also be done like this.
        /*
        
        List<List<Integer>> list2 = new ArrayList<List<Integer>>();
        int n= list1.size();
        for(int i=0 ; i< n ;i++)
        {
           list2.add(list1.get(n-1-i));
        }
        */
    }
        private void helper(TreeNode root,List<List<Integer>> list, int level){
        if(root==null) return;
        if(list.size()==level) list.add(new ArrayList<Integer>());
        list.get(level).add(root.val);
        helper(root.left, list, level+1);
        helper(root.right, list, level+1);

    }

}
/* house  Robber*/
public class Solution {
    public int rob(int[] num) {
       if(num.length==0)
        return 0;
        if(num.length==1)
            return num[0];
        num[1] = Math.max(num[0], num[1]);
        for(int i=2 ; i<num.length; i++)
            num[i] = Math.max(num[i]+num[i-2], num[i-1]);
        return num[num.length-1];
    }
}
/* Check if sum of node of path in binary tree equals a given number / All paths in Binary tree*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if(root==null)
            return false;
        if(root.left==null && root.right==null)
            return root.val==sum;
        int subSum = sum - root.val;
        return (hasPathSum(root.left, subSum) ||  hasPathSum(root.right, subSum));
        
    }
}
/*Trailing zeros in factorial of a number */
public class Solution {
    public int trailingZeroes(int n) {
        int count=0;
        while(n>1)
        {
            count = count+ (n/5);
            n=n/5;
        }
        return count;
    }
}
/*Rectangle Area Â two rectangles are combined to find the total area*/
public class Solution {
    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {
         int space = 0;
         int space1 = (Math.abs(A-C)*Math.abs(B-D));
         int space2 = (Math.abs(E-G)*Math.abs(F-H));
         
         int left = Math.max(A,E);
         int top = Math.min(D,H);
         int right  = Math.min(C,G);
         int bottom = Math.max(B,F);
         if(top>=bottom && right>=left){
             space = (Math.abs(bottom-top) * Math.abs(left-right));
         }
         return space1+space2-space;
    }
}
/* Reverse a linked list iterative*/
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode reverseList(ListNode head) {
         ListNode prev = null;
    while (head != null) {
        ListNode temp = head.next;
        head.next = prev;
        prev = head;
        head = temp;
    }
    return prev;
    }
}
/* Reverse a linked list iterative recursive*/
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode reverseList(ListNode head) {
       if(head == null ||head.next == null){
            return head;
        }

        ListNode root = reverseList(head.next);

        head.next.next = head;
        head.next = null;
        return root;
    }
}
/* check if linked list is palindrome or not iterative*/
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null)
            return true;
        ListNode fast = head, slow = head, prev = null;
        while (fast != null && fast.next != null) {
            prev = slow;
            slow = slow.next;
            fast = fast.next.next;
    }
        prev.next = null;
        slow = reverseList(slow);
        while (head != null && slow != null) {
            if (head.val != slow.val)
                return false;
            head = head.next;
            slow = slow.next;
    }
    return true;
}
    public ListNode reverseList(ListNode head) {
    ListNode prev = null;
    while (head != null) {
        ListNode temp = head.next;
        head.next = prev;
        prev = head;
        head = temp;
    }
    return prev;
    }
}
/* check if  linked list is palindrome or not recursive */
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    ListNode h;
    public boolean isPalindrome(ListNode head) {
        if (head == null) 
            return true;

        if (h == null) 
            h = head;

        boolean tmp = true;        
        if (head.next != null) 
            tmp &= isPalindrome(head.next);

        tmp &= (head.val == h.val);
        h = h.next;
        return tmp;
    }
}
/*Merge N sorted arrays / n-sorted array*/
public int[] mergeNArrays(int[][] arrays, int n)
{
    int result[];
    for(int i=0; i<n ; i++)
    {
       result[] = Merge(result, arrays[i]);
    }
    
    return result;
}
/*find the single number in the array with all numbers two times except one*/
public class Solution {
    public int singleNumber(int[] nums) {
        int n = 0;
        for(int i= 0 ; i<nums.length ; i++)
        {
            n = n ^ nums[i];
        }
        return n;
    }
}
/*Best time to buy and sell stocks with single transaction */
public class Solution {
    public int maxProfit(int[] prices) {
        int max = 0;
        int min = Integer.MAX_VALUE;
        for(int i =0 ; i< prices.length; i++)
        {
            min = Math.min(min, prices[i]);
            max = Math.max(max, prices[i]-min);
        }
    
        return max;
    }
}
/* Best time to buy and sell stock with multiple transactions*/
public class Solution {
    public int maxProfit(int[] prices) {
        int profit = 0;
        for(int i=1; i<prices.length; i++)
        {
            if(prices[i]-prices[i-1]<=0)
                continue;
            profit += prices[i] - prices[i-1];
        }
        return profit;
    }
}
/* find the single number in the array with all numbers three times except one */
public class Solution {
    public int singleNumber(int[] nums) {
        if(nums==null || nums.length==0)
            return 0;
        HashMap <Integer, Integer> hm = new HashMap<Integer, Integer>();
        for(int i= 0; i <nums.length ; i++)
            hm.put(nums[i], hm.getOrDefault(nums[i], 0)+1);
        for(Map.Entry<Integer, Integer> en : hm.entrySet())
        {
            if(en.getValue()!=3)
                return en.getKey();
        }
        return -1;
    }
}
/* find the single number / two numbers in the array with all numbers two times except two elements which occur one time */
public class Solution {
    public int[] singleNumber(int[] nums) {
        Set<Integer> set = new HashSet<Integer>();
    for(int i:nums){
         if(set.add(i)==false)
         set.remove(i);
    }
    int a[]= new int [set.size()];
    int c=0;
    for(int b:set){
        a[c]=b;
        c++;
    }
    return a;
        
    }
}
/*Product of array except itself */
public class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length; 
        int[] output = new int[n];
        int temp = 1;
        output[0] = 1;
        for(int i = 1; i<n ; i++)
        {
            output[i] = output[i-1] * nums[i-1];
        }
        for(int i=n-1 ; i>=0; i--)
        {
            output[i]= temp*output[i];
            temp = temp*nums[i];
            
        }
        return output;  
    }
}
/*check if linked list / linkedlist has a cycle */
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head==null)
            return false;
        ListNode fast = head;
        ListNode slow = head;
        while((fast!= null && fast.next!=null))
        {
            fast = fast.next.next;
            slow= slow.next;
            if(fast==slow)
                break;
        }
        if(fast== null || fast.next==null)
            return false;
        else
            return true;
    }
}
/*find the missing value in the array of integers */
public class Solution {
    public int missingNumber(int[] nums) {
        
        int n = nums.length;
        int expectedOutput = (n*(n+1))/2;
        
        for(int i=0;i<n;i++)
        {
            expectedOutput-=nums[i];
        }
        return expectedOutput;
        
    }
}
/*Populating Next Right Pointers in each node of Binary search tree / left node should make an arrow towards right node */
/**
 * Definition for binary tree with next pointer.
 * public class TreeLinkNode {
 *     int val;
 *     TreeLinkNode left, right, next;
 *     TreeLinkNode(int x) { val = x; }
 * }
 */
public class Solution {
    public void connect(TreeLinkNode root) {
        if(root==null)
        {
            return;
        }
        if(root.left!=null)
        {
            root.left.next = root.right;
            if(root.next!=null)
                root.right.next = root.next.left;
        }
        if(root.left!=null)
            connect(root.left);
        if(root.right!=null)
            connect(root.right);
    }
} 
/* Search insert position of a target value in a sorted array, if already present, return its index */
public class Solution {
    public int searchInsert(int[] nums, int target) {
        for(int i=0; i<nums.length ; i++)
        {
            if(nums[i]>=target)
                return i;
        }
        return nums.length;
    }
}
/* Integer to roman less optimized solution iteratively without using enum*/
int [] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
        String [] str = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};
        
        StringBuilder sb = new StringBuilder();
        for(int i=0; i<values.length; i++)
        {
            while(num>=values[i])
            {
                num-= values[i];
                sb.append(str[i]);
            }
        }
        return sb.toString();
/* Integer to roman less optimized solution iteratively using enum*/
public class Solution {
    
    public enum Type{
    M(1000),CM(900),D(500),CD(400),C(100),XC(90),L(50),XL(40),X(10),IX(9),V(5),IV(4),I(1);
    private final int value;
    Type(int value) {
        this.value = value;
    }
};
    
    public String intToRoman(int num) {
      
          StringBuilder output = new StringBuilder();
    for (Type t:Type.values()) {
        while (num>=t.value) {
            output.append(t);
            num -= t.value;
        }
    }
    return output.toString();
    }
    
}
/* Integer to roman more optimized solution recursively */
public class Solution {
    public String intToRoman(int num) {
       if (num>=1000) {
            return ("M"+intToRoman(num-1000));
        } else if (num>=900) {
            return ("CM"+intToRoman(num-900));
        } else if (num>=500) {
            return ("D"+intToRoman(num-500));
        } else if (num>=400) {
            return ("CD"+intToRoman(num-400));
        } else if (num>=100) {
            return ("C"+intToRoman(num-100));
        } else if (num>=90) {
            return ("XC"+intToRoman(num-90));
        } else if (num>=50) {
            return ("L"+intToRoman(num-50));
        } else if (num>=40) {
            return ("XL"+intToRoman(num-40));
        } else if (num>=10) {
            return ("X"+intToRoman(num-10));
        } else if (num>=9) {
            return ("IX"+intToRoman(num-9));
        } else if (num>=5) {
            return ("V"+intToRoman(num-5));
        } else if (num>=4) {
            return ("IV"+intToRoman(num-4));
        } else if (num>=1) {
            return ("I"+intToRoman(num-1));
        }
        return ("");
    }
}
/* Maximum subarray / Maximum sub array/ Maximum sub-array/ sum of sub array which has maximum sum*/
public class Solution {
    public int maxSubArray(int[] nums) {
        int max = nums[0];
        int [] arr = new int[nums.length];
        arr[0] = nums[0];
        for(int i=1 ; i<nums.length; i++)
        {
            arr[i] = Math.max(nums[i], nums[i]+arr[i-1]);
            max= Math.max(max, arr[i]);
        }
        return max;
    }
}
/*Convert a sorted array to binary search tree / convert a sorted array to BST recursive*
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        if(nums == null || nums.length==0)
            return null;
            
        return getTreeNode(nums, 0 , nums.length-1);
    }
    private TreeNode getTreeNode(int [] nums, int start, int end )
    {
        if(start>end)
            return null;
        int middle = start + (end-start)/2 ;
        TreeNode n = new TreeNode(nums[middle]);
        n.left = getTreeNode(nums, start, middle-1);
        n.right = getTreeNode(nums, middle+1, end);
    
        return n;
    }
}
/* Convert a sorted array to binary search tree / convert a sorted array to BST iterative */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        int len = nums.length;
        if ( len == 0 ) { return null; }

        // 0 as a placeholder
        TreeNode head = new TreeNode(0); 

        Deque<TreeNode> nodeStack       = new LinkedList<TreeNode>() {{ push(head);  }};
        Deque<Integer>  leftIndexStack  = new LinkedList<Integer>()  {{ push(0);     }};
        Deque<Integer>  rightIndexStack = new LinkedList<Integer>()  {{ push(len-1); }};

        while ( !nodeStack.isEmpty() ) {
            TreeNode currNode = nodeStack.pop();
            int left  = leftIndexStack.pop();
            int right = rightIndexStack.pop();
            int mid   = left + (right-left)/2; // avoid overflow
            currNode.val = nums[mid];
            if ( left <= mid-1 ) {
                currNode.left = new TreeNode(0);  
                nodeStack.push(currNode.left);
                leftIndexStack.push(left);
                rightIndexStack.push(mid-1);
            }
            if ( mid+1 <= right ) {
                currNode.right = new TreeNode(0);
                nodeStack.push(currNode.right);
                leftIndexStack.push(mid+1);
                rightIndexStack.push(right);
            }
        }
        return head;    
    }
}
/* Find minimum in a rotated sorted array */
public class Solution {
    public int findMin(int[] nums) {
         int l = 0, r = nums.length-1;
     while (l < r) {
         int mid = (l + r) / 2;
         if (nums[mid] < nums[r]) {
            //right side in order, and mid is smallest of right side,
            // min should be mid or in left.
             r = mid;   
         } else {
            //left side in order and it is the larger part,
            // min should be in right side.
             l = mid + 1; 
         }
     }
     return nums[l];
    }
}
/* Generate Parenthesis / generate all combination of parenthesis*/
public class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> li = new ArrayList<String>();
        if(n<0)
            return li;
        generate("", li, n, n);
        return li;
    }
    public void generate(String s, List<String> list, int left, int right)
    {
        if(left>right)
            return;
        if(left>0)
            generate(s+"(", list, left-1, right);
        if(right>0)
            generate(s+")", list, left , right-1);
        if(left==0&&right==0)
        {
            list.add(s);
            return;
        }
    }
}
/* sort colors / dutch flag problem / sort 0 1 2*/
public class Solution {
    public void sortColors(int[] nums) {
        int r = 0;
        int w = 0 ;
        int b = 0;
        for(int i : nums){
            if(i==0)
                r++;
            if(i==1)
                w++;
            if(i==2)
                b++;
        }
        int i=0;
        while(r>0)
        {
            nums[i++] = 0;
                r--;
        }
        while(w>0)
        {
            nums[i++] = 1;
                w--;
        }
        while(b>0)
        {
            nums[i++] = 2;
                b--;
        }
    }
}
/* Swap nodes in pairs in linked list.*/
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head==null || head.next==null)
            return head;
        ListNode current = head;
        ListNode next;
        ListNode result = new ListNode(-1);
        ListNode prev = result;
        while(current!=null && current.next!=null)
        {
            next = current.next;
            prev.next = next;
            current.next = next.next;
            next.next = current;
            prev = current;
            current = current.next;
        }
        return result.next;
    }
}
/* Find permutations of collection of numbers [Iterative]*/
public class Solution {
public List<List<Integer>> permute(int[] num) {
    LinkedList<List<Integer>> res = new LinkedList<List<Integer>>();
    res.add(new ArrayList<Integer>());
    for (int n : num) {
        int size = res.size();
        for (; size > 0; size--) {
            List<Integer> r = res.pollFirst();
            for (int i = 0; i <= r.size(); i++) {
                List<Integer> t = new ArrayList<Integer>(r);
                t.add(i, n);
                res.add(t);
            }
        }
    }
    return res;
}
}
/* Find permutations of collection of numbers [first solution]*/
public class Solution {
    public List<List<Integer>> permute(int[] nums) {
         List<List<Integer>> result = new ArrayList<List<Integer>>();
        permute(result, nums, 0);
        return result;
    }
     private void permute(List<List<Integer>> result, int[] array, int start) {
        if (start >= array.length) {
            List<Integer> current = new ArrayList<Integer>();
            for (int a : array) {
                current.add(a);
            }
            result.add(current);
        } else {
            for (int i=start; i<array.length; i++) {
                swap(array, start, i);
                permute(result, array, start+1);
                swap(array, start, i);
            }
        }
    }
     private void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}
/* Find permutations of collection of numbers [second solution]*/
public class Solution {
    public List<List<Integer>> permute(int[] nums) {
        
        List<List<Integer>> permutations = new ArrayList<>();
        if(nums.length==0)
            return permutations;
        
        generate(nums, 0 , new ArrayList<>(), permutations);
        return permutations;
        
    }
        public void generate(int[] nums, int start, List<Integer> permutation, List<List<Integer>> permutations)
        {
            if(permutation.size()==nums.length){
                permutations.add(permutation);
                return;
            }
            for(int i=0 ;i<=permutation.size();i++)
            {
                List<Integer> newPermutation = new ArrayList<>(permutation);
                newPermutation.add(i, nums[start]);
                generate(nums, start+1, newPermutation, permutations);
            }
        }
}
/* Kth smallest element in BST recursive*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    
    public int kthSmallest(TreeNode root, int k) {
      ArrayList<Integer>buffer = new ArrayList<Integer>();
      inOrderSearch(root, buffer, k);
      return buffer.get(k-1);
    }
    public void inOrderSearch(TreeNode node, ArrayList<Integer> buffer, int k)
    {
        if(buffer.size()>k)
            return;
        if(node.left!=null)
        {
            inOrderSearch(node.left, buffer, k);
        }
        buffer.add(node.val);
        if(node.right!=null)
        {
            inOrderSearch(node.right, buffer, k);
        }
    }
}
/* Kth smallest element in BST iterative*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    
    public int kthSmallest(TreeNode root, int k) {
      Stack<TreeNode> stack=new Stack<TreeNode>();
        int c=0;
        TreeNode cur=root;
        while(cur!=null){
            stack.push(cur);
            cur=cur.left;
        }
        while(!stack.isEmpty()){
            TreeNode ptr=stack.pop();
            c++;
            if(c==k)return ptr.val;
            TreeNode rt=ptr.right;
            while(rt!=null){
                stack.push(rt);
                rt=rt.left;
            }
        }
        return 0;
    }
}
/* zig-zag / zig zag traversal of BST using recursion*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
       List<List<Integer>> res = new ArrayList<List<Integer>>();
        dfs(res, root, 0);
        return res; 
       }
        private void dfs(List<List<Integer>> res, TreeNode root, int level){
        if (root == null) return;
        if (level >= res.size()){
            res.add(new LinkedList<Integer>());
        }
        LinkedList<Integer> list = (LinkedList<Integer>) res.get(level);
        if (level % 2 == 0){
            list.add(root.val);
        } else {
            list.addFirst(root.val);
        }
        dfs(res, root.left, level + 1);
        dfs(res, root.right, level + 1);
    }
}
/* Sum of root to leaf numbers in a binary search tree*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int sumNumbers(TreeNode root) {
        if(root==null)
            return 0;
        if(root.left==null && root.right==null)
            return root.val;
        List<Integer> li = new ArrayList<Integer>();
        StringBuilder sb = new StringBuilder();
        binaryTree(root, sb, li);
        int sum=0;
        for(int i: li)
            sum=sum+i;
        return sum;
    }
    public void binaryTree(TreeNode root, StringBuilder sb, List<Integer> li)
    {
        if(root==null)
            return;
        StringBuilder result = new StringBuilder(sb);
        result.append(root.val);
        if(root.left==null && root.right==null)
        {
            li.add(Integer.parseInt(result.toString()));
        }
        binaryTree(root.left, result , li);
        binaryTree(root.right, result , li);
    }
}
/* Construct binary tree from inorder and postorder traversal */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
     if(inorder.length==0)
        return null;
     
     int head = postorder[postorder.length-1];
     TreeNode root = new TreeNode(head);
     int i = findIndex(inorder, head);
     int[] inleft = Arrays.copyOfRange(inorder, 0, i);
     int[] postleft = Arrays.copyOfRange(postorder, 0, i);
     int[] inright = Arrays.copyOfRange(inorder, i+1, inorder.length);
     int[] postright = Arrays.copyOfRange(postorder, i, inorder.length-1);
     
     root.left = buildTree(inleft, postleft);
     root.right = buildTree(inright, postright);
    return root;
        
    }
    public static int findIndex(int[] a, int d)
    {
        for(int i= 0 ; i<a.length; i++)
        {
            if(a[i]==d)
                return i;
        }
        return -1;
    }
}
/*Construct binary tree from preorder and inorder traversal */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
         if(inorder.length==0)
        return null;
     
     int head = preorder[0];
     TreeNode root = new TreeNode(head);
     int i = findIndex(inorder, head);
     int[] inleft = Arrays.copyOfRange(inorder, 0, i);
     int[] inright = Arrays.copyOfRange(inorder, i+1, inorder.length);
     
     int[] preleft = Arrays.copyOfRange(preorder, 1, i+1);
     int[] preright = Arrays.copyOfRange(preorder, i+1, inorder.length);
     
     root.left = buildTree(preleft, inleft);
     root.right = buildTree(preright, inright);
    return root;
        
    }
    public static int findIndex(int[] a, int d)
    {
        for(int i= 0 ; i<a.length; i++)
        {
            if(a[i]==d)
                return i;
        }
        return -1;
    }
}
/*count number of nodes in a complete binary tree (Time limit exceeded) / not a good solution*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int countNodes(TreeNode root) {
        if(root==null)
            return 0;
        return 1+countNodes(root.left) + countNodes(root.right);
    }
}
/* count the number of nodes in a complete binary tree / optimal solution */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int countNodes(TreeNode root) {
        if(root==null)
            return 0;
        int leftDepth = getDepth(root,'l');
        int rightDepth = getDepth(root,'r');
        
        if(leftDepth==rightDepth)
            return (1<<leftDepth)-1;
        else
            return 1+countNodes(root.left)+countNodes(root.right);
    }
    public int getDepth(TreeNode node, char d)
    {
        int depth =0;
        while(node!=null)
        {
            if(d == 'l')
                 node=node.left;
            else
                node=node.right;
            depth++;
            
        }
        return depth;
    }
}
/* Check if the given tree is a binary search tree / Validate Binary search Tree / Validate BST (Bad solution) / (Wrong solution)*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean isValidBST(TreeNode root) {
        if(root==null)
            return true;
          return isValidateBST(root.left)&&isValidateBST(root.right); 
    }
}
/* Check if the given tree is a binary search tree / Validate Binary search Tree / Validate BST (correct solution) / (perfect solution) */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean isValidBST(TreeNode root) {
        if(root==null)
            return true;
            
        return checkBST(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }

    public boolean checkBST(TreeNode root, long min, long max)
    {
        if(root==null)
            return true;
        if(root.val<=min || root.val>=max)
            return false;
        return checkBST(root.left, min, root.val)&&checkBST(root.right, root.val, max);
    }
}
/* Right side view of the tree iterative*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> result = new LinkedList<Integer>();
        if(root==null)
            return result;
        List<TreeNode> candidate = new LinkedList<TreeNode>();
        candidate.add(root);
        while(!candidate.isEmpty())
        {
            List<TreeNode> temp = new LinkedList<TreeNode>();
            result.add(candidate.get(0).val);
            for(TreeNode n : candidate)
            {
                if(n.right!=null)
                    temp.add(n.right);
                if(n.left!=null)
                    temp.add(n.left);
            }
            candidate = temp;
        }
        return result;
    }
}
/* Right side view of the tree recursive */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        ArrayList list = new ArrayList();
        rightSideView(root, 0, list);

        return list;
    }
    public void rightSideView(TreeNode root, int level, ArrayList list) {
        if(root == null) return;

        if(list.size() == level)
            list.add(root.val);

        rightSideView(root.right, level + 1, list);
        rightSideView(root.left, level + 1, list);
    }
}
/* Lowest common ancestor in a binary tree */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null || root == p || root==q)
            return root;
        TreeNode left = lowestCommonAncestor(root.left, p , q);
        TreeNode right = lowestCommonAncestor(root.right, p , q);
        
        if(left!=null && right!=null)
            return root;
        
        return left!=null ? left : right;
    }
}

/*Closest Binary Search Tree/BST value*/
public class Solution{
	public int closestValue(TreeNode root, double target){
		int a = root.val;
		TreeNode kid = target < a ? root.left : root.right;
		if(kid==null) return a;
		int b = closestValue(kid,target);
		return Math.abs(a-target) < Math.abs(b-target) ? a:b;
	}
}

/*Cows and Bulls problem
The idea is to iterate over the numbers in secret and in guess and count all bulls right away. For cows maintain an array that stores count of the number appearances in secret and in guess. Increment cows when either number from secret was already seen in guest or vice versa.
*/
public class Solution {
    public String getHint(String secret, String guess) {
        int bulls = 0;
    int cows = 0;
    int[] numbers = new int[10];
    for (int i = 0; i<secret.length(); i++) {
        int s = Character.getNumericValue(secret.charAt(i));
        int g = Character.getNumericValue(guess.charAt(i));
        if (s == g) bulls++;
        else {
            if (numbers[s] < 0) cows++;
            if (numbers[g] > 0) cows++;
            numbers[s] ++;
            numbers[g] --;
        }
    }
    return bulls + "A" + cows + "B";
    }
}
/* Integer to English words / numbers to words*/
public class Solution {
    public String numberToWords(int num) {
         if (num == 0) return "Zero";
    String[] big= {"", "Thousand", "Million", "Billion"};
    String[] small = {"Ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"};
    String[] tens = {"Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"};
    String[] ones = {"", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"};
    StringBuilder res = new StringBuilder();
    int count = 0;
    while (num != 0) {
        int cur = num % 1000;
        int o = cur % 10, t = (cur / 10) % 10, h = cur / 100;
        StringBuilder tmp = new StringBuilder();
        if (h != 0) tmp.append(ones[h] + " Hundred ");
        if (t == 1) tmp.append(small[o] + " ");
        else {
            if (t > 1) tmp.append(tens[t-2] + " ");
            if (o > 0) tmp.append(ones[o] + " ");
        }
        if(tmp.length() != 0) tmp.append(big[count] + " ");
        res.insert(0, tmp);
        num /= 1000;
        count++;
    }
    return res.toString().trim();
    }
}
/*N-queen Problem */
public class Solution {
    public List<List<String>> solveNQueens(int n) {
        List<List<String>> ans = new ArrayList<>();
    char[][] board = new char[n][n];
    for (int i = 0; i < n; i++)
        Arrays.fill(board[i], '.');
    solve(board, n, 0, ans);
    return ans;
    }
    private void solve(char[][] board, int n, int row, List<List<String>> ans) {
    if (row == n) {
        List<String> li = new ArrayList<String>();
        for (char[] rowChars : board) {
            li.add(new String(rowChars));
        }
        ans.add(li);
        return;
    }
    for (int col = 0; col < n; col++) {
        if (board[row][col] == '.' && isValid(board, n, row, col)) {
            board[row][col] = 'Q';
            solve(board, n,  row + 1, ans);
            board[row][col] = '.';

        }
    }
}
private boolean isValid(char[][] board, int n, int i, int j) {
    for (int row = 0; row < n; row++)
        if (board[row][j] == 'Q')
            return false;
    for (int col = 0; col < n; col++)
        if (board[i][col] == 'Q')
            return false;

    // check diagonal.
    int row = i, col = j;
    while (row >= 0 && col >= 0) {
        if (board[row--][col--] == 'Q')
            return false;
    }
    row = i;
    col = j;
    while (row < n && col < n) {
        if (board[row++][col++] == 'Q')
            return false;
    }

    // check other diagonal.
    row = i;
    col = j;
    while (row >= 0 && col < n) {
        if (board[row--][col++] == 'Q')
            return false;
    }
    row = i;
    col = j;
    while (row < n && col >= 0) {
        if (board[row++][col--] == 'Q')
            return false;
    }

    return true;
}
}
/*Number of solution possible in N-Queen Problem using DFS*/
public class Solution {
    HashSet<Integer> cols = new HashSet<Integer>();  // Used columns
HashSet<Integer> diag1 = new HashSet<Integer>(); // 45° diagonal
HashSet<Integer> diag2 = new HashSet<Integer>(); // 135° diagonal 
    public int totalNQueens(int n) {
         return DFS(0, 0, n);
    }
    int DFS(int row, int count, int n) {
    if (row == n) 
        return count + 1;

    for (int col = 0; col < n; col++) {
        if (cols.contains(col) || diag1.contains(row - col) || diag2.contains(row + col)) 
            continue;
        cols.add(col);
        diag1.add(row - col); 
        diag2.add(row + col);
        count = DFS(row + 1, count, n);
        cols.remove(col); 
        diag1.remove(row - col); 
        diag2.remove(row + col);
    }
    return count;
}
}
/* Kth largest element in an unsorted array O(N LogN)*/
public class Solution {
    public int findKthLargest(int[] nums, int k) {
        Arrays.sort(nums);
        return nums[nums.length-k];
    }
}
/* Kth largest element in an unsorted array O(N LogK) (Min Heap)*/
public class Solution {
    public int findKthLargest(int[] nums, int k) {
        PriorityQueue<Integer> largeK = new PriorityQueue<Integer>(k + 1);

                for(int el : nums) {
                    largeK.add(el);
                    if (largeK.size() > k) {
                        largeK.poll();
                    }
                }

                return largeK.poll();
    }
}
/* Kth largest element in an unsorted array O(N) (Quick SORT)
It is a bit like quick sort.
First we randomly select a pivot, do as what quick sort does to get the index of the pivot.
If index == k - 1, which means we've got the kth element;
If index < k - 1, the kth element is to the right of the index, we need to search from index to right.
If index > k - 1, the kth element is to the left of the index, we need to search from left to index.
*/
public class Solution {
    public int findKthLargest(int[] nums, int k) {
       return quickSelect(nums, k - 1, 0, nums.length - 1);
       
    }
    private int quickSelect(int[] arr, int k, int left, int right){
    int pivot = arr[(left + right) / 2];
    int orgL = left, orgR = right;
    while(left <= right){
        while(arr[left] > pivot){
            left ++;
        }
        while(arr[right] < pivot){
            right --;
        }

        if(left <= right){
            swap(arr, left, right);
            left ++;
            right --;
        }
    }

    if(orgL < right && k <= right) return quickSelect(arr, k, orgL, right);
    if(left < orgR && k >= left) return quickSelect(arr, k, left, orgR);
    return arr[k];

}

private void swap(int[] arr, int idx1, int idx2){
    int tmp = arr[idx1] + arr[idx2];
    arr[idx1] = tmp - arr[idx1];
    arr[idx2] = tmp - arr[idx2];

}
}
/* Multiply two strings / multiply 2 strings*/
public class Solution {
    public String multiply(String num1, String num2) {
       int n1 = num1.length(), n2 = num2.length();
        int[] products = new int[n1 + n2];
        for (int i = n1 - 1; i >= 0; i--) {
            for (int j = n2 - 1; j >= 0; j--) {
                int d1 = num1.charAt(i) - '0';
                int d2 = num2.charAt(j) - '0';
                products[i + j + 1] += d1 * d2;
            }
        }
        int carry = 0;
        for (int i = products.length - 1; i >= 0; i--) {
            int tmp = (products[i] + carry) % 10;
            carry = (products[i] + carry) / 10;
            products[i] = tmp;
        }
        StringBuilder sb = new StringBuilder();
        for (int num : products) sb.append(num);
        while (sb.length() != 0 && sb.charAt(0) == '0') sb.deleteCharAt(0);
        return sb.length() == 0 ? "0" : sb.toString();
        
    }
}
/* Longest Palindromic Substring / Longest palindrome in a string*/
public class Solution {
    public String longestPalindrome(String s) {
         String res = "";
        int currLength = 0;
        for(int i=0;i<s.length();i++){
            if(isPalindrome(s,i-currLength-1,i)){
                res = s.substring(i-currLength-1,i+1);
                currLength = currLength+2;
            }
            else if(isPalindrome(s,i-currLength,i)){
                res = s.substring(i-currLength,i+1);
                currLength = currLength+1;
            }
        }
        return res;
    }
      public boolean isPalindrome(String s, int begin, int end){
        if(begin<0) return false;
        while(begin<end){
            if(s.charAt(begin++)!=s.charAt(end--)) return false;
        }
        return true;
    }
}
/*Perfect Squares / find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n*/
/*Time Complexity: n * sqrt(n) */
/*Space Complexity: n  */
public class Solution {
    public int numSquares(int n) {
        int dp[] = new int[n+1];
        int nearest;
        for(int i=1 ;i <=n ; i++)
        {
            nearest = (int)Math.sqrt(i);
            int min = dp[i-1];
            for(int j=nearest ; j>0 ; j--)
            {
                if(dp[i-j*j]<min)
                min = dp[i-j*j];
            }
            dp[i] = min+1;
        }
        return dp[n];
    }
}
/* Shortest palindrome / Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation ITERATIVE*/
public class Solution {
    public String shortestPalindrome(String s) {
        int n = s.length();
    if(n<=1){
        return s;
    }
    int idx = 0;
    for(int center = n/2; center>=0; center--){
        if(valid(s, center, 1)){   //is the longest valid palindrome? (assume length is even)
            idx = 2*center+1;
            break;
        }
        if(valid(s, center, 0)){  //assume length is odd
            idx = 2*center;
            break;
        }

    }
    String suffix = s.substring(idx+1);
    StringBuilder b = new StringBuilder(suffix);
    return b.reverse().toString()+s;
    }
    
    boolean valid(String s, int center, int shift){
    int i = center, j = center+shift;
    while(i>=0 && j<s.length()){
        if(s.charAt(i)!=s.charAt(j)){
            break;
        }
        i--;
        j++;
    }
    return i<0;
}
    
}
/* /* Shortest palindrome / Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation RECURSIVE 


The idea is to use two anchors j and i to compare the String from beginning and end. If jcan reach the end, the String itself is Palindrome. Otherwise, we divide the String by j, and getmid = s.substring(0, j) and suffix.
We reverse suffix as beginning of result and recursively call shortestPalindrome to get result of mid then appedn suffix to get result

*/
public class Solution {
    public String shortestPalindrome(String s) {
       int j = 0;
    for (int i = s.length() - 1; i >= 0; i--) {
        if (s.charAt(i) == s.charAt(j)) { j += 1; }
    }
    if (j == s.length()) { return s; }
    String suffix = s.substring(j);
    return new StringBuffer(suffix).reverse().toString() + shortestPalindrome(s.substring(0, j)) + suffix;
}
    
}
/* Largest Number / Given a list of non negative integers, arrange them such that they form the largest number / For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330 */
public class Solution {
    public String largestNumber(int[] nums) {
          if(nums.length==0)
                return new String();
                
            //Convert to string array.
            List<String> t = new ArrayList<String>();
            int count = 0;
            for(int i=0; i<nums.length;i++){
                if(nums[i]==0)
                    count++;
                t.add(Integer.toString(nums[i]));
            }
            if(count==nums.length)
                return Integer.toString(0);

             //sort based on the criterion whichever generates a bigger number in descending order.
            Collections.sort(t, new Comparator<String>(){
                @Override
                public int compare(String s1, String s2){
                    String front = s1+s2;
                    String end = s2+s1;
                    return front.compareTo(end)*(-1);

                }
            });

            //output the result.
            StringBuilder sb = new StringBuilder();
            for(String s : t)
                sb.append(s);
            return sb.toString();

    }
}
/*Combination Sum	/ Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. 
The same repeated number may be chosen from C unlimited number of times. RECURSIVE
 */
public class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        
        return combinationSum(candidates, target, 0);   
    }
     public List<List<Integer>> combinationSum(int[] candidates, int target, int start) {

        List<List<Integer>> res = new ArrayList<List<Integer>>();
        Arrays.sort(candidates);
        for (int i = start; i < candidates.length; i++) {
            if (candidates[i] <target) {
                for (List<Integer> ar : combinationSum(candidates, target - candidates[i], i)) {
                    ar.add(0, candidates[i]);
                    res.add(ar);
                }
            } else if (candidates[i] == target) {
                List<Integer> lst = new ArrayList<>();
                lst.add(candidates[i]);
                res.add(lst);
            } else
                break;
        }
        return res;
    }
}
/* Combination Sum	/ Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.  The same repeated number may be chosen from C unlimited number of times. ITERATIVE (DP)
*/
public class Solution {
    public List<List<Integer>> combinationSum(int[] cands, int t) {
        Arrays.sort(cands); // sort candidates to try them in asc order
        List<List<List<Integer>>> dp = new ArrayList<>();
        for (int i = 1; i <= t; i++) { // run through all targets from 1 to t
            List<List<Integer>> newList = new ArrayList(); // combs for curr i
            // run through all candidates <= i
            for (int j = 0; j < cands.length && cands[j] <= i; j++) {
                // special case when curr target is equal to curr candidate
                if (i == cands[j]) newList.add(Arrays.asList(cands[j]));
                // if current candidate is less than the target use prev results
                else for (List<Integer> l : dp.get(i-cands[j]-1)) {
                    if (cands[j] <= l.get(0)) {
                        List cl = new ArrayList<>();
                        cl.add(cands[j]); cl.addAll(l);
                        newList.add(cl);
                    }
                }
            }
            dp.add(newList);
        }
        return dp.get(t-1);
    }
}
/*Palindrome Partitioning / Palindrome partitioning / Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.
 */
public class Solution 
{
    public List<List<String>> partition(String s) 
    {
        List<List<String>> res=new ArrayList<List<String>>();
        if(s.length()==0)return res;
        recur(res,new ArrayList<String>(),s);
        return res;   
    }
     public void recur(List<List<String>> res,List<String> temp, String s)
     {
        if(s.length()==0)
        {
            res.add(new ArrayList<String>(temp));
            return;
        }
        for(int i=0;i<s.length();i++)
        {
            if(isPalin(s.substring(0,i+1))){
                temp.add(s.substring(0,i+1));
                recur(res,temp,s.substring(i+1));
                temp.remove(temp.size()-1);
            }
        }
    }
    public boolean isPalin(String s)
    {
        for(int i=0;i<s.length()/2;i++)
        {
            if(s.charAt(i)!=s.charAt(s.length()-1-i))return false;
        }
        return true;
    }
}
/* Pow(x. m) / Calculate power function*/
public class Solution {
    public double myPow(double x, int m) {
        double temp=x;
            if(m==0)
            return 1;
            temp=myPow(x,m/2);
            if(m%2==0)
            return temp*temp;
            else 
            {
            if(m > 0)
                return x*temp*temp;
            else
                return (temp*temp)/x;
            }
    }
}

/*Minimum Sliding Window*/
public class Solution {
    public String minWindow(String s, String t) {
        if(s == null || s.length() < t.length() || s.length() == 0){
        return "";
    }
    HashMap<Character,Integer> map = new HashMap<Character,Integer>();
    for(char c : t.toCharArray()){
        if(map.containsKey(c)){
            map.put(c,map.get(c)+1);
        }else{
            map.put(c,1);
        }
    }
    int left = 0;
    int minLeft = 0;
    int minLen = s.length()+1;
    int count = 0;
    for(int right = 0; right < s.length(); right++){
        if(map.containsKey(s.charAt(right))){
            map.put(s.charAt(right),map.get(s.charAt(right))-1);
            if(map.get(s.charAt(right)) >= 0){
                count ++;
            }
            while(count == t.length()){
                if(right-left+1 < minLen){
                    minLeft = left;
                    minLen = right-left+1;
                }
                if(map.containsKey(s.charAt(left))){
                    map.put(s.charAt(left),map.get(s.charAt(left))+1);
                    if(map.get(s.charAt(left)) > 0){
                        count --;
                    }
                }
                left ++ ;
            }
        }
    }
    if(minLen>s.length())  
    {  
        return "";  
    }  

    return s.substring(minLeft,minLeft+minLen);   
    }
}
/* Scramble String / String to tree and back to string*/
public class Solution {
    public boolean isScramble(String s1, String s2) {
         if (s1.equals(s2)) return true; 

        int[] letters = new int[26];
        for (int i=0; i<s1.length(); i++) {
            letters[s1.charAt(i)-'a']++;
            letters[s2.charAt(i)-'a']--;
        }
        for (int i=0; i<26; i++) if (letters[i]!=0) return false;

        for (int i=1; i<s1.length(); i++) {
            if (isScramble(s1.substring(0,i), s2.substring(0,i)) && isScramble(s1.substring(i), s2.substring(i))) 
                return true;
            if (isScramble(s1.substring(0,i), s2.substring(s2.length()-i)) && isScramble(s1.substring(i), s2.substring(0,s2.length()-i))) return true;
        }
        return false;
    }
}
/* Find the minimum set of ranges for a target range
This should run in O(nlogn) time. The bottleneck is in sorting the array. The rest of the algorithm runs in O(n) */*/
List<Interval> smallestSetOfRanges(List<Interval> ranges, Interval R) {
	List<Interval> result;
	int target, i, maxTarget, maxIndex;
	boolean match=false;

	if (R.first == R.second) {
		for (i = 0; i < ranges.size(); i++) {
			if (ranges.get(i).first <= R.first && ranges.get(i).second >= R.second) {
				result.add(ranges.get(i);
				break;
			}
		}
		return result;
	}

	Collections.sort(ranges, new Comparator<Interval>(){
		@Override
		public int compare(Interval i1, Interval i2){
			return Integer.compare(i1.first,i2.first);
		}
	});

	target = R.first;
	maxIndex = 0;
	while (target < R.second) {
		match = false;
		maxTarget = target;
		for (i = maxIndex; i < ranges.size(); i++) {
			if (ranges.get(i).first <= target && ranges.get(i).second >= maxTarget) {
				match = true;
				maxTarget = ranges.get(i).second;
				maxIndex = i;
			} else if (ranges.get(i).first > target) {
				break;
			}
		}
		if (match == false) {
			result.clear();
			break;
		}
		result.add(ranges.get(maxIndex);
		target = maxTarget;
		maxIndex++;
	}

	return result;
}
/* Find the minimum set of ranges for a target range
This should run in O(nlogn) time. The bottleneck is in sorting the array. The rest of the algorithm runs in O(n) */
import java.util.*;

class SmallestRangingSet {
    static class Interval implements Comparable<Interval>{
        Integer min;
        Integer max;
        public Interval(int min, int max) {
            this.min = min;
            this.max = max;
        }

        boolean intersects(int num) {
            return (min <= num && max >= num);
        }

        //Overrides the compareTo method so it will be sorted
        //in order relative to the min value
        @Override
        public int compareTo(Interval obj) {
            if (min > obj.min) return 1;
            else if (min < obj.min) return -1;
            else return 0;
        }
    }

    public static Set<Interval> smallestIntervalSet(Interval[] set, Interval target) {
        //Bottle neck is here. The array is sorted, giving this algorithm O(nlogn) time
        Arrays.sort(set);

        //Create a set to store our ranges in
        Set<Interval> smallSet = new HashSet<Interval>();
        //Create a variable to keep track of the most optimal range, relative
        //to the range before it, at all times.
        Interval bestOfCurr = null;
        //Keep track of the specific number that any given range will need to
        //intersect with. Initialize it to the target-min-value.
        int currBestNum = target.min;
        //Go through each element in our sorted array.
        for (int i = 0; i < set.length; i++) {
            Interval currInterval = set[i];
            //If we have already passed our target max, break.
            if (currBestNum >= target.max)
                break;
            //Otherwise, if the current interval intersects with
            //our currBestNum
            if (currInterval.intersects(currBestNum)) {
                //If the current interval, which intersects currBestNum
                //has a greater max, then our current bestOfCurr
                //Update bestOfCurr to be equal to currInterval.
                if (bestOfCurr == null || currInterval.max >= bestOfCurr.max) {
                    bestOfCurr = currInterval;
                }
            }
            //If our range does not intersect, we can assume that the most recently
            //updated bestOfCurr is probably the most optimal new range to add to 
            //our set. However, if bestOfCurr is null, it means it was never updated,
            //because there is a gap somewhere when trying to fill our target range.
            //So we must check for null first.
            else if (bestOfCurr != null) {
                //If it's not null, add bestOfCurr to our set
                smallSet.add(bestOfCurr);
                //Update currBestNum to look for intervals that
                //intersect with bestOfCurr.max
                currBestNum = bestOfCurr.max;
                //This line is here because without it, it actually skips over
                //the next Interval, which is problematic if your sorted array
                //has two optimal Intervals next to eachother.
                i--;
                //set bestOfCurr to null, so that it won't run
                //this section of code twice on the same Interval.
                bestOfCurr = null;
            }

        }

        //Now we should just make sure that we have in fact covered the entire
        //target range. If we haven't, then we are going to return an empty list.
        if (currBestNum < target.max)
            smallSet.clear();
        return smallSet;
    }

    public static void main(String[] args) {
        //{(1, 4), (30, 40), (20, 91) ,(8, 10), (6, 7), (3, 9), (9, 12), (11, 14)}
        Interval[] interv = {
                new Interval(1, 4),
                new Interval(30, 40),
                new Interval(20, 91),
                new Interval(8, 10),
                new Interval(6, 7),
                new Interval(3, 9),
                new Interval(9, 12),
                new Interval(11, 14)
        };
        Set<Interval> newSet = smallestIntervalSet(interv, new Interval(3,14));
        for (Interval intrv : newSet) {
            System.out.print("(" + intrv.min + ", " + intrv.max + ") ");
        }

    }
}

/* Sum to target in an array (consecutive)*/
public static boolean solution(int[] nums, int target) {
        if(nums.length == 0) {
            return target == 0;
        }
        int start = 0;
        int end = 0;
        int sum = nums[0];
        if (sum == target) {
            return true;
        }
        while(end < nums.length) {
            if(sum > target) {
                sum -= nums[start];
                start++;
            } else {
                end++;
                if(end < nums.length) {
                    sum += nums[end];
                }
            }
            if (sum == target) {
                return true;
            }
        }
        return false;
    }

/* determine the number of steps in which one word / one string to other*/
int count=0;
public int convert(String changing, String end, Set<String> wordDict) {
        if (changing.equals(end)) return count;

        int i = 0;

        for (char c : end.toCharArray()) {
            char[] changingArray = changing.toCharArray();

            if (changingArray[i] != c) {
                char temp = changingArray[i];
		changingArray[i] = c;

                if (dictionary.contains(new String(changingArray))) {
			count++;
                    return convert(new String(changingArray), end);

                }
		Else
		{
			changingArray[i] = temp;
		}
            }
            i++;

        }
        return count;
    }

/* Sort object based on the index 
Example: array[] = {C,D,E,F,G};
Example: index[] = {3,0,4,1,2};
*/
public static void sortByIndex(char[] array, int[] indexes) {
		if (array.length != indexes.length) return;

		for (int i = 0; i < array.length; i++) {
			// swap value
			char temp = array[indexes[i]]; 
			array[indexes[i]] = array[i];
			array[i] = temp;
			// swap index
			int tInd = indexes[indexes[i]];
			indexes[indexes[i]] = indexes[i];
			indexes[i] = tInd;
		}
	}

/* Given an array find all pairs of numbers such that they differ / difference exactly by target value*/
public static void computeDifference(int[] arr, int k){
		for(int i = 0,j = 1; j < arr.length && i < j; ){
			if((arr[j] - arr[i]) == k){
				System.out.println(arr[j]+" "+arr[i]);
				j++;
			}else if((arr[j] - arr[i]) > k){
				i++;
			}else if((arr[j] - arr[i]) < k){
				j++;
				
			}
		}
	}

/* Maximum drop between the two array elements*/
Same as the stock profit


