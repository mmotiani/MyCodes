_____________________________________________________________________

_____________________________________________________________________

_____________________________________________________________________

_____________________________________________________________________

_____________________________________________________________________
/*Minimum Absolute difference in BST and BINARY TREE */

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    int min=Integer.MAX_VALUE;
    TreeNode prev=null;
    
    public int getMinimumDifference(TreeNode root) {
        if(root==null)
            return min;
        
        getMinimumDifference(root.left);
        
        if(prev!=null)
            min = Math.min(min, root.val-prev.val);
        
        prev=root;
        getMinimumDifference(root.right);
        
        return min;
    }
    
    //IF THE TREE WAS NOT BST
    /*
    
    What if it is not a BST? (Follow up of the problem) The idea is to put values in a TreeSet and then every time we can use O(lgN) time to lookup for the nearest values.

    Pre-Order traverse, time complexity O(NlgN), space complexity O(N).


     public class Solution {
    TreeSet<Integer> set = new TreeSet<>();
    int min = Integer.MAX_VALUE;
    
    public int getMinimumDifference(TreeNode root) {
        if (root == null) return min;
        
        if (!set.isEmpty()) {
            if (set.floor(root.val) != null) {
                min = Math.min(min, root.val - set.floor(root.val));
            }
            if (set.ceiling(root.val) != null) {
                min = Math.min(min, set.ceiling(root.val) - root.val);
            }
        }
        
        set.add(root.val);
        
        getMinimumDifference(root.left);
        getMinimumDifference(root.right);
        
        return min;
    }
}
    */
}
_____________________________________________________________________
/*Single Element in the sorted array*/

class Solution {
    public int singleNonDuplicate(int[] nums) {
        
        //EXPLAINATION
        /*
        The logic behind this is very easy: for each mid, we try to find understand whether the single number is on the left half. The if header tests that nums[mid] is not single and neither is anything on its left.

if mid is even, then there are 2m numbers on the left of mid. For the statement of nums[mid] is not single and neither is anything on its left to hold, we need the 2m numbers to the left of mid to be m pairs, and also nums[mid] be in a pair with nums[mid + 1]. Indeed, we only have to make sure in this case that nums[mid], nums[mid + 1] is a pair. You can prove by contradiction that as long as this holds, the sole single number can't be on the left of mid. Now that the statement of nums[mid] is not single and neither is anything on its left is proven, we can just go to the right half.
if mid is odd, then to prove nums[mid] is not single and neither is anything on its left, we only need to prove that nums[mid - 1], nums[mid] is a pair. mid - 1 is even, and as long as nums[mid - 1], nums[mid - 1 + 1] forms a pair, we can actually use the argument of previous paragraph to prove that no entry to the left of mid is single. And neither is mid itself obviously. With nums[mid] is not single and neither is anything on its left proven, we can again to the right half.
If nums[mid] is not single and neither is anything on its left not provable, then go to left half since the single number is there.
        */
        
       int n = nums.length;
        int lo = 0, hi = n - 1;
        while (lo < hi) {
            int mid = lo + (hi - lo) / 2;
            if ((mid % 2 == 0 && nums[mid] == nums[mid + 1]) || (mid % 2 == 1 && nums[mid] == nums[mid - 1]))
                lo = mid + 1;
            else
                hi = mid - 1;
        }
        return nums[lo];
    }
}
_____________________________________________________________________
/*Counting 1s bit from 0 to n*/
class Solution {
    /*
    This uses the hint from the description about using ranges. Basically, the numbers in one range are equal to 1 plus all of the numbers in the ranges before it. If you write out the binary numbers, you can see that numbers 8-15 have the same pattern as 0-7 but with a 1 at the front.

My logic was to copy the previous values (starting at 0) until a power of 2 was hit (new range), at which point we just reset the t pointer back to 0 to begin the new range.
    */
    public int[] countBits(int num) {
        int[] result = new int[num+1];
        result[0]=0;
        int pow = 1;
        for(int i=1, t=0; i<=num;i++,t++)
        {
            if(i==pow)
            {
                pow=pow*2;
                t=0;
            }
            result[i]=result[t]+1;
        }
        return result;
    }
}
//OTHER SOLUTION
/*
public class Solution {
    public int[] countBits(int num) {
        int[] bits = new int[num + 1];    
    for(int i = 1; i <= num; i++){
        bits[i] = bits[i/2];
        if(i%2 == 1) bits[i]++; 
    }
    return bits;
    }
}
*/
_____________________________________________________________________
/*Maximum length of pair chain*/

public class Solution {
    public int findLongestChain(int[][] pairs) {
        Arrays.sort(pairs, (p1,p2)->p1[1]-p2[1] );

        int count = 0, end = Integer.MIN_VALUE;
        for (int[] pair : pairs)
        {
            if (pair[0] > end)
            {
                count++;
                end = pair[1];
            }
        }
        return count;
//         /*
//         This problem is a variation of standard Longest Increasing Subsequence problem. Following is a simple two step process.
// 1) Sort given pairs in increasing order of first (or smaller) element.
// 2) Now run a modified LIS process where we compare the second element of already finalized LIS with the first element of new LIS being constructed.
//         */
        
//         if(pairs==null || pairs.length==0)
//             return 0;
//         Arrays.sort(pairs, (a,b)->(a[0]-b[0]));
        
//         int n=pairs.length;
//         int[] dp = new int[n];
        
//         /* Initialize MCL (max chain length) values for all indexes */
//         for(int i=0; i<n; i++)
//         {
//             dp[i]=1;
//         }
        
//         /* Compute optimized chain length values in bottom up manner */
//         for(int i=1;i<n;i++)
//         {
//             for(int j=0;j<i;j++)
//             {
//                 if(pairs[i][0]>pairs[j][1])
//                     dp[i]=dp[j]+1;
//             }
//         }
        
//         // mcl[i] now stores the maximum chain length ending with pair i
        
//         /* Pick maximum of all MCL values */
//         int max=0;
//         for(int i=0; i<n; i++)
//         {
//             if(max<dp[i])
//                 max=dp[i];
//         }
        
//         return max;
    }
    //ALTERNATIVE SOLUTION USING HEAP
    /*
    public class Solution {
public int findLongestChain(int[][] pairs) {
if(pairs.length==0) return 0;
    Arrays.sort(pairs,new Comparator<int[]>(){
    public int compare(int[] a,int[] b){
    return a[0]-b[0];
    }
});
PriorityQueue<Integer> pq=new PriorityQueue<Integer>(Collections.reverseOrder());
pq.offer(pairs[0][1]);
for(int i=1;i<pairs.length;i++){
    //if the max number of the chain greater than cur right number, replace the max with the smaller one
    if(pq.peek()>pairs[i][1]){
        pq.poll();
        pq.offer(pairs[i][1]);
    }
    else{
    //add the cur right number if chain can be formed;
    if(pq.peek()<pairs[i][0]) pq.offer(pairs[i][1]);
    }
}
return pq.size();
}
}
    */
}
_____________________________________________________________________
/*Frequency Sort*/

public class Solution {
    public String frequencySort(String s) {
        if(s==null || s.length()==0)
            return s;
        
        Map<Character, Integer> map = new HashMap<>();
        
        //Build a map of characters to the number of times it occurs in the string
        for(char ch : s.toCharArray())
            map.put(ch, map.getOrDefault(ch,0)+1);
        
        
        //Create an array where the index of the array represents how many times that character occurred in the String
        List<Character>[] bucket = new List[s.length()+1];
        for(char key:map.keySet())
        {
            int frequency = map.get(key);
            if(bucket[frequency]==null)
                bucket[frequency]=new ArrayList<Character>();
            bucket[frequency].add(key);
        }
        
        //Iterate from the end of the array to the beginning, and at each index, append each character to the return string that number of times.
        StringBuilder sb = new StringBuilder();
        for(int pos = bucket.length-1; pos>=0; pos--)
        {
            if(bucket[pos]!=null)
            {
                for(char num : bucket[pos])
                {
                    for(int i=0; i<map.get(num); i++)
                    {
                        sb.append(num);
                    }
                }
            }
        }
        
        return sb.toString();
        
    }
}
_____________________________________________________________________
/*Most frequent subtree sum*/

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    HashMap<Integer, Integer> sumToCount;
    int maxCount;
    public int[] findFrequentTreeSum(TreeNode root) {
        maxCount=0;
        sumToCount=new HashMap<Integer, Integer>();
        
        postOrder(root);
        List<Integer> res = new ArrayList<>();
        for(int key: sumToCount.keySet())
        {
            if(sumToCount.get(key)==maxCount)
            {
                res.add(key);
            }
        }
        int[] result = new int[res.size()];
        for(int index=0; index<res.size(); index++)
        {
            result[index]=res.get(index);
        }
        return result;
    }
    public int postOrder(TreeNode root)
    {
        if(root==null)
            return 0;
        int left = postOrder(root.left);
        int right = postOrder(root.right);
        
        int sum = left+right+root.val;
        int count = sumToCount.getOrDefault(sum, 0)+1;
        sumToCount.put(sum, count);
        
        maxCount=Math.max(maxCount, count);
        
        return sum;
    }
    /*ONE MORE SOLUTION*/
    
    /*
    Map<Integer, Integer> map = new HashMap<>();
    
    public int[] findFrequentTreeSum(TreeNode root) {
        updateSumTree(root);
        List<Integer> ans = new ArrayList<>();
        int max = 0;
        
        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
            int count = entry.getValue();
            if (count == max) 
                ans.add(entry.getKey());
            if (count > max) {
                max = count;
                ans = new ArrayList<>();
                ans.add(entry.getKey());
            }
        }
        
        int[] result = new int[ans.size()];
        for (int i = 0;i<result.length;i++)
            result[i] = ans.get(i);
        
        return result;
    }
    
    public void updateSumTree(TreeNode root) {
        if (root == null)
            return;
        if (root.left != null) {
            updateSumTree(root.left);
            root.val += root.left.val;
        }
        if (root.right != null) {
            updateSumTree(root.right);
            root.val += root.right.val;
        }
        
        Integer count = map.get(root.val);
        if (count == null)
            map.put(root.val, 1);
        else
            map.put(root.val, count + 1);
    }
}
    */
}
_____________________________________________________________________
/* Boundary / Boundaries of a binary tree */

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    List<Integer> result = new ArrayList<Integer>();
    public List<Integer> boundaryOfBinaryTree(TreeNode root) {
        
        if(root==null)
            return result;
        
        result.add(root.val); //since the root is special,so we add it first
        leftBoundary(root.left);
        leaves(root.left);
        leaves(root.right);
        rightBoundary(root.right);
        
        return result;
    }
    
    public void leftBoundary(TreeNode root)
    {
        if(root==null || (root.left==null && root.right==null))
            return;
        result.add(root.val);
        if(root.left==null)
            leftBoundary(root.right);
        else
            leftBoundary(root.left);
    }
    
    public void rightBoundary(TreeNode root)
    {
        if(root==null || (root.left==null && root.right==null))
            return;
        if(root.right==null)
            rightBoundary(root.left);
        else
            rightBoundary(root.right);
        result.add(root.val); // add after child visit(reverse)
    }
    
    public void leaves(TreeNode root)
    {
        if(root==null)
            return;
        if(root.left==null && root.right==null)
        {
            result.add(root.val);
            return;
        }
        leaves(root.left);
        leaves(root.right);
    }
    
}
_____________________________________________________________________
/*SWAP NODES [ALGO] hackkerank*/
import java.io.*;
import java.util.*;

public class Solution {
   private static class Node{
		int data;
		Node left;
		Node right;
	}

	public static void inorderTraversal(Node node){
		if (node == null){
	        return;
	    }
	    inorderTraversal(node.left);
	    if (node.data != -1){
	    	System.out.print(node.data+" ");
	    }
	    inorderTraversal(node.right);
	}
    
    public static void main(String[] args) throws IOException {
        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
        int nodeCount = Integer.parseInt(reader.readLine());
	//		0 is the first element; or the node with value 1
	Node[] nodes = new Node[nodeCount];
        nodes[0]=new Node();
        nodes[0].data=1;
        
        Map<Node, Integer> depth = new HashMap<Node, Integer>();
        Map<Integer, List<Node>> lookUp = new HashMap<Integer, List<Node>>();
        
        depth.put(nodes[0], 1);
        lookUp.put(1, new ArrayList<Node>());
        lookUp.get(1).add(nodes[0]);
        
        for(int i=0; i<nodeCount; i++)
        {
            int currentDepth = depth.get(nodes[i]);
            String[] split = reader.readLine().split(" ");
            Node left=new Node(), right=new Node();
            left.data=Integer.parseInt(split[0]);
            right.data=Integer.parseInt(split[1]);
            
            if(left.data!=-1)
            {
                nodes[i].left=left;
                nodes[left.data-1]=left;
                depth.put(left, currentDepth+1);
                if(lookUp.get(currentDepth+1)==null)
                    lookUp.put(currentDepth+1, new ArrayList<Node>());
                lookUp.get(currentDepth+1).add(left);
            }
            
            if(right.data!=-1)
            {
                nodes[i].right=right;
                nodes[right.data-1]=right;
                depth.put(right, currentDepth+1);
                if(lookUp.get(currentDepth+1)==null)
                    lookUp.put(currentDepth+1, new ArrayList<Node>());
                lookUp.get(currentDepth+1).add(right);
            }
        }
        
        int swaps = Integer.parseInt(reader.readLine());
        for(int i=0; i<swaps; i++)
        {
            int k = Integer.parseInt(reader.readLine());
            for(int j=1; lookUp.get(j*k)!=null; j++)
            {
                for(Node b : lookUp.get(j*k))
                {
                    Node c = b.left;
                    b.left=b.right;
                    b.right=c;
                }
            }
            inorderTraversal(nodes[0]);
            System.out.println();
        }
		
	}
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
}
_____________________________________________________________________
/*Contacts (question related to Trie)*/
import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        Trie trie = new Trie();
        int n = sc.nextInt();
        
        for(int i=0; i<n; i++)
        {
            String command=sc.next();
            if(command.equals("add"))
            {
                String name=sc.next();
                trie.add(name);
            }
            else
            {
                String partial = sc.next();
                System.out.println(trie.count(partial));
            }
        }
        /* Enter your code here. Read input from STDIN. Print output to STDOUT. Your class should be named Solution. */
    }
}
class Trie
{
    Map<Character, Trie> map = new HashMap<>();
    int count;
    
    void add(String s)
    {
        count++;
        if(s==null || s.length()==0)
            return;
        
        char first = s.charAt(0);
        if(!map.containsKey(first))
            map.put(first, new Trie());
        
        map.get(first).add(s.substring(1));
    }
    
    int count(String s)
    {
        if(s==null||s.length()==0)
            return count;
        char first = s.charAt(0);
        return map.containsKey(first)?map.get(first).count(s.substring(1)) :0;
    }
}

_____________________________________________________________________

/*Running Median*/

import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

public class Solution {
    public static void main(String args[] ) throws Exception {
       Scanner sc = new Scanner(System.in);
        PriorityQueue<Integer> lowers = new PriorityQueue<Integer>(Comparator.reverseOrder());
        PriorityQueue<Integer> uppers = new PriorityQueue<Integer>();
        
        int n = sc.nextInt();
        for(int i=0; i<n; i++)
        {
            int ai=sc.nextInt();
            if(!lowers.isEmpty() && ai<=lowers.peek())
                lowers.offer(ai);
            else
                uppers.offer(ai);
            
            while(lowers.size() > uppers.size())
            {
                uppers.offer(lowers.poll());
            }
            while(uppers.size()-lowers.size()>1)
            {
                lowers.offer(uppers.poll());
            }
            
            double median;
            if(lowers.size()==uppers.size())
            {
                median=(lowers.peek()+uppers.peek())/2.0;
            }
            else
                median=uppers.peek();
            System.out.println(median);
        }
        /* Enter your code here. Read input from STDIN. Print output to STDOUT */
    }
}

_____________________________________________________________________

/*ADD and SEARCH word - Data structure design*/

public class WordDictionary {
    public class TrieNode{
        public TrieNode[] children=new TrieNode[26];
        String item="";
    }
    private TrieNode root;
    /** Initialize your data structure here. */
    public WordDictionary() {
        root=new TrieNode();
    }
    
    /** Adds a word into the data structure. */
    public void addWord(String word) {
        TrieNode node=root;
        for(char c:word.toCharArray())
        {
            if(node.children[c-'a']==null)
                node.children[c-'a']=new TrieNode();
            node = node.children[c-'a'];
        }
        node.item=word;
    }
    
    /** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */
    public boolean search(String word) {
        return match(word.toCharArray(), 0, root);
    }
    
    public boolean match(char[] ch, int k, TrieNode node)
    {
        if(k==ch.length)
            return !node.item.equals("");
        if(ch[k]!='.')
        {
            return node.children[ch[k]-'a']!=null && match(ch, k+1, node.children[ch[k]-'a']);
        }
        else
        {
            for(int i=0;i<node.children.length;i++)
            {
                if(node.children[i]!=null)
                {
                    if(match(ch, k+1, node.children[i]))
                        return true;
                }
            }
        }
        return false;
    }
    
    //OTHER WAY OF SOLVING THE PROBLEM. INSTEAD OF USING ITEM, USE BOOLEAN isWord.
    /*
    public class WordDictionary {

    public class TrieNode {
        public TrieNode[] children = new TrieNode[26];
        public boolean isWord;
    }
    
    private TrieNode root = new TrieNode();

    // Adds a word into the data structure.
    public void addWord(String word) {
        TrieNode node = root;
        for (char c : word.toCharArray()) {
            if (node.children[c - 'a'] == null) {
                node.children[c - 'a'] = new TrieNode();
            }
            node = node.children[c - 'a'];
        }
        node.isWord = true;
    }

    // Returns if the word is in the data structure. A word could
    // contain the dot character '.' to represent any one letter.
    public boolean search(String word) {
        return match(word.toCharArray(), 0, root);
    }
    
    private boolean match(char[] chs, int k, TrieNode node) {
        if (k == chs.length) {
            return node.isWord;
        }
        if (chs[k] == '.') {
            for (int i = 0; i < node.children.length; i++) {
                if (node.children[i] != null && match(chs, k + 1, node.children[i])) {
                    return true;
                }
            }
        } else {
            return node.children[chs[k] - 'a'] != null && match(chs, k + 1, node.children[chs[k] - 'a']);
        }
        return false;
    }
}
    */
    
}

/**
 * Your WordDictionary object will be instantiated and called as such:
 * WordDictionary obj = new WordDictionary();
 * obj.addWord(word);
 * boolean param_2 = obj.search(word);
 */
_____________________________________________________________________
/*COURSE SCHEDULE*/
public class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        if(numCourses<=1)
            return true;
        if(prerequisites.length==0 || prerequisites[0].length==0)
            return true;
        
         // initialize adjacency list
        Map<Integer, Set<Integer>> graph = new HashMap<>();
        
        //Initialize vertices
        for(int i=0;i<numCourses;i++)
            graph.put(i, new HashSet<Integer>());
        
        // add edges
        for(int i=0;i<prerequisites.length;i++)
            graph.get(prerequisites[i][0]).add(prerequisites[i][1]);
        
        Queue<Integer> queue = new LinkedList<>();
        int remainingCourses = numCourses;
        
        for(Map.Entry<Integer, Set<Integer>> entry : graph.entrySet())
        {
            if(entry.getValue().size()==0)
            {
                queue.offer(entry.getKey());
                remainingCourses--;
            }
        }
        
        while(!queue.isEmpty())
        {
            int key=queue.poll();
            
            for(Map.Entry<Integer, Set<Integer>> entry : graph.entrySet())
            {
                if(entry.getValue().contains(key))
                {
                    entry.getValue().remove((Integer)key);
                    if(entry.getValue().size()==0)
                    {
                        queue.offer(entry.getKey());
                        remainingCourses--;
                    }
                }
            }
        }
        return remainingCourses==0;
        
    }
}
_____________________________________________________________________

public class Solution {
    public boolean validTree(int n, int[][] edges) {
        //ALSO CHECK THE BFS SOLUTION 2 EXPLAINED DOWNSTAIRS 
        // FOR QUESTION, check program creek.
        
        // initialize adjacency list
        List<List<Integer>> adjList = new ArrayList<>();
        
         // initialize vertices
        for(int i=0;i<n;i++)
            adjList.add(i, new ArrayList<Integer>());
         
         // add edges 
        for(int i=0;i<edges.length;i++)
        {
            int u=edges[i][0], v=edges[i][1];
            adjList.get(u).add(v);
            adjList.get(v).add(u);
        }
        
        boolean[] visited = new boolean[n];
        
        // make sure there's no cycle
        if(hasCycle(adjList, visited, 0, -1)) // 0 represents the first node
            return false;
        
        // make sure all vertices are connected
        for(int i=0;i<n;i++)
        {
            if(!visited[i])
                return false;
        }
        return true;
    }
    
    // check if an undirected graph has cycle started from vertex u
    public boolean hasCycle(List<List<Integer>> adjList, boolean[] visited, int u, int parent)
    {
        visited[u]=true;
        for(int i=0;i<adjList.get(u).size();i++)
        {
            int v = adjList.get(u).get(i);
            if((visited[v] && parent!=v) || (!visited[v] && hasCycle(adjList, visited, v, u)))
                return true;
        }
        return false;
    }
    
    //SOLUTION 1:ONE MORE SOLUTION using BFS. ABOVE SOLUTION IS WITH DFS. There is one more solution downstairs
    /*
    public class Solution {
    public boolean validTree(int n, int[][] edges) {
        int[] visited = new int[n];
        List<List<Integer>> adjList = new ArrayList<>();
        for (int i=0; i<n; ++i) 
        {  
            adjList.add(new ArrayList<Integer>()); 
        }
        for (int[] edge: edges) 
        {
            adjList.get(edge[0]).add(edge[1]);
            adjList.get(edge[1]).add(edge[0]);
        }
        Deque<Integer> q = new ArrayDeque<>();
        q.addLast(0); visited[0] = 1;  // vertex 0 is in the queue, being visited
        while (!q.isEmpty()) 
        {
            Integer cur = q.removeFirst();
            for (Integer succ: adjList.get(cur)) 
            {
                if (visited[succ] == 1) 
                { 
                    return false;
                }  // loop detected
                if (visited[succ] == 0) 
                { 
                    q.addLast(succ); visited[succ] = 1; 
                }
            }
            visited[cur] = 2;  // visit completed
        }
        for (int v: visited) 
        { 
            if (v == 0) 
            { 
                return false; 
            } 
        }  // # of connected components is not 1
        return true;
    }
}
    */
    
    //SOLUTION 2: ONE MORE BFS (easy to explain)
    /*
    public boolean validTree(int n, int[][] edges) {
    HashMap<Integer, ArrayList<Integer>> map = new HashMap<Integer, ArrayList<Integer>>();
    for(int i=0; i<n; i++){
        ArrayList<Integer> list = new ArrayList<Integer>();
        map.put(i, list);
    }
 
    for(int[] edge: edges){
        map.get(edge[0]).add(edge[1]);
        map.get(edge[1]).add(edge[0]);
    }
 
    boolean[] visited = new boolean[n];
 
    LinkedList<Integer> queue = new LinkedList<Integer>();
    queue.offer(0);
    while(!queue.isEmpty())
    {
        int top = queue.poll();
        if(visited[top])
            return false;
 
        visited[top]=true;
 
        for(int i: map.get(top))
        {
            if(!visited[i])
                queue.offer(i);
        }
    }
 
    for(boolean b: visited)
    {
        if(!b)
            return false;
    }
 
    return true;
}
    */
}
_____________________________________________________________________

/*PAINT HOUSE 1 (3 colors)*/
public class Solution {
    //EXPLAINTION:
    /*
    The basic idea is when we have painted the first i houses, and want to paint the i+1 th house, we have 3 choices: paint it either red, or green, or blue. If we choose to paint it red, we have the follow deduction:

paintCurrentRed = min(paintPreviousGreen,paintPreviousBlue) + costs[i+1][0]
Same for the green and blue situation. And the initialization is set to costs[0], so we get the code:
    */
    public int minCost(int[][] costs) {
        if(costs==null || costs.length==0)
            return 0;
        int lastR=costs[0][0];
        int lastG=costs[0][1];
        int lastB=costs[0][2];
        
        for(int i=1;i<costs.length; i++)
        {
            int currR=Math.min(lastG,lastB)+costs[i][0];
            int currG=Math.min(lastR,lastB)+costs[i][1];
            int currB=Math.min(lastR,lastG)+costs[i][2];
            lastR=currR;
            lastG=currG;
            lastB=currB;
        }
        return Math.min(Math.min(lastR, lastG), lastB);
    }
}
_____________________________________________________________________

/*CELEBRITY CANDIDATE*/

/* The knows API is defined in the parent class Relation.
      boolean knows(int a, int b); */

public class Solution extends Relation {
  //EXPLAINATION:  The first pass is to pick out the candidate. If candidate knows i, then switch candidate. The second pass is to check whether the candidate is real.
    public int findCelebrity(int n) {
        int celebrityCandidate = 0;
        for(int i=1;i<n;i++)
        {
            if(knows(celebrityCandidate, i))
                celebrityCandidate=i;
        }
        for(int i=0;i<n;i++)
        {
            if(i!=celebrityCandidate && (knows(celebrityCandidate, i) || !knows(i,celebrityCandidate)))
                return -1;
        }
        return celebrityCandidate;
    }
}

_____________________________________________________________________

/*Sparse matrix multiplication*/
public class Solution {
    public int[][] multiply(int[][] A, int[][] B) {
        int m = A.length, n = A[0].length, nB = B[0].length;
        int[][] result = new int[m][nB];

        for(int i = 0; i < m; i++) 
        {
            for(int k = 0; k < n; k++) 
            {
                if (A[i][k] != 0) 
                {
                    for (int j = 0; j < nB; j++) 
                    {
                        if (B[k][j] != 0) 
                            result[i][j] += A[i][k] * B[k][j];
                    }
                }
            }
        }
        return result;   
    }
}
_____________________________________________________________________

/*Binary Tree Vertical Order Traversal*/

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<List<Integer>> verticalOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();
        if(root==null) //base case
            return result;
        
        //map's key is column, we assume the root column is zero, the left node will minus 1 ,and the right node will plus 1
        Map<Integer, ArrayList<Integer>> map = new HashMap<>();
        Queue<TreeNode> queue = new LinkedList<>();
        
        //use a HashMap to store the TreeNode and the according cloumn value
        HashMap<TreeNode, Integer> weight = new HashMap<>();
        
        queue.offer(root);
        weight.put(root,0);
        int min=0;
        
        while(!queue.isEmpty())
        {
            TreeNode node = queue.poll();
            int w = weight.get(node);
            
            if(!map.containsKey(w))
            {
                map.put(w, new ArrayList<>());
            }
            
            map.get(w).add(node.val);
            
            if(node.left!=null)
            {
                queue.add(node.left);
                weight.put(node.left, w-1);
            }
            if(node.right!=null)
            {
                queue.add(node.right);
                weight.put(node.right, w+1);
            }
            //update min ,min means the minimum column value, which is the left most node
            min=Math.min(min, w);
            
        }
        while(map.containsKey(min))
        {
            result.add(map.get(min++));
        }
        return result;
    }
}


_____________________________________________________________________

/*set matrix to zero*/

public class Solution {
    public void setZeroes(int[][] matrix) {
        
        if(matrix==null || matrix.length < 1)
            return;
            
        int[] row = new int[matrix.length];
        int[] column = new int[matrix[0].length];
        
        
        for(int i=0; i< matrix.length; i++)
        {
            for(int j=0; j< matrix[0].length; j++)
            {
                if(matrix[i][j]==0)
                {
                    row[i] = -1;
                    column[j] = -1;
                }
            }
            
        }
        
        for(int i=0; i< matrix.length; i++)
        {
            for(int j=0; j< matrix[0].length; j++)
            {
                if(row[i]==-1 || column[j]==-1)
                {
                   matrix[i][j]=0;
                }
            }
            
        }
        
    }
}

_____________________________________________________________________

/*Battleships in a board*/

/**
 * 
 * There are three rules to tell if a cell is a 'head':

The cell is a 'X' (board[i][j] == 'X')
No left side neighbor, or the left neighbor is a '.' (i == 0 || board[i - 1][j] == '.')
No right side neighbor, or the right neighbor is a '.' (j == 0 || board[i][j - 1] == '.')

 * 
 **/
public class Solution {
    public int countBattleships(char[][] board) {
         if (board == null || board.length == 0 || board[0].length == 0) return 0;
	int R = board.length, C = board[0].length, count = 0;
	for (int i = 0; i < R; i++) {
		for (int j = 0; j < C; j++) {
			if (board[i][j] == 'X' && (i == 0 || board[i - 1][j] == '.') && (j == 0 || board[i][j - 1] == '.'))
				count++;
		}
	}
	
	return count;
    }
}

_____________________________________________________________________

/*reverse words in a string in space/ reverse words in a sentence without using extra space*/

public class Solution {
    public void reverseWords(char[] s) {
        
        if(s==null || s.length < 1)
            return;
        
        reverse(s, 0, s.length-1);
        
        //System.out.println(" reversed string : " + s);
        int start = 0;
        
        for(int i=0; i< s.length; i++)
        {
            if(s[i] == ' ')
            {
                reverse(s, start, i-1);
                start = i+1;
            }
        }
        reverse(s, start, s.length-1);
    }
    
    public void reverse(char[] s, int start, int end)
    {
        while(start < end)
        {
            char c = s[start];
            s[start] = s[end];
            s[end] = c;
            
            start++;
            end--;
        }
    }
}
_____________________________________________________________________

/*Water Jug Problem*/
/**
You are given two jugs with capacities x and y litres. There is an infinite amount of water supply available. You need to determine whether it is possible to measure exactly z litres using these two jugs.

If z liters of water is measurable, you must have z liters of water contained within one or both buckets by the end.

Operations allowed:

Fill any of the jugs completely with water.
Empty any of the jugs.
Pour water from one jug into another till the other jug is completely full or the first jug itself is empty.
**/

public class Solution {
    public boolean canMeasureWater(int x, int y, int z) {
         //limit brought by the statement that water is finallly in one or both buckets
    if(x + y < z) return false;
    //case x or y is zero
    if( x == z || y == z || x + y == z ) return true;
    
    //get GCD, then we can use the property of BÃ©zout's identity
    return z%GCD(x, y) == 0;
    }
    public int GCD(int a, int b){
    while(b != 0 ){
        int temp = b;
        b = a%b;
        a = temp;
    }
    return a;
}
}
_____________________________________________________________________

/*GCD of two number*/
public int GCD(int a, int b){
    while(b != 0 ){
        int temp = b;
        b = a%b;
        a = temp;
    }
    return a;
 }
 
 _____________________________________________________________________

/*Largest BST subtree  SOLUTION 1 (a bit tricky)*/
/*Largest Binary search tree subtree*/
/*Largest subtree which is BST in a binary tree*/ 

public int largestBSTSubtree(TreeNode root) {
    if (root == null) return 0;
    if (root.left == null && root.right == null) return 1;
    if (isValid(root, null, null)) return countNode(root);
    return Math.max(largestBSTSubtree(root.left), largestBSTSubtree(root.right));
}

public boolean isValid(TreeNode root, Integer min, Integer max) {
    if (root == null) return true;
    if (min != null && min >= root.val) return false;
    if (max != null && max <= root.val) return false;
    return isValid(root.left, min, root.val) && isValid(root.right, root.val, max);
}

public int countNode(TreeNode root) {
    if (root == null) return 0;
    if (root.left == null && root.right == null) return 1;
    return 1 + countNode(root.left) + countNode(root.right);
}
__________________________________________________________________________

/*Largest BST subtree  SOLUTION 2 (a bit simple to explain)*/
/*Largest Binary search tree subtree*/
/*Largest subtree which is BST in a binary tree*/ 

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
   
   public int largestBSTSubtree(TreeNode root) {
       if(root == null) return 0;
       if(isValid(root, Integer.MAX_VALUE, Integer.MIN_VALUE)) return count(root);
       else return Math.max(largestBSTSubtree(root.left), largestBSTSubtree(root.right));
   }
    
   public int count (TreeNode n){
       if(n == null)
           return 0;
       return 1 + count(n.left) + count(n.right);
   }
   
   public boolean isValid(TreeNode n, int max, int min){
       if(n == null) return true;
       if(n.val < max && n.val > min) return isValid(n.left, n.val, min) && isValid(n.right, max, n.val);
       else return false;
   }
   
}
__________________________________________________________________________

/*Number of Islands*/

public class Solution {
    public int numIslands(char[][] grid) {
        
        if(grid==null || grid.length < 1)
            return 0;
        
        int count=0;
        
        for(int i=0; i< grid.length; i++)
        {
            for(int j=0; j< grid[0].length; j++)
            {
                if(grid[i][j]=='1')
                {
                    count++;
                    //grid[i][j] = 'x';
                    //System.out.println(" inside if" + count);
                    dfs(grid, i, j);
                }
            }
        }
        return count;
    }
    
    
    public void dfs(char[][] grid, int i, int j)
    {
        if( i<0 || j<0 || i>=grid.length || j >= grid[0].length || grid[i][j]!='1')
            return;
        
        grid[i][j] = 'x';
        
        dfs(grid,i-1, j);
        dfs(grid, i+1, j);
        dfs(grid, i, j-1);
        dfs(grid,i, j+1);
    }
}

__________________________________________________________________________

/*Copy List with Random Pointer*/
/**
 * Definition for singly-linked list with a random pointer.
 * class RandomListNode {
 *     int label;
 *     RandomListNode next, random;
 *     RandomListNode(int x) { this.label = x; }
 * };
 */
public class Solution {
    public RandomListNode copyRandomList(RandomListNode head) {
        if(head==null)
            return head;
        
        Map<RandomListNode,RandomListNode> randomPointer = new HashMap<>();
        RandomListNode current=head;
        while(current!=null)
        {
            RandomListNode temp = new RandomListNode(current.label);
            temp.next=null;
            temp.random=null;
            randomPointer.put(current,temp);
            current=current.next;
        }
        current=head;
        while(current!=null)
        {
            RandomListNode temp = randomPointer.get(current);
            temp.next=randomPointer.get(current.next);
            temp.random=randomPointer.get(current.random);
            current=current.next;
        }
        return randomPointer.get(head);
    }
}

__________________________________________________________________________

/*Bottom Left tree value (Iterative)*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int findBottomLeftValue(TreeNode root) {
         Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    while (!queue.isEmpty()) {
        root = queue.poll();
        if (root.right != null)
            queue.add(root.right);
        if (root.left != null)
            queue.add(root.left);
    }
    return root.val;
    }
}
__________________________________________________________________
/*Bottom Left tree value (Recursive)*/

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    
    int maxlevel =0; 
    int nodeData =0;
    public int findBottomLeftValue(TreeNode root) {
        
        findDeepest(root, maxlevel, 1, this.nodeData);
        //System.out.println("Node data before returning: "+ nodeData);
        return this.nodeData;
    }

    public void findDeepest(TreeNode root, int maxlevel, int level, int nodeData)
    {
        if (level > this.maxlevel)
        {
            this.nodeData = root.val;
            this.maxlevel = level;
        }
        
        if(root.left!=null)
            findDeepest(root.left, this.maxlevel, level+1, this.nodeData);    
        
        if(root.right!=null)
             findDeepest(root.right, this.maxlevel, level+1, this.nodeData); 
    }
    
}
__________________________________________________________________________

/*Encode and Decode TinyURL*/
/**
 below is the tiny url solution in java, also this is the similar method in industry. In industry, most of shorten url service is by database, one auto increasing long number as primary key. whenever a long url need to be shorten, append to the database, and return the primary key number. (the database is very easy to distribute to multiple machine like HBase, or even you can use the raw file system to store data and improve performance by shard and replica).
**/
public class Codec {
    List<String> urls = new ArrayList<String>();

    
    // Encodes a URL to a shortened URL.
    public String encode(String longUrl) {
        urls.add(longUrl);
        return String.valueOf(urls.size()-1);
    }

    // Decodes a shortened URL to its original URL.
    public String decode(String shortUrl) {
         int index = Integer.valueOf(shortUrl);
        return (index<urls.size())?urls.get(index):"";
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.decode(codec.encode(url));

__________________________________________________________________________


/*Design Hit Counter SOLUTION 1 (Very Simple)*/
/**
Design a hit counter which counts the number of hits received in the past 5 minutes.

Each function accepts a timestamp parameter (in seconds granularity) and you may assume that calls are being made to the system in chronological order (ie, the timestamp is monotonically increasing). You may assume that the earliest timestamp starts at 1.

It is possible that several hits arrive roughly at the same time.
**/
public class HitCounter {
/*In this problem, I use a queue to record the information of all the hits. Each time we call the function getHits( ), we have to delete the elements which hits beyond 5 mins (300). The result would be the length of the queue : ) */

        Queue<Integer> q = null;
        /** Initialize your data structure here. */
        public HitCounter() {
            q = new LinkedList<Integer>();
        }
        
        /** Record a hit.
            @param timestamp - The current timestamp (in seconds granularity). */
        public void hit(int timestamp) {
            q.offer(timestamp);
        }
        
        /** Return the number of hits in the past 5 minutes.
            @param timestamp - The current timestamp (in seconds granularity). */
        public int getHits(int timestamp) {
            while(!q.isEmpty() && timestamp - q.peek() >= 300) {
                q.poll();
            }
            return q.size();
        }
    }
}
/*Design Hit Counter SOLUTION 2 (Not Very Simple) hit = O(1) and getHits = O(s) where s is the timestamp and in this case s is 300*/
public class HitCounter {
    private int[] times;
    private int[] hits;
    /** Initialize your data structure here. */
    public HitCounter() {
        times = new int[300];
        hits = new int[300];
    }
    
    /** Record a hit.
        @param timestamp - The current timestamp (in seconds granularity). */
    public void hit(int timestamp) {
        int index = timestamp % 300;
        if (times[index] != timestamp) {
            times[index] = timestamp;
            hits[index] = 1;
        } else {
            hits[index]++;
        }
    }
    
    /** Return the number of hits in the past 5 minutes.
        @param timestamp - The current timestamp (in seconds granularity). */
    public int getHits(int timestamp) {
        int total = 0;
        for (int i = 0; i < 300; i++) {
            if (timestamp - times[i] < 300) {
                total += hits[i];
            }
        }
        return total;
    }
}
__________________________________________________________________________

/*Design Phone Directory*/
/**
Design a Phone Directory which supports the following operations:

get: Provide a number which is not assigned to anyone.
check: Check if a number is available or not.
release: Recycle or release a number.
**/
Set<Integer> used = new HashSet<Integer>();
    Queue<Integer> available = new LinkedList<Integer>();
    int max;
    public PhoneDirectory(int maxNumbers) {
        max = maxNumbers;
        for (int i = 0; i < maxNumbers; i++) {
            available.offer(i);
        }
    }
    
    public int get() {
        Integer ret = available.poll();
        if (ret == null) {
            return -1;
        }
        used.add(ret);
        return ret;
    }
    
    public boolean check(int number) {
        if (number >= max || number < 0) {
            return false;
        }
        return !used.contains(number);
    }
    
    public void release(int number) {
        if (used.remove(number)) {
            available.offer(number);
        }
    }
__________________________________________________________________________

/*Design Tic Tac Toe*/
/**
Initially, I had not read the Hint in the question and came up with an O(n) solution. After reading the extremely helpful hint; a much easier approach became apparent. The key observation is that in order to win Tic-Tac-Toe you must have the entire row or column. Thus, we don't need to keep track of an entire n^2 board. We only need to keep a count for each row and column. If at any time a row or column matches the size of the board then that player has won.

To keep track of which player, I add one for Player1 and -1 for Player2. There are two additional variables to keep track of the count of the diagonals. Each time a player places a piece we just need to check the count of that row, column, diagonal and anti-diagonal.

Also see a very similar answer that I believe had beaten me to the punch. We came up with our solutions independently but they are very similar in principle.
**/
public class TicTacToe {
private int[] rows;
private int[] cols;
private int diagonal;
private int antiDiagonal;

/** Initialize your data structure here. */
public TicTacToe(int n) {
    rows = new int[n];
    cols = new int[n];
}

/** Player {player} makes a move at ({row}, {col}).
    @param row The row of the board.
    @param col The column of the board.
    @param player The player, can be either 1 or 2.
    @return The current winning condition, can be either:
            0: No one wins.
            1: Player 1 wins.
            2: Player 2 wins. */
public int move(int row, int col, int player) {
    int toAdd = player == 1 ? 1 : -1;
    
    rows[row] += toAdd;
    cols[col] += toAdd;
    if (row == col)
    {
        diagonal += toAdd;
    }
    
    if (col == (cols.length - row - 1))
    {
        antiDiagonal += toAdd;
    }
    
    int size = rows.length;
    if (Math.abs(rows[row]) == size ||
        Math.abs(cols[col]) == size ||
        Math.abs(diagonal) == size  ||
        Math.abs(antiDiagonal) == size)
    {
        return player;
    }
    
    return 0;
}
__________________________________________________________________________

/**

Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user's news feed. Your design should support the following methods:

postTweet(userId, tweetId): Compose a new tweet.
getNewsFeed(userId): Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.
follow(followerId, followeeId): Follower follows a followee.
unfollow(followerId, followeeId): Follower unfollows a followee.

**/
public class Twitter {

    private static class Tweet{
    int tweetId;
    int timePosted;
    public Tweet(int tId, int time){
        tweetId = tId;
        timePosted = time;
    }
}

    static int timeStamp;
int feedMaxNum;
Map<Integer, Set<Integer>> followees;
Map<Integer, List<Tweet>> tweets;

/** Initialize your data structure here. */
public Twitter() {
    timeStamp = 0;
    feedMaxNum = 10;
    followees = new HashMap<>();
    tweets = new HashMap<>();
}

/** Compose a new tweet. */
public void postTweet(int userId, int tweetId) {
    if(!tweets.containsKey(userId)) {
        tweets.put(userId, new LinkedList<Tweet>());
        follow(userId, userId);  //follow itself
    }
    tweets.get(userId).add(0, new Tweet(tweetId, timeStamp++)); //add new tweet on the first place
}

/** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */
public List<Integer> getNewsFeed(int userId) {
    //min heap that the earliest tweet is on the top
    PriorityQueue<Tweet> feedHeap = new PriorityQueue<>(new Comparator<Tweet>(){
        public int compare(Tweet t1, Tweet t2){
            return t1.timePosted - t2.timePosted;
        }
    });

    //add tweets of the followees
    Set<Integer> myFollowees = followees.get(userId);
    if(myFollowees != null){
        for(int followeeId : myFollowees){
            List<Tweet> followeeTweets = tweets.get(followeeId);
            if(followeeTweets == null) continue;
            for(Tweet t : followeeTweets){
                if(feedHeap.size() < feedMaxNum) feedHeap.add(t);
                else{
                    if(t.timePosted <= feedHeap.peek().timePosted) break;
                    else{
                        feedHeap.add(t);
                        feedHeap.poll(); //remove the oldest tweet
                    }
                }
            }
        }
    }
    List<Integer> myFeed = new LinkedList<>();
    while(!feedHeap.isEmpty()){
        myFeed.add(0, feedHeap.poll().tweetId);
    }
    return myFeed;
}

/** Follower follows a followee. If the operation is invalid, it should be a no-op. */
public void follow(int followerId, int followeeId) {
    if(!followees.containsKey(followerId)) followees.put(followerId, new HashSet<Integer>());
    followees.get(followerId).add(followeeId);
}

/** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */
public void unfollow(int followerId, int followeeId) {
    if(!followees.containsKey(followerId) || followerId == followeeId) return; //cannot unfollow itself
    followees.get(followerId).remove(followeeId);
}
}
/**
 * Your Twitter object will be instantiated and called as such:
 * Twitter obj = new Twitter();
 * obj.postTweet(userId,tweetId);
 * List<Integer> param_2 = obj.getNewsFeed(userId);
 * obj.follow(followerId,followeeId);
 * obj.unfollow(followerId,followeeId);
 */
__________________________________________________________________________

/*Populating the next right pointer I and II*/

/**
 * Definition for binary tree with next pointer.
 * public class TreeLinkNode {
 *     int val;
 *     TreeLinkNode left, right, next;
 *     TreeLinkNode(int x) { val = x; }
 * }
 */
public class Solution {
    public void connect(TreeLinkNode root) {
        if(root==null)
        return;
 
    LinkedList<TreeLinkNode> nodeQueue = new LinkedList<TreeLinkNode>();
    LinkedList<Integer> depthQueue = new LinkedList<Integer>();
 
    if(root!=null){
        nodeQueue.offer(root);
        depthQueue.offer(1);
    }
 
    while(!nodeQueue.isEmpty()){
        TreeLinkNode topNode = nodeQueue.poll();
        int depth = depthQueue.poll();
 
        if(depthQueue.isEmpty()){
            topNode.next = null;
        }else if(depthQueue.peek()>depth){
            topNode.next = null;
        }else{
            topNode.next = nodeQueue.peek();
        }
 
        if(topNode.left!=null){
            nodeQueue.offer(topNode.left);
            depthQueue.offer(depth+1);
        }
 
        if(topNode.right!=null){
            nodeQueue.offer(topNode.right);
            depthQueue.offer(depth+1);
        }        
    }
    }
}
__________________________________________________________________________

/*Decode ways*/
public int numDecodings(String s) {
    if(s==null || s.length()==0 || s.charAt(0)=='0')
        return 0;
    if(s.length()==1)
        return 1;
 
    int[] dp = new int[s.length()];    
    dp[0]=1;
    if(Integer.parseInt(s.substring(0,2))>26){
        if(s.charAt(1)!='0'){
            dp[1]=1;
        }else{
            dp[1]=0;
        }
    }else{
        if(s.charAt(1)!='0'){
            dp[1]=2;
        }else{
            dp[1]=1;
        }
    }
 
    for(int i=2; i<s.length(); i++){
        if(s.charAt(i)!='0'){
            dp[i]+=dp[i-1];
        }
 
        int val = Integer.parseInt(s.substring(i-1, i+1));
        if(val<=26 && val >=10){
            dp[i]+=dp[i-2];
        }
    }
 
    return dp[s.length()-1];
}

__________________________________________________________________________

/*Longest Increasing subsequence*/

public int lengthOfLIS(int[] nums) {
    if(nums==null || nums.length==0)
        return 0;
 
    ArrayList<Integer> list = new ArrayList<Integer>(); 
 
    for(int num: nums){
        if(list.size()==0 || num>list.get(list.size()-1)){
            list.add(num);
        }else{
            int i=0; 
            int j=list.size()-1;
 
            while(i<j){
                int mid = (i+j)/2;
                if(list.get(mid) < num){
                    i=mid+1;
                }else{
                    j=mid;
                }
            }
 
            list.set(j, num);
        }
    }
 
    return list.size();
}
__________________________________________________________________________

/*Integer to English Word*/

public class Solution {
    HashMap<Integer, String> map = new HashMap<Integer, String>();
 
    public String numberToWords(int num) {
        fillMap();
        StringBuilder sb = new StringBuilder();
 
        if(num==0){
            return map.get(0);
        }
 
        if(num >= 1000000000){
            int extra = num/1000000000;
            sb.append(convert(extra) + " Billion");
            num = num%1000000000;
        }
 
        if(num >= 1000000){
            int extra = num/1000000;
            sb.append(convert(extra) + " Million");
            num = num%1000000;
        } 
 
        if(num >= 1000){
            int extra = num/1000;
            sb.append(convert(extra) + " Thousand");
            num = num%1000;
        } 
 
        if(num > 0){
            sb.append(convert(num));
        }
 
        return sb.toString().trim();
    }
 
    public String convert(int num){
 
        StringBuilder sb = new StringBuilder();
 
        if(num>=100){
            int numHundred = num/100;
            sb.append(" " +map.get(numHundred)+ " Hundred");
            num=num%100;
        }
 
        if(num > 0){
            if(num>0 && num<=20){
                sb.append(" "+map.get(num));
            }else{
                int numTen = num/10;
                sb.append(" "+map.get(numTen*10));
 
                int numOne=num%10;
                if(numOne>0){
                    sb.append(" " + map.get(numOne));
                }
            }
        }
 
        return sb.toString();
    }
 
    public void fillMap(){
        map.put(0, "Zero");
        map.put(1, "One");
        map.put(2, "Two");
        map.put(3, "Three");
        map.put(4, "Four");
        map.put(5, "Five");
        map.put(6, "Six");
        map.put(7, "Seven");
        map.put(8, "Eight");
        map.put(9, "Nine");
        map.put(10, "Ten");
        map.put(11, "Eleven");
        map.put(12, "Twelve");
        map.put(13, "Thirteen");
        map.put(14, "Fourteen");
        map.put(15, "Fifteen");
        map.put(16, "Sixteen");
        map.put(17, "Seventeen");
        map.put(18, "Eighteen");
        map.put(19, "Nineteen");
        map.put(20, "Twenty");
        map.put(30, "Thirty");
        map.put(40, "Forty");
        map.put(50, "Fifty");
        map.put(60, "Sixty");
        map.put(70, "Seventy");
        map.put(80, "Eighty");
        map.put(90, "Ninety");
    }
}

__________________________________________________________________________

/*Longest Palindromic substring*/

public class Solution {
private int lo, maxLen;

public String longestPalindrome(String s) {
	int len = s.length();
	if (len < 2)
		return s;
	
    for (int i = 0; i < len-1; i++) {
     	extendPalindrome(s, i, i);  //assume odd length, try to extend Palindrome as possible
     	extendPalindrome(s, i, i+1); //assume even length.
    }
    return s.substring(lo, lo + maxLen);
}

private void extendPalindrome(String s, int j, int k) {
	while (j >= 0 && k < s.length() && s.charAt(j) == s.charAt(k)) {
		j--;
		k++;
	}
	if (maxLen < k - j - 1) {
		lo = j + 1;
		maxLen = k - j - 1;
	}
}}

__________________________________________________________________________

/* Read N Characters Given Read4*/
public int read(char[] buf, int n) {
  boolean eof = false;      // end of file flag
  int total = 0;            // total bytes have read
  char[] tmp = new char[4]; // temp buffer
  
  while (!eof && total < n) {
    int count = read4(tmp);
    
    // check if it's the end of the file
    eof = count < 4;
    
    // get the actual count
    count = Math.min(count, n - total);
    
    // copy from temp buffer to buf
    for (int i = 0; i < count; i++) 
      buf[total++] = tmp[i];
  }
  
  return total;
}
__________________________________________________________________________

/*Distance of non-zero number from nearest zero */
/*for every non-zero element in array, find its distance to the nearest zero*/

public static void zeroDistance (int [] a) {
    // closest == -1 means no zero was found yet
    int closest = -1;
    for (int i=0 ; i<a.length ; i++) 
       if (a[i] == 0) 
           closest = 0;
       else {         
           // short version
           // a[i] = closest == -1 ? Integer.MAX_VALUE : ++closest;

           // simpler version for your to understand
           if (closest == -1) 
               a[i] = Integer.MAX_VALUE;
           else {
               closest++;
               a[i] = closest;
           }                    
       }
    closest = -1;
    for (int i=a.length-1 ; i>=0 ; i--) 
       if (a[i] == 0)                            
           closest = 0;
       else if (closest != -1 && a[i] > ++closest) 
           a[i] = closest;       
}
__________________________________________________________________________

/* First Unique Character in a String */
/*
s = "leetcode"
return 0.

s = "loveleetcode",
return 2.
*/

public class Solution {
    public int firstUniqChar(String s) {
         int freq [] = new int[26];
        for(int i = 0; i < s.length(); i ++)
            freq [s.charAt(i) - 'a'] ++;
        for(int i = 0; i < s.length(); i ++)
            if(freq [s.charAt(i) - 'a'] == 1)
                return i;
        return -1;
    }
}

__________________________________________________________________________

/*132 pattern*/
/*
Given a sequence of n integers a1, a2, ..., an, a 132 pattern is a subsequence ai, aj, ak such that i < j < k and ai < ak < aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.
*/

public class Solution {
    public boolean find132pattern(int[] nums) {
         Stack<Pair> stack = new Stack();
        for(int n: nums)
        {
            if(stack.isEmpty() || n <stack.peek().min ) 
                stack.push(new Pair(n,n));
            else if(n > stack.peek().min)
            { 
                Pair last = stack.pop();
                if(n < last.max) 
                    return true;
                else 
                {
                    last.max = n;
                    while(!stack.isEmpty() && n >= stack.peek().max) 
                        stack.pop();
                    // At this time, n < stack.peek().max (if stack not empty)
                    if(!stack.isEmpty() && stack.peek().min < n) 
                        return true;
                    stack.push(last);
                }
                
            }
        }
        return false;
    }
}
  class Pair{
        int min, max;
        public Pair(int min, int max){
            this.min = min;
            this.max = max;
        }
}
__________________________________________________________________________

/*Lexicographical Numbers
Given an integer n, return 1 - n in lexicographical order.
For example, given 13, return: [1,10,11,12,13,2,3,4,5,6,7,8,9].
*/
/*
The basic idea is to find the next number to add.
Take 45 for example: if the current number is 45, the next one will be 450 (450 == 45 * 10)(if 450 <= n), or 46 (46 == 45 + 1) (if 46 <= n) or 5 (5 == 45 / 10 + 1)(5 is less than 45 so it is for sure less than n).
We should also consider n = 600, and the current number = 499, the next number is 5 because there are all "9"s after "4" in "499" so we should divide 499 by 10 until the last digit is not "9".
It is like a tree, and we are easy to get a sibling, a left most child and the parent of any node.
*/
public class Solution {
    public List<Integer> lexicalOrder(int n) {
         List<Integer> list = new ArrayList<>(n);
        int curr = 1;
        for (int i = 1; i <= n; i++) {
            list.add(curr);
            if (curr * 10 <= n) {
                curr *= 10;
            } else if (curr % 10 != 9 && curr + 1 <= n) {
                curr++;
            } else {
                while ((curr / 10) % 10 == 9) {
                    curr /= 10;
                }
                curr = curr / 10 + 1;
            }
        }
        return list;
    }
}
__________________________________________________________________________

/*Ones and Zeroes
In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.
For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.
Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.
Note:â¨
1. The given numbers of 0s and 1s will both not exceed 100
2. The size of given string array won't exceed 600.

Example 1:â¨
Input: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3
Output: 4

Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are â10,â0001â,â1â,â0â

Example 2:â¨
Input: Array = {"10", "0", "1"}, m = 1, n = 1
Output: 2

Explanation: You could form "10", but then you'd have nothing left. Better form "0" and "1".
*/
public class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int[][] dp = new int[m+1][n+1];
    for (String s : strs) {
        int[] count = count(s);
        for (int i=m;i>=count[0];i--) 
            for (int j=n;j>=count[1];j--) 
                dp[i][j] = Math.max(1 + dp[i-count[0]][j-count[1]], dp[i][j]);
    }
    return dp[m][n];
    }
    public int[] count(String str) {
    int[] res = new int[2];
    for (int i=0;i<str.length();i++)
        res[str.charAt(i) - '0']++;
    return res;
 }
}
__________________________________________________________________________

/*Search in a rotated sorted array*/
class Solution {
public:
    int search(int A[], int n, int target) {
        int lo=0,hi=n-1;
        // find the index of the smallest value using binary search.
        // Loop will terminate since mid < hi, and lo or hi will shrink by at least 1.
        // Proof by contradiction that mid < hi: if mid==hi, then lo==hi and loop would have been terminated.
        while(lo<hi){
            int mid=(lo+hi)/2;
            if(A[mid]>A[hi]) lo=mid+1;
            else hi=mid;
        }
        // lo==hi is the index of the smallest value and also the number of places rotated.
        int rot=lo;
        lo=0;hi=n-1;
        // The usual binary search and accounting for rotation.
        while(lo<=hi){
            int mid=(lo+hi)/2;
            int realmid=(mid+rot)%n;
            if(A[realmid]==target)return realmid;
            if(A[realmid]<target)lo=mid+1;
            else hi=mid-1;
        }
        return -1;
    }
}
__________________________________________________________________________

/*H-Index (citation)*/
public class Solution {
    public int hIndex(int[] citations) {
        if (citations == null || citations.length == 0) return 0;
        Arrays.sort(citations);
        int len = citations.length;
        for (int i = 0; i < citations.length; i++) {
            if (len <= citations[i])
                return len;
            else
                len--;
        }
        return len;
    }
}
__________________________________________________________________________

/*H-Index II (citation)*/
public class Solution {
    public int hIndex(int[] citations) {
         if(citations == null || citations.length == 0) return 0;
        int l = 0, r = citations.length;
        int n = citations.length;
        while(l < r){
            int mid = l + (r - l) / 2;
            if(citations[mid] == n - mid) return n - mid;
            if(citations[mid] < citations.length - mid) l = mid + 1;
            else r = mid;
        }
        return n - l;
    }
}
__________________________________________________________________________

/*Validate IP address IPv4 or IPv6*/

public class Solution {
    public String validIPAddress(String IP) {
        if(isValidIPv4(IP)) return "IPv4";
	else if(isValidIPv6(IP)) return "IPv6";
	else return "Neither";
    }
    public boolean isValidIPv4(String ip) {
	if(ip.length()<7) return false;
	if(ip.charAt(0)=='.') return false;
	if(ip.charAt(ip.length()-1)=='.') return false;
	String[] tokens = ip.split("\\.");
	if(tokens.length!=4) return false;
	for(String token:tokens) {
		if(!isValidIPv4Token(token)) return false;
	}
	return true;
}
public boolean isValidIPv4Token(String token) {
	if(token.startsWith("0") && token.length()>1) return false;
	try {
		int parsedInt = Integer.parseInt(token);
		if(parsedInt<0 || parsedInt>255) return false;
		if(parsedInt==0 && token.charAt(0)!='0') return false;
	} catch(NumberFormatException nfe) {
		return false;
	}
	return true;
}
	
public boolean isValidIPv6(String ip) {
	if(ip.length()<15) return false;
	if(ip.charAt(0)==':') return false;
	if(ip.charAt(ip.length()-1)==':') return false;
	String[] tokens = ip.split(":");
	if(tokens.length!=8) return false;
	for(String token: tokens) {
		if(!isValidIPv6Token(token)) return false;
	}
	return true;
}
public boolean isValidIPv6Token(String token) {
	if(token.length()>4 || token.length()==0) return false;
	char[] chars = token.toCharArray();
	for(char c:chars) {
		boolean isDigit = c>=48 && c<=57;
		boolean isUppercaseAF = c>=65 && c<=70;
		boolean isLowerCaseAF = c>=97 && c<=102;
		if(!(isDigit || isUppercaseAF || isLowerCaseAF)) 
			return false;
	}
	return true;
}
}
__________________________________________________________________________

/*Remove K Digits from a number to make it smaller
Example 1:
Input: num = "1432219", k = 3
Output: "1219"
Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.

Example 2:
Input: num = "10200", k = 1
Output: "200"
Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes.

Example 3:
Input: num = "10", k = 2
Output: "0"
Explanation: Remove all the digits from the number and it is left with nothing which is 0.
*/
public class Solution {
    public String removeKdigits(String num, int k) {
        int length = num.length();
        
         //corner case
        if(length==k)
            return "0";
            
        Stack<Character> stack = new Stack<>();
        int index;
        for(index=0;index<length;index++)
        {
             //whenever meet a digit which is less than the previous digit, discard the previous one
            while(k>0 && !stack.isEmpty() && stack.peek()>num.charAt(index))
            {
                stack.pop();
                k--;
            }
            stack.push(num.charAt(index));
        }
        
        // corner case like "1111"
        while(k>0)
        {
            stack.pop();
            k--;
        }
        
        //construct the number from the stack
        StringBuilder result = new StringBuilder();
        while(!stack.isEmpty())
        {
            result.append(stack.pop());
        }
        result.reverse();
        
        //remove all the 0 at the head
        while(result.length()>1 && result.charAt(0)=='0')
        {
            result.deleteCharAt(0);
        }
        return result.toString();
    }
}
__________________________________________________________________________

/*Range addition*/
/*
Assume you have an array of length n initialized with all 0's and are given k update operations.

Each operation is represented as a triplet: [startIndex, endIndex, inc] which increments each element of subarray A[startIndex ... endIndex] (startIndex and endIndex inclusive) with inc.

Return the modified array after all k operations were executed
*/
public class Solution {
    /*
    segment [i,j] is made of two parts [0,i-1] and [0, j]
so [i,j] increase 2 is same as [0,j] increase 2 and [0,i-1] increase -2. so you only need to update value at nums[j] with inc and nums[i-1] -inc. initially nums[i] is defined as all elements [0,i] increases inc

then think from length-1 to 0 backward. The last spot nums[length-1] does not need any modification.
nums[length-2] value should be updated as nums[length-2] + nums[length-1] as the latter covers the front. but front does not influence what is after it. so every spot should be updated as + the accumulate sum from the end.
    */
    public int[] getModifiedArray(int length, int[][] updates) {
         int[] nums = new int[length];
        for (int[] update : updates) {
            nums[update[1]] += update[2];
            if (update[0] > 0) {
                nums[update[0] - 1] -= update[2];
            } 
        }
        
        int sum = nums[length - 1];
        for (int i = length - 2; i >= 0; i--) {
            int tmp = sum + nums[i];
            nums[i] += sum;
            sum = tmp; 
        }
        return nums;
    }
}

/*Combination Sum 3*/
public class Solution {
    public List<List<Integer>> combinationSum3(int k, int n) {
        List<List<Integer>> ans = new ArrayList<>();
    combination(ans, new ArrayList<Integer>(), k, 1, n);
    return ans;
    }
    
    private void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {
    if (comb.size() == k && n == 0) {
        List<Integer> li = new ArrayList<Integer>(comb);
        ans.add(li);
        return;
    }
    for (int i = start; i <= 9; i++) {
        comb.add(i);
        combination(ans, comb, k, i+1, n-i);
        comb.remove(comb.size() - 1);
    }
}
}

/*Combinations
Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.
For example,
If n = 4 and k = 2, a solution is:
[   [2,4],   [3,4],   [2,3],   [1,2],   [1,3],   [1,4], ]
*/
public class Solution {

    public List<List<Integer>> combine(int n, int k) {

        List<List<Integer>> combs = new ArrayList<List<Integer>>();

        combine(combs, new ArrayList<Integer>(), 1, n, k);

        return combs;

    
    public static void combine(List<List<Integer>> combs, List<Integer> comb, int start, int n, int k) {

        if(k==0) {

            combs.add(new ArrayList<Integer>(comb));

            return;

        }

        for(int i=start;i<=n;i++) {

            comb.add(i);

            combine(combs, comb, i+1, n, k-1);

            comb.remove(comb.size()-1);

        }

    }



}



/*Write a function that takes a string as input and returns the string reversed | Reverse StRing*/

public class Solution {

    public String reverseString(String s) {

        char[] word = s.toCharArray();

        int i = 0;

        int j = s.length() - 1;

        while (i < j) {

            char temp = word[i];

            word[i] = word[j];

            word[j] = temp;

            i++;

            j--;

        }

        return new String(word);

    }

}

/*POWER OF THREE (SOLUTION 1)*/
public class Solution {

    public boolean isPowerOfThree(int n) {

        // 1162261467 is 3^19,  3^20 is bigger than int  

    return ( n>0 &&  1162261467%n==0);

    }

}
/* POWER OF THREE (SOLUTION 2)*/
public class Solution {

    public boolean isPowerOfThree(int n) {

       // The expression "(int) Math.pow(3, (int) (Math.log(Integer.MAX_VALUE) / Math.log(3.0))" returns max integer that is "power of 3"

    return n > 0 && (int) Math.pow(3, (int) (Math.log(Integer.MAX_VALUE) / Math.log(3.0))) % n == 0;
    }

}
/* Reverse Vowels of a String (LESS OPTIMIZED)*/
public class Solution {

    public String reverseVowels(String s) {

       if(s == null || s.length()==0) return s;

    String vowels = "aeiouAEIOU";

    char[] chars = s.toCharArray();

    int start = 0;

    int end = s.length()-1;

    while(start<end){



        while(start<end && !vowels.contains(chars[start]+"")){

            start++;

        }



        while(start<end && !vowels.contains(chars[end]+"")){

            end--;

        }



        char temp = chars[start];

        chars[start] = chars[end];

        chars[end] = temp;



        start++;

        end--;

    }

    return new String(chars);

    }

}
/* Reverse Vowels of a String  (MORE OPTIMIZED)*/
public class Solution {

    public String reverseVowels(String s) {

        if(s == null || s.length()==0){

            return s;

        }

        HashSet<Character> vowels = new HashSet<>();

        vowels.add('a');

        vowels.add('e');

        vowels.add('i');

        vowels.add('o');

        vowels.add('u');



        vowels.add('A');

        vowels.add('E');

        vowels.add('I');

        vowels.add('O');

        vowels.add('U');



        // reverse the  vowels while popping up

        Stack<Character> vStack = new Stack<>();

        for(char c : s.toCharArray()){

            if(vowels.contains(c)){

                vStack.push(c);

            }

        }



        StringBuilder sb = new StringBuilder();

        for(char c : s.toCharArray()){

            if(vowels.contains(c)){

                sb.append(vStack.pop());

            }else{

                sb.append(c);

            }

        }

        return sb.toString();

    }

}
/*POWER OF FOUR*/
// The idea is that numbers in quaternary system that is power of 4 will be like 10, 100, 1000 and such. Similar to binary case. And this can be extended to any radix.

public class Solution {

    public boolean isPowerOfFour(int num) {

        return Integer.toString(num, 4).matches("10*");

    }

}

/*REVERSE BITS*/
public class Solution {

    // you need treat n as an unsigned value

    public int reverseBits(int n) {

        int res=0;

    for(int i=0;i<32;i++){

        res= ( res << 1 ) | ( n & 1 );         

        n = n >> 1;                  

    }

    return res;

    }

}
/* Counting Bits | Count 1s bits and return them in array (Dynamic Programming)*/
public class Solution {

    public int[] countBits(int num) {

        int[] bits = new int[num + 1];    

    for(int i = 1; i <= num; i++){

        bits[i] = bits[i/2];

        if(i%2 == 1) bits[i]++; 

    }

    return bits;

    }

}
/* Counting Bits | Count 1s bits and return them in array (using two pointers)*/
/*This uses the hint from the description about using ranges. Basically, the numbers in one range are equal to 1 plus all of the numbers in the ranges before it. If you write out the binary numbers, you can see that numbers 8-15 have the same pattern as 0-7 but with a 1 at the front.
My logic was to copy the previous values (starting at 0) until a power of 2 was hit (new range), at which point we just reset the t pointer back to 0 to begin the new range.
*/
public class Solution {

    public int[] countBits(int num) {

       int[] ret = new int[num+1];

    ret[0] = 0;

    int pow = 1;

    for(int i = 1, t = 0; i <= num; i++, t++) {

        if(i == pow) {

            pow *= 2;

            t = 0;

        }

        ret[i] = ret[t] + 1;

    }

    return ret;

    }

}
/*Patching Array | Patches in array (SOLUTION 1)*/

/*
Explanation
Let miss be the smallest sum in [0,n] that we might be missing. Meaning we already know we can build all sums in [0,miss). Then if we have a number num <= miss in the given array, we can add it to those smaller sums to build all sums in [0,miss+num). If we don't, then we must add such a number to the array, and it's best to add miss itself, to maximize the reach.
________________________________________
Example: Let's say the input is nums = [1, 2, 4, 13, 43] and n = 100. We need to ensure that all sums in the range [1,100] are possible.
Using the given numbers 1, 2 and 4, we can already build all sums from 0 to 7, i.e., the range [0,8). But we can't build the sum 8, and the next given number (13) is too large. So we insert 8 into the array. Then we can build all sums in [0,16).
Do we need to insert 16 into the array? No! We can already build the sum 3, and adding the given 13 gives us sum 16. We can also add the 13 to the other sums, extending our range to [0,29).
And so on. The given 43 is too large to help with sum 29, so we must insert 29 into our array. This extends our range to [0,58). But then the 43 becomes useful and expands our range to [0,101). At which point we're done.

*/
public class Solution {

    public int minPatches(int[] nums, int n) {

        int count = 0, i = 0;

    for (long miss=1; miss <= n; count++){

        if(i < nums.length && nums[i] <= miss)

            miss = miss + nums[i++];

        else

            miss+=miss;

        }

    return count - i;

    }

}

/*Patching Array | Patches in array (SOLUTION 2)*/
/*
The variable max records the maximal value that can be formed by the elements in nums and patched numbers. If max is less than nums[i] - 1 which means we need to patch a new number, we then patch max + 1.

*/

public class Solution {

    public int minPatches(int[] nums, int n) {

       long max = 0;

    int cnt = 0;

    for (int i = 0; max < n;) {

        if (i >= nums.length || max < nums[i] - 1) {

            max += max + 1;

            cnt++;

        } else {

            max += nums[i];

            i++;

        }

    }

    return cnt;

    }

}
/*Flatten nested list iterator (DFS Solution)*/

/**

 * // This is the interface that allows for creating nested lists.

 * // You should not implement it, or speculate about its implementation

 * public interface NestedInteger {

 *

 *     // @return true if this NestedInteger holds a single integer, rather than a nested list.

 *     public boolean isInteger();

 *

 *     // @return the single integer that this NestedInteger holds, if it holds a single integer

 *     // Return null if this NestedInteger holds a nested list

 *     public Integer getInteger();

 *

 *     // @return the nested list that this NestedInteger holds, if it holds a nested list

 *     // Return null if this NestedInteger holds a single integer

 *     public List<NestedInteger> getList();

 * }

 */

public class NestedIterator implements Iterator<Integer> {

Stack<Iterator<NestedInteger>> stack = new Stack<>();

    Integer current = null;

    public NestedIterator(List<NestedInteger> nestedList) {

       if (nestedList != null) {

            stack.push(nestedList.iterator());

        }

    }



    @Override

    public Integer next() {

        return current;

    }



    @Override

    public boolean hasNext() {

          while (!stack.isEmpty()) {

            Iterator<NestedInteger> node = stack.peek();



            // This will clear out empty iterators.

            if (!node.hasNext()) {

                stack.pop();

                continue;

            }



            // If the value is an integer, done - load up and return.

            // Otherwise push the current list to the top of the stack and continue.

            NestedInteger value = node.next();

            if (value.isInteger()) {

                current = value.getInteger();

                return true;

            } else {

                stack.push(value.getList().iterator());

            }

        }



        return false;

    }

    

}



/**

 * Your NestedIterator object will be instantiated and called as such:

 * NestedIterator i = new NestedIterator(nestedList);

 * while (i.hasNext()) v[f()] = i.next();

 */
/*Search in a rotated sorted array 2 (duplicates are not allowed)*/
public class Solution {

    public int search(int[] nums, int target) {

        int start = 0;

        int end = nums.length - 1;

        while (start <= end){

            int mid = (start + end) / 2;

            if (nums[mid] == target)

                return mid;



            if (nums[start] <= nums[mid]){

                 if (target < nums[mid] && target >= nums[start]) 

                    end = mid - 1;

                 else

                    start = mid + 1;

            } 



            if (nums[mid] <= nums[end]){

                if (target > nums[mid] && target <= nums[end])

                    start = mid + 1;

                 else

                    end = mid - 1;

            }

        }

        return -1;

    }

}
/*Top K frequent elements */
//done using bucket sort
public class Solution {

    public List<Integer> topKFrequent(int[] nums, int k) {

        

    List<Integer>[] bucket = new List[nums.length + 1];

    Map<Integer, Integer> frequencyMap = new HashMap<Integer, Integer>();



    for (int n : nums) {

        frequencyMap.put(n, frequencyMap.getOrDefault(n, 0) + 1);

    }



    for (int key : frequencyMap.keySet()) {

        int frequency = frequencyMap.get(key);

        if (bucket[frequency] == null) {

            bucket[frequency] = new ArrayList<>();

        }

        bucket[frequency].add(key);

    }



    List<Integer> res = new ArrayList<>();



    for (int pos = bucket.length - 1; pos >= 0 && res.size() < k; pos--) {

        if (bucket[pos] != null) {

            res.addAll(bucket[pos]);

        }

    }

    return res;

    }

}
/*Integer break to maximize the sum (Read the explaination as well) (DP O(n))*/
//For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4)
/*
Why the max product of any n>4 must contain a factor of 3? 
1. It can't contain any factor x that is >= 5, o.w., we can further increase the max product by decomposing x, as the decomposed x when x>=5 is strictly greater than x;
2. Out of 1, 2, 3, 4, we know 1 won't be a factor of n when n>4, if n is an odd number, 3 must be there as a factor (2 and 4 can't add up to an odd number); 
3. Now say n is an even number (n>4) and only has factor of 2 and 4, we can always split a 6 to3X3, which is better than 2X2X2.
Therefore, the max product of any n (n>4) must contain a factor of 3. The recurrence relation holds.
Further, as it holds for all n (n>4), we will be only using 3 as factor for n (n>4), we keep subtracting 3 until n<=4, and adopt the remaining factor.

*/
public class Solution {

    public int integerBreak(int n) {

        if (n <= 2) return 1;

    if (n == 3) return 2;

    if (n == 4) return 4;

    int[] p = new int[n+1];

    p[2] = 2;

    p[3] = 3;

    p[4] = 4;

    for (int i = 5; i <= n; ++i) {

        p[i] = 3 * p[i-3];

    }

    return p[n];

    }

}
/* Integer break to maximize the sum (Read the explaination as well) (using pow function O(n))*/
/*
Given a number n lets say we have a possible product P = p1 * p2 * ... pk. Then we notice what would happen if we could break pi up into two more terms lets say one of the terms is 2 we would get the terms pi-2 and 2 so if 2(pi-2) > pi we would get a bigger product and this happens if pi > 4. since there is one other possible number less then 4 that is not 2 aka 3. Likewise for 3 if we instead breakup the one of the terms into pi-3 and 3 we would get a bigger product if 3*(pi-3) > pi which happens if pi > 4.5.
Hence we see that all of the terms in the product must be 2's and 3's. So we now just need to write n = a3 + b2 such that P = (3^a) * (2^b) is maximized. Hence we should favor more 3's then 2's in the product then 2's if possible.
So if n = a*3 then the answer will just be 3^a.
if n = a3 + 2 then the answer will be 2(3^a).
and if n = a3 + 22 then the answer will be 2 * 2 * 3^a
The above three cover all cases that n can be written as and the Math.pow() function takes O(log n) time to preform hence that is the running time.


*/
public class Solution {

    public int integerBreak(int n) {

         if(n == 2)

            return 1;

        else if(n == 3)

            return 2;

        else if(n%3 == 0)

            return (int)Math.pow(3, n/3);

        else if(n%3 == 1)

            return 2 * 2 * (int) Math.pow(3, (n - 4) / 3);

        else 

            return 2 * (int) Math.pow(3, n/3);

    }

}
/* Wildcard Matching
*/
/*
The basic idea is to have one pointer for the string and one pointer for the pattern. This algorithm iterates at most length(string) + length(pattern) times, for each iteration, at least one pointer advance one step

*/
public class Solution {

    public boolean isMatch(String str, String pattern) {

        int s = 0, p = 0, match = 0, starIdx = -1;            

        while (s < str.length()){

            // advancing both pointers

            if (p < pattern.length()  && (pattern.charAt(p) == '?' || str.charAt(s) == pattern.charAt(p))){

                s++;

                p++;

            }

            // * found, only advancing pattern pointer

            else if (p < pattern.length() && pattern.charAt(p) == '*'){

                starIdx = p;

                match = s;

                p++;

            }

           // last pattern pointer was *, advancing string pointer

            else if (starIdx != -1){

                p = starIdx + 1;

                match++;

                s = match;

            }

           //current pattern pointer is not star, last patter pointer was not *

          //characters do not match

            else return false;

        }



        //check for remaining characters in pattern

        while (p < pattern.length() && pattern.charAt(p) == '*')

            p++;



        return p == pattern.length();

    }

}
/*Self Crossing/ Line crossing*/


// Categorize the self-crossing scenarios, there are 3 of them: 

// 1. Fourth line crosses first line and works for fifth line crosses second line and so on...

// 2. Fifth line meets first line and works for the lines after

// 3. Sixth line crosses first line and works for the lines after

public class Solution {

    public boolean isSelfCrossing(int[] x) {

        int l = x.length;

        if(l <= 3) return false;



        for(int i = 3; i < l; i++){

            if(x[i] >= x[i-2] && x[i-1] <= x[i-3]) return true;  //Fourth line crosses first line and onward

            if(i >=4)

            {

                if(x[i-1] == x[i-3] && x[i] + x[i-4] >= x[i-2]) return true; // Fifth line meets first line and onward

            }

            if(i >=5)

            {

                if(x[i-2] - x[i-4] >= 0 && x[i] >= x[i-2] - x[i-4] && x[i-1] >= x[i-3] - x[i-5] && x[i-1] <= x[i-3]) return true;  // Sixth line crosses first line and onward

            }

        }

        return false;

    }

}
/*Palindrome Pairs
Given words = ["bat", "tab", "cat"]
Return [[0, 1], [1, 0]]
*/
/*
There are several cases to be considered that isPalindrome(s1 + s2):
Case1: If s1 is a blank string, then for any string that is palindrome s2, s1+s2 and s2+s1 are palindrome.
Case 2: If s2 is the reversing string of s1, then s1+s2 and s2+s1 are palindrome.
Case 3: If s1[0:cut] is palindrome and there exists s2 is the reversing string of s1[cut+1:] , then s2+s1 is palindrome.
Case 4: Similiar to case3. If s1[cut+1: ] is palindrome and there exists s2 is the reversing string of s1[0:cut] , then s1+s2 is palindrome.
To make the search faster, build a HashMap to store the String-idx pairs.
*/public class Solution {

    public List<List<Integer>> palindromePairs(String[] words) {

         List<List<Integer>> res = new ArrayList<List<Integer>>();

    if(words == null || words.length == 0){

        return res;

    }

    //build the map save the key-val pairs: String - idx

    HashMap<String, Integer> map = new HashMap<>();

    for(int i = 0; i < words.length; i++){

        map.put(words[i], i);

    }



    //special cases: "" can be combine with any palindrome string

    if(map.containsKey("")){

        int blankIdx = map.get("");

        for(int i = 0; i < words.length; i++){

            if(isPalindrome(words[i])){

                if(i == blankIdx) continue;

                res.add(Arrays.asList(blankIdx, i));

                res.add(Arrays.asList(i, blankIdx));

            }

        }

    }



    //find all string and reverse string pairs

    for(int i = 0; i < words.length; i++){

        String cur_r = reverseStr(words[i]);

        if(map.containsKey(cur_r)){

            int found = map.get(cur_r);

            if(found == i) continue;

            res.add(Arrays.asList(i, found));

        }

    }



    //find the pair s1, s2 that 

    //case1 : s1[0:cut] is palindrome and s1[cut+1:] = reverse(s2) => (s2, s1)

    //case2 : s1[cut+1:] is palindrome and s1[0:cut] = reverse(s2) => (s1, s2)

    for(int i = 0; i < words.length; i++){

        String cur = words[i];

        for(int cut = 1; cut < cur.length(); cut++){

            if(isPalindrome(cur.substring(0, cut))){

                String cut_r = reverseStr(cur.substring(cut));

                if(map.containsKey(cut_r)){

                    int found = map.get(cut_r);

                    if(found == i) continue;

                    res.add(Arrays.asList(found, i));

                }

            }

            if(isPalindrome(cur.substring(cut))){

                String cut_r = reverseStr(cur.substring(0, cut));

                if(map.containsKey(cut_r)){

                    int found = map.get(cut_r);

                    if(found == i) continue;

                    res.add(Arrays.asList(i, found));

                }

            }

        }

    }



    return res;

    }

    public String reverseStr(String str){

    StringBuilder sb= new StringBuilder(str);

    return sb.reverse().toString();

}



public boolean isPalindrome(String s){

    int i = 0;

    int j = s.length() - 1;

    while(i <= j){

        if(s.charAt(i) != s.charAt(j)){

            return false;

        }

        i++;

        j--;

    }

    return true;

}

}
/*Word Search 2 (using TRIE)*/
public class Solution {

    public class TrieNode{

        public boolean isWord = false;

        public TrieNode[] child = new TrieNode[26];

        public TrieNode(){



        }

    }



    TrieNode root = new TrieNode();

    boolean[][] flag;

    public List<String> findWords(char[][] board, String[] words) {

        Set<String> result = new HashSet<>();

        flag = new boolean[board.length][board[0].length];



        addToTrie(words);



        for(int i = 0; i < board.length; i++){

            for(int j = 0; j < board[0].length; j++){

                if(root.child[board[i][j] - 'a'] != null){

                    search(board, i, j, root, "", result);

                }

            }

        }



        return new LinkedList<>(result);

    }

    private void addToTrie(String[] words){

        for(String word: words){

            TrieNode node = root;

            for(int i = 0; i < word.length(); i++){

                char ch = word.charAt(i);

                if(node.child[ch - 'a'] == null){

                    node.child[ch - 'a'] = new TrieNode();

                }

                node = node.child[ch - 'a'];

            }

            node.isWord = true;

        }

    }

   private void search(char[][] board, int i, int j, TrieNode node, String word, Set<String> result){

        if(i >= board.length || i < 0 || j >= board[i].length || j < 0 || flag[i][j]){

            return;

        }



        if(node.child[board[i][j] - 'a'] == null){

            return;

        }



        flag[i][j] = true;

        node = node.child[board[i][j] - 'a'];

        if(node.isWord){

            result.add(word + board[i][j]);

        }



        search(board, i-1, j, node, word + board[i][j], result);

        search(board, i+1, j, node, word + board[i][j], result);

        search(board, i, j-1, node, word + board[i][j], result);

        search(board, i, j+1, node, word + board[i][j], result);



        flag[i][j] = false;

    }

}
/*Maximal Rectangles*/
/*

The DP solution proceeds row by row, starting from the first row. Let the maximal rectangle area at row i and column j be computed by [right(i,j) - left(i,j)]*height(i,j).



All the 3 variables left, right, and height can be determined by the information from previous row, and also information from the current row. So it can be regarded as a DP solution. The transition equations are:



left(i,j) = max(left(i-1,j), curleft), curleft can be determined from the current row

right(i,j) = min(right(i-1,j), curright), curright can be determined from the current row

height(i,j) = height(i-1,j) + 1, if matrix[i][j]=='1';

height(i,j) = 0, if matrix[i][j]=='0'

*/

public class Solution {

    public int maximalRectangle(char[][] matrix) {

       if (matrix == null || matrix.length == 0 || matrix[0].length == 0) { 

           return 0; 

       }

    int rows = matrix.length, cols = matrix[0].length;

    int[] left = new int[cols], right = new int[cols], top = new int[cols];

    Arrays.fill(left, cols); // max distance (inclusive) to left-most 1 at (y,x)

    Arrays.fill(right, cols); // max distance (inclusive) to right-most 1 at (y,x)

    Arrays.fill(top, 0); // max distance (inclusive) to top-most 1 at (y,x)

    int max = 0;

    for (int y = 0; y < rows; y++) {

        for (int x = 0; x < cols; x++) {

            if (matrix[y][x] == '1') { 

                top[x] += 1;

            }

            else { 

                top[x] = 0; 

                

            }

        }

        int l = 0; // max left distance so far

        for (int x = 0; x < cols; x++) {

            if (matrix[y][x] == '1') { 

                left[x] = Math.min(left[x], ++l); 

                

            }

            else { 

                left[x] = cols; l = 0; 

                

            }

        }

        int r = 0; // max right distance so far

        for (int x = cols-1; x >= 0; x--) {

            if (matrix[y][x] == '1') { 

                right[x] = Math.min(right[x], ++r); 

                

            }

            else { 

                right[x] = cols; r = 0; 

                

            }

        }

        for (int x = 0; x < cols; x++) {

            if (matrix[y][x] == '1') {

                // width should exclude double count of current element

                max = Math.max(max, (left[x]+right[x]-1)*top[x]);

            }

        }

    }

    return max;

    }

}
/*Reverse Linked List 2 (reverse a linked list from one position to another)*/
/**

 * Definition for singly-linked list.

 * public class ListNode {

 *     int val;

 *     ListNode next;

 *     ListNode(int x) { val = x; }

 * 

 */

 

 /*Simply just reverse the list along the way using 4 pointers: dummy, pre, start, then*/

public class Solution {

    public ListNode reverseBetween(ListNode head, int m, int n) {

        if(head == null) return null;

    ListNode dummy = new ListNode(0); // create a dummy node to mark the head of this list

    dummy.next = head;

    ListNode pre = dummy; // make a pointer pre as a marker for the node before reversing

    for(int i = 0; i<m-1; i++) pre = pre.next;



    ListNode start = pre.next; // a pointer to the beginning of a sub-list that will be reversed

    ListNode then = start.next; // a pointer to a node that will be reversed



    // 1 - 2 -3 - 4 - 5 ; m=2; n =4 ---> pre = 1, start = 2, then = 3

    // dummy-> 1 -> 2 -> 3 -> 4 -> 5



    for(int i=0; i<n-m; i++)

    {

        start.next = then.next;

        then.next = pre.next;

        pre.next = then;

        then = start.next;

    }



    // first reversing : dummy->1 - 3 - 2 - 4 - 5; pre = 1, start = 2, then = 4

    // second reversing: dummy->1 - 4 - 3 - 2 - 5; pre = 1, start = 2, then = 5 (finish)



    return dummy.next;



    }

}
/*Path Sum 2 | return all paths in a tree that equals the given sum*/
/**

 * Definition for a binary tree node.

 * public class TreeNode {

 *     int val;

 *     TreeNode left;

 *     TreeNode right;

 *     TreeNode(int x) { val = x; }

 * }

 */

public class Solution {

    private List<List<Integer>> result = new ArrayList<List<Integer>>();

    public List<List<Integer>> pathSum(TreeNode root, int sum) {

        helper(new ArrayList<Integer>(), root, sum);

    return result;

    }

    private void helper(List<Integer> list, TreeNode root, int sum) {

    if (root == null) return;

    list.add(root.val);

    sum -= root.val;

    if (root.left == null && root.right == null) {

        if (sum == 0) result.add(list);

        return;

    }

    helper(new ArrayList<Integer>(list), root.left, sum);

    helper(new ArrayList<Integer>(list), root.right, sum);

}

}
/*Unique Binary Search trees | all possible binary search tress for given nâ¦.i.e. between 1 and n*/
/**

 * Definition for a binary tree node.

 * public class TreeNode {

 *     int val;

 *     TreeNode left;

 *     TreeNode right;

 *     TreeNode(int x) { val = x; }

 * }

 */

 /*

 I start by noting that 1..n is the in-order traversal for any BST with nodes 1 to n. So if I pick i-th node as my root, the left subtree will contain elements 1 to (i-1), and the right subtree will contain elements (i+1) to n. I use recursive calls to get back all possible trees for left and right subtrees and combine them in all possible ways with the root.

 */

public class Solution {

    public List<TreeNode> generateTrees(int n) {

                return generateSubtrees(1,n);

    }

   private List<TreeNode> generateSubtrees(int s, int e) {

    List<TreeNode> res = new LinkedList<TreeNode>();

    if (s > e) {

        res.add(null); // empty tree

        return res;

    }



    for (int i = s; i <= e; ++i) {

        List<TreeNode> leftSubtrees = generateSubtrees(s, i - 1);

        List<TreeNode> rightSubtrees = generateSubtrees(i + 1, e);



        for (TreeNode left : leftSubtrees) {

            for (TreeNode right : rightSubtrees) {

                TreeNode root = new TreeNode(i);

                root.left = left;

                root.right = right;

                res.add(root);

            }

        }

    }

    return res;

}

}
/*LinkedList cycle 2 | Linked list cycle 2 | circular linked list | Starting node of cycle (With Explaination)*/
/**

 * Definition for singly-linked list.

 * class ListNode {

 *     int val;

 *     ListNode next;

 *     ListNode(int x) {

 *         val = x;

 *         next = null;

 *     }

 * }

 */

 /*

 EXPLAINATION:

 Definitions: Cycle = length of the cycle, if exists. C is the beginning of Cycle, S is the distance of slow pointer from C when slow pointer meets fast pointer.



Distance(slow) = C + S, Distance(fast) = 2 * Distance(slow) = 2 * (C + S). To let slow poiner meets fast pointer, only if fast pointer run 1 cycle more than slow pointer. Distance(fast) - Distance(slow) = Cycle => 2 * (C + S) - (C + S) = Cycle => C + S = Cycle

=> C = Cycle - S => This means if slow pointer runs (Cycle - S) more, it will reaches C. So at this time, if there's another point2 running from head => After C distance, point2 will meet slow pointer at C, where is the beginning of the cycle.

 */

public class Solution {

    public ListNode detectCycle(ListNode head) {

        ListNode slow = head;

                ListNode fast = head;



                while (fast!=null && fast.next!=null){

                    fast = fast.next.next;

                    slow = slow.next;



                    if (fast == slow){

                        ListNode slow2 = head; 

                        while (slow2 != slow){

                            slow = slow.next;

                            slow2 = slow2.next;

                        }

                        return slow;

                    }

                }

                return null;

    }

}
/*Odd Even Linked List | even linked list followed by odd linked list*/
/**

 * Definition for singly-linked list.

 * public class ListNode {

 *     int val;

 *     ListNode next;

 *     ListNode(int x) { val = x; }

 * }

 */

 

 /*

 EXPLAINATION:

 We just need to form a linked list of all odd nodes(X) and another linked list of all even nodes(Y). Afterwards, we link Y to the end of X, and return the head of X.

 */

public class Solution {

    public ListNode oddEvenList(ListNode head) {

        if(head == null || head.next == null){

        return head;

    }

    ListNode odd = head;

    ListNode even = head.next;

    ListNode even_head = head.next;

    while(even != null && even.next != null){

        odd.next = odd.next.next;

        even.next = even.next.next;

        odd = odd.next;

        even = even.next;

    }

    odd.next = even_head;

    return head;

    }

}
/*Different ways to add Parenthesis*/
public class Solution {

    public List<Integer> diffWaysToCompute(String input) {

        List<Integer> ret = new LinkedList<Integer>();

        for (int i=0; i<input.length(); i++) {

            if (input.charAt(i) == '-' ||

                input.charAt(i) == '*' ||

                input.charAt(i) == '+' ) {

                String part1 = input.substring(0, i);

                String part2 = input.substring(i+1);

                List<Integer> part1Ret = diffWaysToCompute(part1);

                List<Integer> part2Ret = diffWaysToCompute(part2);

                for (Integer p1 :   part1Ret) {

                    for (Integer p2 :   part2Ret) {

                        int c = 0;

                        switch (input.charAt(i)) {

                            case '+': c = p1+p2;

                                break;

                            case '-': c = p1-p2;

                                break;

                            case '*': c = p1*p2;

                                break;

                        }

                        ret.add(c);

                    }

                }

            }

        }

        if (ret.size() == 0) {

            ret.add(Integer.valueOf(input));

        }

        return ret;

    }

}
/*Search in a rotated sorted array 1 (Duplicates are allowed)*/
public class Solution {

    public boolean search(int[] nums, int target) {

        int start = 0, end = nums.length - 1, mid = -1;

        while(start <= end) {

            mid = (start + end) / 2;

            if (nums[mid] == target) {

                return true;

            }

            //If we know for sure right side is sorted or left side is unsorted

            if (nums[mid] < nums[end] || nums[mid] < nums[start]) {

                if (target > nums[mid] && target <= nums[end]) {

                    start = mid + 1;

                } else {

                    end = mid - 1;

                }

            //If we know for sure left side is sorted or right side is unsorted

            } else if (nums[mid] > nums[start] || nums[mid] > nums[end]) {

                if (target < nums[mid] && target >= nums[start]) {

                    end = mid - 1;

                } else {

                    start = mid + 1;

                }

            //If we get here, that means nums[start] == nums[mid] == nums[end], then shifting out

            //any of the two sides won't change the result but can help remove duplicate from

            //consideration, here we just use end-- but left++ works too

            } else {

                end--;

            }

        }



        return false;

    }

}
/*Count of smaller numbers after self | smaller numbers to the right */
/**/
/**/
/**/



/*Palindrome Permutation
Given a string, determine if a permutation of the string could form a palindrome.
For example,
"code" -> False, "aab" -> True, "carerac" -> True.

*/
public class Solution {
    public boolean canPermutePalindrome(String s) {
        if (s == null || s.length() == 0) { return true; }
        Map<Character, Integer> map = new HashMap<>();
        for (char c : s.toCharArray()) {
            if (!map.containsKey(c)) { map.put(c, 1); }
            else { map.put(c, map.get(c) + 1); }
        }
        int odd = 0;
        for (int val : map.values()) {
            if (odd > 1) { return false; }
            if (val % 2 != 0) { odd++; }
        }
        return odd <= 1;
    }
}
/*Flip Game
++ -- game
*/
public class Solution {
    public List<String> generatePossibleNextMoves(String s) {
        List<String> ret = new ArrayList<>();
        for (int i = 0; i < s.length() - 1; i++) {
            if (s.charAt(i) == s.charAt(i + 1) && s.charAt(i) == '+') {
                ret.add(s.substring(0, i) + "--" + s.substring(i + 2));
            }
        }
        return ret;
    }
}
/*Shortest word distance
Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.
For example,
Assume that words = ["practice", "makes", "perfect", "coding", "makes"].
Given word1 = âcodingâ, word2 = âpracticeâ, return 3.
Given word1 = "makes", word2 = "coding", return 1.
Note:
You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.

*/
public class Solution {
    public int shortestDistance(String[] words, String word1, String word2) {
        if (words == null) { return 0; }
        int pos1 = -1, pos2 = -1, min = Integer.MAX_VALUE;
        for (int i = 0; i < words.length; i++) {
            if (words[i].equals(word1)) { pos1 = i; }
            else if (words[i].equals(word2)) { pos2 = i; }
            if (pos1 != -1 && pos2 != -1) {
                if (Math.abs(pos1 - pos2) < min) {
                    min = Math.abs(pos1 - pos2);
                }
            }
        }
        return min;
    }
}
/*Meeting Rooms
Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), determine if a person could attend all meetings.
For example,
Given [[0, 30],[5, 10],[15, 20]],
return false.

*/
/**
 * Definition for an interval.
 * public class Interval {
 *     int start;
 *     int end;
 *     Interval() { start = 0; end = 0; }
 *     Interval(int s, int e) { start = s; end = e; }
 * }
 */
public class Solution {
    public boolean canAttendMeetings(Interval[] intervals) {
        if (intervals == null || intervals.length == 0) { return true; }
        // sort by start time
        Arrays.sort(intervals, new Comparator<Interval>(){
            public int compare(Interval x, Interval y) {
                return x.start - y.start;
            }
        });
        Interval prev = null;
        for (Interval cur : intervals) {
            if (prev != null && cur.start < prev.end) {
                return false;
            }
            prev = cur;
        }
        return true;
    }
}
/* Strobogrammatic Number
A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).
Write a function to determine if a number is strobogrammatic. The number is represented as a string.
For example, the numbers "69", "88", and "818" are all strobogrammatic.

*/
public class Solution {
    public boolean isStrobogrammatic(String num) {
        Map<Character, Character> pairs = new HashMap<Character, Character>() {
            {
                put('1', '1');
                put('6', '9');
                put('8', '8');
                put('9', '6');
                put('0', '0');
            }
        };
        int len = num.length();
        for (int i = 0; i < len / 2 + 1; i++) {
            char c = num.charAt(i);
            if (!pairs.containsKey(c)) { return false; }
            if (pairs.get(c) != num.charAt(len - i - 1)) { return false; }
        }
        return true;
    }
}
/* Closest Binary Search Tree Value
Given a non-empty binary search tree and a target value, find the value in the BST that is closest to the target.
Note:
â¢	Given target value is a floating point.
â¢	You are guaranteed to have only one unique value in the BST that is closest to the target.

*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int closestValue(TreeNode root, double target) {
        int closest = root.val;
        TreeNode tmp = root;
        while (tmp != null) {
            closest = Math.abs(tmp.val - target) < Math.abs(closest - target) ? tmp.val : closest;
            if (closest == target) { return closest; }
            tmp = target > tmp.val ? tmp.right : tmp.left;
        }
        return closest;
    }
}
/* Group Shifted Strings
Given a string, we can "shift" each of its letter to its successive letter, for example: "abc" -> "bcd". We can keep "shifting" which forms the sequence:
"abc" -> "bcd" -> ... -> "xyz"
Given a list of strings which contains only lowercase alphabets, group all strings that belong to the same shifting sequence.
For example, given: ["abc", "bcd", "acef", "xyz", "az", "ba", "a", "z"], 
Return:
[
  ["abc","bcd","xyz"],
  ["az","ba"],
  ["acef"],
  ["a","z"]
]

*/
public class Solution {
    public List<List<String>> groupStrings(String[] strings) {
        List<List<String>> groups = new ArrayList<>();
    if (strings == null) { return groups; }

    Map<String, List<String>> map = new HashMap<>();
    for (String str : strings) {
      char[] chs = str.toCharArray();
       int offset = chs[0] - 'a';
      for (int i = 0; i < chs.length; i++) {
        char c = (char)(chs[i] - offset);
        chs[i] = c < 'a' ? (char)(c + 26) : c;
      }

       String key = new String(chs);
      List<String> list = map.get(key);
      if (list == null) {
        list = new ArrayList<String>();
        map.put(key, list);
      }
      list.add(str);

    }
    for (String key : map.keySet()) {
      List<String> list = map.get(key);
      Collections.sort(list);
      groups.add(list);
    }
    return groups;

    }
}
/* Paint Fence
There is a fence with n posts, each post can be painted with one of the k colors.
You have to paint all the posts such that no more than two adjacent fence posts have the same color.
Return the total number of ways you can paint the fence.
Note:
n and k are non-negative integers.

*/
public class Solution {
    public int numWays(int n, int k) {
        if (n == 0) { return 0; }
        if (n == 1) { return k; }
        int numDiffColor = k * (k - 1), numSameColor = k;
        for (int i = 2; i < n; i++) {
            int tmp = numDiffColor;
            numDiffColor = (numDiffColor + numSameColor) * (k - 1);
            numSameColor = tmp;
        }
        return numSameColor + numDiffColor;
    }
}
/* Read N Characters Given Read4
The API: int read4(char *buf) reads 4 characters at a time from a file.
The return value is the actual number of characters read. For example, it returns 3 if there is only 3 characters left in the file.
By using the read4 API, implement the function int read(char *buf, int n) that reads n characters from the file.
Note:
The read function will only be called once for each test case.

*/
*********FIRST SOLUTION************
/* The read4 API is defined in the parent class Reader4.
      int read4(char[] buf); */

public class Solution extends Reader4 {
    /**
     * @param buf Destination buffer
     * @param n   Maximum number of characters to read
     * @return    The number of characters read
     */
    public int read(char[] buf, int n) {
        char[] tmp = new char[4];
        int i = 0, num = 4;
        while(i < n && num == 4){
            num = read4(tmp);
            for(int j = 0; j < num && i < n; j++){
                buf[i++] = tmp[j];
            }
        }
        return i;
    }
}
*********************SECOND SOLUTION*********************
/* The read4 API is defined in the parent class Reader4.
      int read4(char[] buf); */

public class Solution extends Reader4 {
    /**
     * @param buf Destination buffer
     * @param n   Maximum number of characters to read
     * @return    The number of characters read
     */
    public int read(char[] buf, int n) {
        int readChars = 0;
    boolean endOfFile = false;
  
    while (readChars < n && !endOfFile) {
      char[] buffer = new char[4];
      int count = read4(buffer);
      if (count < 4) { endOfFile = true; }
      count = Math.min(count, n - readChars);
      for (int i = 0; i < count; i++) { buf[readChars++] = buffer[i]; }
      // readChars += count;
    }
    return readChars;
    }
}
/*Two Sum III - Data structure design
Design and implement a TwoSum class. It should support the following operations: add and find.
add - Add the number to an internal data structure.
find - Find if there exists any pair of numbers which sum is equal to the value.
For example,
add(1); add(3); add(5);
find(4) -> true
find(7) -> false

*/
public class TwoSum {
    private Map<Integer,Integer> map = new HashMap<>();

    // Add the number to an internal data structure.
	public void add(int number) {
	    map.put(number, map.containsKey(number)? map.get(number) + 1: 1);
	}

    // Find if there exists any pair of numbers which sum is equal to the value.
	public boolean find(int value) {
	    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
	        int i = entry.getKey();
	        int j = value - i;
	        if ((i == j && entry.getValue() > 1) ||( i!=j && map.containsKey(j))){
	            return true;
	        }
	    }
	    return false;
	}
}


// Your TwoSum object will be instantiated and called as such:
// TwoSum twoSum = new TwoSum();
// twoSum.add(number);
// twoSum.find(value);

/*Unique Word Abbreviation
An abbreviation of a word follows the form <first letter><number><last letter>. Below are some examples of word abbreviations:
a) it                      --> it    (no abbreviation)

     1
b) d|o|g                   --> d1g

              1    1  1
     1---5----0----5--8
c) i|nternationalizatio|n  --> i18n

              1
     1---5----0
d) l|ocalizatio|n          --> l10n
Assume you have a dictionary and given a word, find whether its abbreviation is unique in the dictionary. A word's abbreviation is unique if no other word from the dictionary has the same abbreviation.
Example: 
Given dictionary = [ "deer", "door", "cake", "card" ]

isUnique("dear") -> false
isUnique("cart") -> true
isUnique("cane") -> false
isUnique("make") -> true

*/
public class ValidWordAbbr {
  Map<String, String> map = new HashMap<>();
  
  public ValidWordAbbr(String[] dictionary) {
    for (String str : dictionary) {
      String abbr = getAbbr(str);
      if (map.containsKey(abbr)) { map.put(abbr, null); }  // not unique
      else { map.put(abbr, str); }
    }
  }
  
  public boolean isUnique(String word) {
    String key = getAbbr(word);
    return !map.containsKey(key) || word.equals(map.get(key));
  }

  private String getAbbr(String word) {
    if (word == null) { return word; }
    int n = word.length();
    return word.charAt(0) + (n <= 2 ? "" : Integer.toString(n - 2)) + word.charAt(n - 1);
  }
}


// Your ValidWordAbbr object will be instantiated and called as such:
// ValidWordAbbr vwa = new ValidWordAbbr(dictionary);
// vwa.isUnique("Word");
// vwa.isUnique("anotherWord");

/*Wiggle Sort
Given an unsorted array nums, reorder it in-place such that nums[0] <= nums[1] >= nums[2] <= nums[3]....
For example, given nums = [3, 5, 2, 1, 6, 4], one possible answer is [1, 6, 2, 5, 3, 4].
*/
*********FIRST SOLUTION************
public class Solution {
    public void wiggleSort(int[] nums) {
        if (nums == null || nums.length == 0) { return; }
        Arrays.sort(nums);
        for (int i = 1; i < nums.length - 1; i += 2) {
            int tmp = nums[i];
            nums[i] = nums[i + 1];
            nums[i + 1] = tmp;
        }
    }
}
*********SECOND SOLUTION (BEST SOLUTION)************
public class Solution {
    public void wiggleSort(int[] nums) {
        if (nums == null) { return; }
        for (int i = 1; i < nums.length; i++) {
            int tmp = nums[i - 1];
            if ((i % 2 == 1) == (tmp > nums[i])) {
                nums[i - 1] = nums[i];
                nums[i] = tmp;
            }
        }
    }
}


/*Reverse LinkedList / Reverse Linked List / Reverse List RECURSIVELY*/
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode reverseList(ListNode head) {
       if(head == null ||head.next == null){
            return head;
        }

        ListNode root = reverseList(head.next);

        head.next.next = head;
        head.next = null;
        return root;
    }
}
/*Reverse LinkedList / Reverse Linked List / Reverse List ITERATIVELY*/
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode reverseList(ListNode head) {
         ListNode prev = null;
    while (head != null) {
        ListNode temp = head.next;
        head.next = prev;
        prev = head;
        head = temp;
    }
    return prev;
    }
}
/*Median of 2 sorted arrays*/
public class Solution {
    public double findMedianSortedArrays(int[] A, int[] B) {
        int n = A.length;
    int m = B.length;
    // the following call is to make sure len(A) <= len(B).
    // yes, it calls itself, but at most once, shouldn't be
    // consider a recursive solution
    if (n > m)
        return findMedianSortedArrays(B, A);

    // now, do binary search
    int k = (n + m - 1) / 2;
    int l = 0, r = Math.min(k, n); // r is n, NOT n-1, this is important!!
    while (l < r) {
        int midA = (l + r) / 2;
        int midB = k - midA;
        if (A[midA] < B[midB])
            l = midA + 1;
        else
            r = midA;
    }

    // after binary search, we almost get the median because it must be between
    // these 4 numbers: A[l-1], A[l], B[k-l], and B[k-l+1] 

    // if (n+m) is odd, the median is the larger one between A[l-1] and B[k-l].
    // and there are some corner cases we need to take care of.
    int a = Math.max(l > 0 ? A[l - 1] : Integer.MIN_VALUE, k - l >= 0 ? B[k - l] : Integer.MIN_VALUE);
    if (((n + m) & 1) == 1)
        return (double) a;

    // if (n+m) is even, the median can be calculated by 
    //      median = (max(A[l-1], B[k-l]) + min(A[l], B[k-l+1]) / 2.0
    // also, there are some corner cases to take care of.
    int b = Math.min(l < n ? A[l] : Integer.MAX_VALUE, k - l + 1 < m ? B[k - l + 1] : Integer.MAX_VALUE);
    return (a + b) / 2.0;
    }
}
/*Median of array*/
Arrays.sort(numArray);
double median;
if (numArray.length % 2 == 0)
    median = ((double)numArray[numArray.length/2] + (double)numArray[numArray.length/2 - 1])/2;
else
    median = (double) numArray[numArray.length/2];

/*candy / candies distribution to the candidates
This solution picks each element from the input array only once. First, we give a candy to the first child. Then for each child we have three cases:
1.	His/her rating is equal to the previous one -> give 1 candy.
2.	His/her rating is greater than the previous one -> give him (previous + 1) candies.
3.	His/her rating is less than the previous one -> don't know what to do yet, let's just count the number of such consequent cases.
When we enter 1 or 2 condition we can check our count from 3. If it's not zero then we know that we were descending before and we have everything to update our total candies amount: number of children in descending sequence of raitings - coundDown, number of candies given at peak - prev (we don't update prev when descending). Total number of candies for "descending" children can be found through arithmetic progression formula (1+2+...+countDown). Plus we need to update our peak child if his number of candies is less then or equal to countDown.
*/
public class Solution {
    public int candy(int[] ratings) {
         if (ratings == null || ratings.length == 0) return 0;
        int total = 1, prev = 1, countDown = 0;
        for (int i = 1; i < ratings.length; i++) {
            if (ratings[i] >= ratings[i-1]) {
                if (countDown > 0) {
                    total += countDown*(countDown+1)/2; // arithmetic progression
                    if (countDown >= prev) total += countDown - prev + 1;
                    countDown = 0;
                    prev = 1;
                }
                prev = ratings[i] == ratings[i-1] ? 1 : prev+1;
                total += prev;
            } else countDown++;
        }
        if (countDown > 0) { // if we were descending at the end
            total += countDown*(countDown+1)/2;
            if (countDown >= prev) total += countDown - prev + 1;
        }
        return total;
    }
}
/*JUMP Game / jump the maximum in array to reach the end*/
public class Solution {
    public int jump(int[] A) {
         int count = 0, max = 0;
    for (int i = 0, nextMax = 0; i <= max && i < A.length - 1; i++) {
        nextMax = Math.max(nextMax, i + A[i]);
        if (i == max) {
            max = nextMax;
            count++;
        }
    }
    // if there is no way to get to the end, return -1
    return max >= A.length - 1 ? count : -1;
    }
}
/*Number of substrings of a String*/
public int subStrings(String c)
{
		int len=c.length;
		int maxlength=0;
		int start=0;
		int count=0;
		boolean [][]temp=new boolean[len][len];
		
		for(int i=0;i<len;i++){
			temp[i][i]=true;
		}
		
		for(int i=0;i<len-1;i++){
			if(c[i]==c[i+1]){
				temp[i][i+1]=true;
				start=i;
				maxlength=2;
			}
		}
		
		for(int  j=2;j<len;j++){
			for(int i=0,k=j;k<len;i++,k++){
				if(c[i]==c[k] && temp[i+1][k-1]==true){
					temp[i][k]=true;					
					if(k-i+1>maxlength){
					start=i;
					maxlength=k-i+1;
					}					
				}
			}
		}
		
		/*for(int i=start;i<=start+maxlength-1;i++){
			System.out.print(c[i]);
		}*/
		
		for(int i=0;i<temp.length;i++){
			for(int j=i;j<temp.length;j++){
				
				if(temp[i][j]==true)
					count++;
			}
		}
		
		System.out.println(count);
		
		return maxlength;
}
/*check if string is palindrome with other characters in middle*/
class Solution {
  public static void main(String[] args) {
    String s ="0000000";
    
    boolean flag=false ;
   int start =0;
   int end = s.length()-1;
  while(start<end)
  {
    if(Character.isLetter(s.charAt(start))&&Character.isLetter(s.charAt(end)))
    {
        //System.out.println("First condition"); 
        if(Character.toLowerCase(s.charAt(start))!=Character.toLowerCase(s.charAt(end)))
        {  
         flag=true;
          break;
        }
      start++;
      end--;
    }else if(!Character.isLetter(s.charAt(start))){
       // System.out.println("second condition");
        start++; 
    }
    else if(!Character.isLetter(s.charAt(end))){
       // System.out.println("third condition");
      end--;
    }
    }
  if(flag)
    System.out.println("False");
  else
    System.out.println("True");
  }
}
/*Ternary tree*/
/*
// The following definitions of Tree and Node are provided.
// insert and delete will be methods of class Tree.

public class Tree {
    private class Node {
        private int val;
        private Node left = null;
        private Node right = null;
        private Node mid = null;

        public Node(int val) {
            this.val = val;
        }
    }

    private Node root;
*/

    /* 
     * Please complete this method.
     * Inserts val into the tree. There is no need to rebalance the tree.
     */
    public void insert(int val) {
            Node newNode = new Node(val);
            //wNode.val = val;
            if(root==null)
            {
                root = newNode;
                return;
            }
            else
            {
                Node tempNode = root;
                while(tempNode!=null){  
                   if(tempNode.val > val)
                       if(tempNode.left == null)
                       {
                            tempNode.left = newNode;
                            break;
                       }
                       else
                            tempNode = tempNode.left;
                   else if(tempNode.val < val)
                       if(tempNode.right == null)
                       {
                           tempNode.right = newNode;
                            break;
                       }
                       else
                            tempNode = tempNode.right;
                   else
                   {
                       if(tempNode.mid == null)
                       {
                           tempNode.mid = newNode;
                            break;
                       }
                       else
                            tempNode = tempNode.mid;   
                   }
                }
            }

    }

    /* 
     * Please complete this method.
     * Deletes only one instance of val from the tree.
     * If val does not exist in the tree, do nothing.
     * There is no need to rebalance the tree.
     */
    public void delete(int val) {
        Node currentNode = root;
        Node parent=null;     // parent of the node being deleted
        boolean LorR=false;  // flag to indicate if there is Left or Right child
        boolean firstLoop=true;
        if(root==null)
            return;
        while(currentNode!=null)
        {
            if(currentNode.left == null && currentNode.right==null && currentNode.mid==null)
            {
                if(currentNode.val==val)
                {
                    currentNode = null;
                    return;
                }
                else
                    return;
            }
            else if(val<currentNode.val)
            {
                parent=currentNode;
                LorR=false;
                currentNode=currentNode.left;
            }
            else if(val>currentNode.val)
            {
                parent=currentNode;
                LorR=true;
                currentNode=currentNode.right;
            }	
            else if(currentNode.val==val)
            {
                if(currentNode.mid!=null)
                  {
                        while(currentNode.mid!=null)
                        {
                            parent=currentNode;
                            currentNode=currentNode.mid;
                        }
                        parent.mid=null;
                  }
                 else if(currentNode.left==null && currentNode.right!=null)
                 {
                     if(firstLoop==true)
                        root=currentNode.right;
                     else if(LorR==false)
                        parent.left=currentNode.right;
                     else
                         parent.right=currentNode.right;                     
                 }
                 else if(currentNode.right==null && currentNode.left!=null)
                 {
                     if(firstLoop==true)
                        root=currentNode.left;
                     else if(LorR==false)
                        parent.left=currentNode.left;
                     else
                         parent.right=currentNode.left;                     
                 }
                 else if(currentNode.left==null && currentNode.right==null)
                 {
                     if(firstLoop==true)
                        root=null;
                     else if(LorR==false)
                        parent.left=null;
                     else
                        parent.right=null;                     
                 }
                else 
                  {
                        Node node = currentNode.left;
                        if(node.right==null)
                        {
                            node.right=currentNode.right;
                            currentNode=node;
                        }
                        else
                        {
                            Node parentNode=currentNode;  //parent of the rightmost node
                            
                            while(node.right!=null)
                            {   
                                parentNode=node;
                                node=node.right;
                            }
                            parentNode.right=node.left;
                            node.left=currentNode.left;
                            node.right=currentNode.left;
                            if(firstLoop==true)
                                root=node;
                            else if(LorR==false)
                            parent.left=node;
                            else
                               parent.right=node;
                      }   
                  }
            }
            else
                return;
        firstLoop=false;
        }
    }
/*Given a particular node, return the successor of that node in an inorder traversal / inorder successor given its given parent of node
Node {
    Node left;
    Node right;
    Node parent;
    Object data;
}
*/
Node inOrderSuccessor (Node node)
       {
           if(node.right!=null)
              {
                  Node nodeR = node.right; 
                  while(nodeR.left!=null)
                      nodeR=nodeR.left;
                  return nodeR;
              }
            parent = node.parent;
           
    while (parent != null) {
        if (parent.left == node) {
            break;
        } else {
            node = parent;
            parent = parent.parent;
        }
    }
    return parent
           
           
       }


/*Edit Distance / minimum distance required to convert one word to other 
Basically the idea is to build up the solution step by step and keep track of the previous optimal solution in a 2D array. In this 2D array dp, dp[i][j] means the operation needed to transform word1(0, i) to word2(0,j).
There can be three conditions:
1, word1[i] == word2[j] : then no operation needed. dp[i][j] == dp[i-1][j-1]
2, Do one operation on word1[i-1][j]. dp[i][j] = dp[i-1][j] + 1
3, Do one operation on word2[i][j-1]. dp[i][j] = dp[i][j-1] + 1
for 2 and 3, the reason it works is that we know the optimal ways to transfrom word1(0,i) to word2(0,j-1) and word1(0,i-1) to word(0,j) ( Delete ("abc" to "ab") or Insert ("ab" to "abc") ). Now all we need to one more operation.
*/
public class Solution {
    public int minDistance(String word1, String word2) {
         if (word1.equals(word2)) {
        return 0;
    }
    if (word1.length() == 0 || word2.length() == 0) {
        return Math.abs(word1.length() - word2.length());
    }
    int[][] dp = new int[word1.length() + 1][word2.length() + 1];
    for (int i = 0; i <= word1.length(); i++) {
        dp[i][0] = i;
    }
    for (int i = 0; i <= word2.length(); i++) {
        dp[0][i] = i;
    }
    for (int i = 1; i <= word1.length(); i++) {
        for (int j = 1; j <= word2.length(); j++) {
            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i][j-1])) + 1;
            }
        }
    }
    return dp[word1.length()][word2.length()];
    }
}

/*Reverse nodes in group of k in a list*/

/*Insert Interval and merge wherever necessary*/
/**
 * Definition for an interval.
 * public class Interval {
 *     int start;
 *     int end;
 *     Interval() { start = 0; end = 0; }
 *     Interval(int s, int e) { start = s; end = e; }
 * }
 */
public class Solution {
    public List<Interval> insert(List<Interval> intervals, Interval newInterval) {
         List<Interval> result = new ArrayList<Interval>();
    for (Interval i : intervals) 
    {
        if (newInterval == null || i.end < newInterval.start)
            result.add(i);
        else if (i.start > newInterval.end) 
        {
            result.add(newInterval);
            result.add(i);
            newInterval = null;
        } 
        else 
        {
            newInterval.start = Math.min(newInterval.start, i.start);
            newInterval.end = Math.max(newInterval.end, i.end);
        }
    }
    if (newInterval != null)
        result.add(newInterval);
    return result;
    }
}
/*Merge Intervals
The idea is to sort the intervals by their starting points. Then, we take the first interval and compare its end with the next intervals starts. As long as they overlap, we update the end to be the max end of the overlapping intervals. Once we find a non overlapping interval, we can add the previous "extended" interval and start over.
Sorting takes O(n log(n)) and merging the intervals takes O(n). So, the resulting algorithm takes O(n log(n)).
I used an anonymous comparator and a for-each loop to try to keep the code clean and simple.
*/
/**
 * Definition for an interval.
 * public class Interval {
 *     int start;
 *     int end;
 *     Interval() { start = 0; end = 0; }
 *     Interval(int s, int e) { start = s; end = e; }
 * }
 */
public class Solution {
    public List<Interval> merge(List<Interval> intervals) {
         if (intervals.size() <= 1)
        return intervals;

    // Sort by ascending starting point using an anonymous Comparator
    Collections.sort(intervals, new Comparator<Interval>() {
        @Override
        public int compare(Interval i1, Interval i2) {
            return Integer.compare(i1.start, i2.start);
        }
    });

    List<Interval> result = new LinkedList<Interval>();
    int start = intervals.get(0).start;
    int end = intervals.get(0).end;

    for (Interval interval : intervals) {
        if (interval.start <= end) // Overlapping intervals, move the end if needed
            end = Math.max(end, interval.end);
        else {                     // Disjoint intervals, add the previous one and reset bounds
            result.add(new Interval(start, end));
            start = interval.start;
            end = interval.end;
        }
    }

    // Add the last interval
    result.add(new Interval(start, end));
    return result;
    }
}
/*Word Break / If a word can be segmented into one or more dictionary words.*/
public class Solution {
    public boolean wordBreak(String s, Set<String> wordDict) {
        if (s == null && wordDict == null)
        return true;
    if (s == null || wordDict == null)
        return false;
    //dp[i] represents if s.substring(0, i+1) is wordbreakable.
    boolean[] dp = new boolean[s.length()+1];
    dp[0] = true;
    for (int i = 1; i <= s.length(); i++) {
        for (int j = 0; j < i; j++) {
            if (dp[j] && wordDict.contains(s.substring(j, i))) {
                dp[i] = true;
                break;
            }
        }
    }
    return dp[s.length()];
    }
}
/*Word Break II / a word can be segmented to form a sentence SOLUTION I USING DFS
Using DFS directly will lead to TLE, so I just used HashMap to save the previous results to prune duplicated branches
*/
public class Solution {
    public List<String> wordBreak(String s, Set<String> wordDict) {
         return DFS(s, wordDict, new HashMap<String, LinkedList<String>>());
    }
    // DFS function returns an array including all substrings derived from s.
List<String> DFS(String s, Set<String> wordDict, HashMap<String, LinkedList<String>>map) {
    if (map.containsKey(s)) 
        return map.get(s);

    LinkedList<String>res = new LinkedList<String>();     
    if (s.length() == 0) {
        res.add("");
        return res;
    }               
    for (String word : wordDict) {
        if (s.startsWith(word)) {
            List<String>sublist = DFS(s.substring(word.length()), wordDict, map);
            for (String sub : sublist) 
                res.add(word + (sub.isEmpty() ? "" : " ") + sub);               
        }
    }       
    map.put(s, res);
    return res;
}  
}
/* Word Break II / a word can be segmented to form a sentence SOLUTION II USING SEARCH*/
public class Solution {
    public List<String> wordBreak(String s, Set<String> dict) {
    List<String> result = new ArrayList<String>();
    for(int j = s.length() - 1; j >= 0; j--){
        if(dict.contains(s.substring(j)))
            break;
        else{
            if(j == 0)
                return result;
        }
    }
    for(int i = 0; i < s.length()-1; i++)
    {
        if(dict.contains(s.substring(0,i+1)))
        {
            List<String> strs = wordBreak(s.substring(i+1,s.length()),dict);
            if(strs.size() != 0)
                for(Iterator<String> it = strs.iterator();it.hasNext();)
                {
                    result.add(s.substring(0,i+1)+" "+it.next());
                }
        }
    }
    if(dict.contains(s)) result.add(s);
    return result;
    }  
}
/*Implement Trie
With my solution I took the simple approach of giving each TrieNode a 26 element array of each possible child node it may have. I only gave 26 children nodes because we are only working with lowercase 'a' - 'z'. If you are uncertain why I made the root of my Trie an empty character this is a standard/typical approach for building out a Trie it is somewhat arbitrary what the root node is.
For insert I used the following algorithm. Loop through each character in the word being inserted check if the character is a child node of the current TrieNode i.e. check if the array has a populated value in the index of this character. If the current character ISN'T a child node of my current node add this character representation to the corresponding index location then set current node equal to the child that was added. However if the current character IS a child of the current node only set current node equal to the child. After evaluating the entire String the Node we left off on is marked as a word this allows our Trie to know which words exist in our "dictionary"
For search I simply navigate through the Trie if I discover the current character isn't in the Trie I return false. After checking each Char in the String I check to see if the Node I left off on was marked as a word returning the result.
Starts with is identical to search except it doesn't matter if the Node I left off was marked as a word or not if entire string evaluated i always return true;
*/
class TrieNode {
     private final int R = 26;
    private final TrieNode[] children;
    private String item;
    // Initialize your data structure here.
    public TrieNode() {
             children = new TrieNode[R];
        item = "";
    }

    public String getItem() {
        return item;
    }

    public void setItem(String item) {
        this.item = item;
    }

    public TrieNode[] getChildren() {
        return children;
    }

    public TrieNode getChild(int i) {
        if (i >= 26 || i < 0) throw new IllegalArgumentException();
        return children[i];
    }

    public void setChild(int i, TrieNode node) {
        children[i] = node;
    }
    
}

public class Trie {
    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }

    // Inserts a word into the trie.
    public void insert(String word) {
         TrieNode curr = root;
        for (char c : word.toCharArray()) {
            if (curr.getChild(c - 'a') == null) curr.setChild(c - 'a', new TrieNode());
            curr = curr.getChild(c - 'a');
        }
        curr.setItem(word);
    }

    // Returns if the word is in the trie.
    public boolean search(String word) {
        TrieNode curr = root;
        for (char c : word.toCharArray()) {
            if (curr.getChild(c - 'a') == null) return false;
            curr = curr.getChild(c - 'a');
        }
        return curr.getItem().equals(word);
    
    }

    // Returns if there is any word in the trie
    // that starts with the given prefix.
    public boolean startsWith(String prefix) {
        TrieNode curr = root;
        for (char c : prefix.toCharArray()) {
            if (curr.getChild(c - 'a') == null) return false;
            curr = curr.getChild(c - 'a');
        }
        return true;
    }
}

// Your Trie object will be instantiated and called as such:
// Trie trie = new Trie();
// trie.insert("somestring");
// trie.search("key");
/*Unique Binary Search Trees / Unique BSTs*/
/**
 * Taking 1~n as root respectively:
 *      1 as root: # of trees = F(0) * F(n-1)  // F(0) == 1
 *      2 as root: # of trees = F(1) * F(n-2) 
 *      3 as root: # of trees = F(2) * F(n-3)
 *      ...
 *      n-1 as root: # of trees = F(n-2) * F(1)
 *      n as root:   # of trees = F(n-1) * F(0)
 *
 * So, the formulation is:
 *      F(n) = F(0) * F(n-1) + F(1) * F(n-2) + F(2) * F(n-3) + ... + F(n-2) * F(1) + F(n-1) * F(0)
 */
 
public class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n+1];
    dp[0] = dp[1] = 1;
    for (int i=2; i<=n; i++) {
        dp[i] = 0;
        for (int j=1; j<=i; j++) {
            dp[i] += dp[j-1] * dp[i-j];
        }
    }
    return dp[n];
    }
}
/* Letter Combinations of a Phone Number / combination of words from telephone number RECURSIVE
method combine is to add new letters to old list, using 2 for-loop.
for example:
gave digits = "23"
i=0 -> result=combine("abc", [""]) ---> [a,b,c];
i=1 -> result=combine("def", [a,b,c]) ---> [ad,bd,cd, ae,be,ce, af,bf,cf];
*/
public class Solution {
    public List<String> letterCombinations(String digits) {
        String digitletter[] = {"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
            List<String> result = new ArrayList<String>();

            if (digits.length()==0) return result;

            result.add("");
            for (int i=0; i<digits.length(); i++) 
                result = combine(digitletter[digits.charAt(i)-'0'],result);

            return result;   
    }
    
     public static List<String> combine(String digit, List<String> l) {
            List<String> result = new ArrayList<String>();

            for (int i=0; i<digit.length(); i++) 
                for (String x : l) 
                    result.add(x+digit.charAt(i));

            return result;
        }
}
/* Letter Combinations of a Phone Number / combination of words from telephone number ITERATIVE
*/
public class Solution {
    public List<String> letterCombinations(String digits) {
         List<String> res = new ArrayList<String>();
        if (digits == null || digits.length() == 0) return res;
        res.add("");
        String[] mapping = new String[] {"0", "1", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
        for (int i = 0; i < digits.length(); i++){
            List<String> newRes = new ArrayList<String>();
            char[] charArray= mapping[digits.charAt(i) - '0'].toCharArray();
            for (String str : res){
                for (char c : charArray){
                    newRes.add(new String(str + c));
                }
            }
            res = newRes;
        }
        return res;
        }
}
/*Expression add operators / combinations of operator to find out the target value.
This problem has a lot of edge cases to be considered:
1.	overflow: we use a long type once it is larger than Integer.MAX_VALUE or minimum, we get over it.
2.	0 sequence: because we can't have numbers with multiple digits started with zero, we have to deal with it too.
3.	a little trick is that we should save the value that is to be multiplied in the next recursion.
*/
public class Solution {
    
    public List<String> addOperators(String num, int target) {
      List<String> rst = new ArrayList<String>();
        if(num == null || num.length() == 0) return rst;
        helper(rst, "", num, target, 0, 0, 0);
        return rst;
    }
    public void helper(List<String> rst, String path, String num, int target, int pos, long eval, long multed){
        if(pos == num.length()){
            if(target == eval)
                rst.add(path);
            return;
        }
        for(int i = pos; i < num.length(); i++){
            if(i != pos && num.charAt(pos) == '0') break;
            long cur = Long.parseLong(num.substring(pos, i + 1));
            if(pos == 0){
                helper(rst, path + cur, num, target, i + 1, cur, cur);
            }
            else{
                helper(rst, path + "+" + cur, num, target, i + 1, eval + cur , cur);

                helper(rst, path + "-" + cur, num, target, i + 1, eval -cur, -cur);

                helper(rst, path + "*" + cur, num, target, i + 1, eval - multed + multed * cur, multed * cur );
            }
        }
}
}


/*void generateNextPalindromeUtil (int num[], int n )
{
    // find the index of mid digit
    int mid = n/2;
 
    // A bool variable to check if copy of left side to right is sufficient or not
    bool leftsmaller = false;
 
    // end of left side is always 'mid -1'
    int i = mid - 1;
 
    // Begining of right side depends if n is odd or even
    int j = (n % 2)? mid + 1 : mid;
 
   // Initially, ignore the middle same digits 
    while (i >= 0 && num[i] == num[j])
        i--,j++;
 
    // Find if the middle digit(s) need to be incremented or not (or copying left 
    // side is not sufficient)
    if ( i < 0 || num[i] < num[j])
        leftsmaller = true;
 
    // Copy the mirror of left to tight
    while (i >= 0)
    {
        num[j] = num[i];
        j++;
        i--;
    }
 
    // Handle the case where middle digit(s) must be incremented. 
    // This part of code is for CASE 1 and CASE 2.2
    if (leftsmaller == true)
    {
        int carry = 1;
        i = mid - 1;
 
        // If there are odd digits, then increment
        // the middle digit and store the carry
        if (n%2 == 1)
        {
            num[mid] += carry;
            carry = num[mid] / 10;
            num[mid] %= 10;
            j = mid + 1;
        }
        else
            j = mid;
 
        // Add 1 to the rightmost digit of the left side, propagate the carry 
        // towards MSB digit and simultaneously copying mirror of the left side 
        // to the right side.
        while (i >= 0)
        {
            num[i] += carry;
            carry = num[i] / 10;
            num[i] %= 10;
            num[j++] = num[i--]; // copy mirror to right
        }
    }
}

/* Cost of concatenating string / cost of string concatenation*/
public class MinimumCost {
    public static void main(String[] args) {
        ArrayList<String> s = new ArrayList<String>();
        s.add("abcd");
        s.add("def");
        s.add("gh");
        s.add("jh");
        System.out.println(getCost(s)); //Prints 22 for the above list
    }
    public static int getCost(ArrayList<String> s){
        int cost = 0;
        Collections.sort(s, new MySort()); //Sort the list according to length of the string
        while (s.size() != 1){ //Repeat until the list got one final string out of all the strings
            cost = cost + s.get(0).length() + s.get(1).length();
            String tmp = s.get(0) + s.get(1);
            s.remove(0);
            s.remove(0); // Remove the top 2 strings as they are concatenated now
            s.add(tmp); // Add the concatenated string to the list
            Collections.sort(s, new MySort()); //Sort the list again after concatenation
            }
        return cost;
    }
    static class MySort implements Comparator<String> {
        @Override
        public int compare(String s1, String s2) {
            if (s1.length() < s2.length())
                return -1;
            if (s1.length() > s2.length())
                return 1;
            return 0;

        }
    }

}

/*Function to generate the number of equal probability  given f(1) generates 0 and 1 with equal probability.*/
public static int f29() {
	int start = 0;
	int randomPick = 0;
	while (start <= 29) {
		randomPick += f1();
		start++;
	}
	return randomPick;
}

/* Search in 2D matrix with rows in ascending and column is also ascending / Search a 2D Matrix II*/
public class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if(matrix == null || matrix.length < 1 || matrix[0].length <1) {
            return false;
        }
        int col = matrix[0].length-1;
        int row = 0;
        while(col >= 0 && row <= matrix.length-1) {
            if(target == matrix[row][col]) {
                return true;
            } else if(target < matrix[row][col]) {
                col--;
            } else if(target > matrix[row][col]) {
                row++;
            }
        }
        return false;
    }
}
/* longest increasing Subsequence. O(n2)*/
public class Solution {
    public int lengthOfLIS(int[] nums) {
        int N = nums.length;
        if (N == 0) return 0;
        int[] dp = new int[N];
        Arrays.fill(dp, 1);
        int res = 1;
        for (int i = 1; i < N; i++) {
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) {
                    dp[i] = Math.max(dp[j] + 1, dp[i]);
                }
            }
            res = Math.max(res, dp[i]);
        }
        return res;   
    }
}
/* longest increasing Subsequence. O(n log n)*/
public class Solution {
    public int lengthOfLIS(int[] nums) {
         if (nums.length == 0) return 0;
        int len = 0, N = nums.length;
        int[] tailTable = new int[N];   
        tailTable[len++] = nums[0];
        for (int i = 1; i < N; i++) {
            if (nums[i] < tailTable[0]) tailTable[0] = nums[i];
            else if (nums[i] > tailTable[len - 1]) tailTable[len++] = nums[i];
            else {
                tailTable[binarySearch(tailTable, 0, len - 1, nums[i])] = nums[i];
            }
        }
        return len;
    }
    private int binarySearch(int[] tails, int start, int end, int target) {
        while (start < end) {
            int mid = start + (end - start)/2;
            if (tails[mid] >= target) end = mid;
            else start = mid + 1;
        }
        return end;
    }
}
/* Make all possible subsets (with duplicates)/ Subsets II*/
public class Solution {
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> each = new ArrayList<>();
    helper(res, each, 0, nums);
    return res;
    }
    public void helper(List<List<Integer>> res, List<Integer> each, int pos, int[] n) {
    if (pos <= n.length) {
        res.add(each);
    }
    int i = pos;
    while (i < n.length) {
        each.add(n[i]);
        helper(res, new ArrayList<>(each), i + 1, n);
        each.remove(each.size() - 1);
        i++;
        while (i < n.length && n[i] == n[i - 1]) {i++;}
    }
    return;
}
}
/* Range Sum - Immutable*/
public class NumArray {
int[] sum;
    public NumArray(int[] nums) {
        sum = new int[nums.length];
        if(nums.length>0)
            sum[0]=nums[0];
        for(int i=1; i<nums.length; i++)
        {
            sum[i]=sum[i-1]+nums[i];
        }
    }

    public int sumRange(int i, int j) 
    {
         if(i==0)
            return sum[j];
        return sum[j]-sum[i-1];
    }
}


// Your NumArray object will be instantiated and called as such:
// NumArray numArray = new NumArray(nums);
// numArray.sumRange(0, 1);
// numArray.sumRange(1, 2);
/* Partition List / divide list such that elements less than target are at the left of list and more after the target
the basic idea is to maintain two queues, the first one stores all nodes with val less than x , and the second queue stores all the rest nodes. Then concat these two queues. Remember to set the tail of second queue a null next, or u will get TLE.
*/
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode partition(ListNode head, int x) {
        ListNode dummy1 = new ListNode(0), dummy2 = new ListNode(0);  //dummy heads of the 1st and 2nd queues
    ListNode curr1 = dummy1, curr2 = dummy2;      //current tails of the two queues;
    while (head!=null){
        if (head.val<x) {
            curr1.next = head;
            curr1 = head;
        }else {
            curr2.next = head;
            curr2 = head;
        }
        head = head.next;
    }
    curr2.next = null;          //important! avoid cycle in linked list. otherwise u will get TLE.
    curr1.next = dummy2.next;
    return dummy1.next;
    }
}
/*find the starting and ending index of an element in the sorted array / Search for a range*/
public class Solution {
    public int[] searchRange(int[] A, int target) {
        int[] range = {A.length, -1};
        searchRange(A, target, 0, A.length - 1, range);
        if (range[0] > range[1]) range[0] = -1; 
        return range;
    }
     public void searchRange(int[] A, int target, int left, int right, int[] range) {
        if (left > right) return;
        int mid = left + (right - left) / 2;
        if (A[mid] == target) {
            if (mid < range[0]) {
                range[0] = mid;
                searchRange(A, target, left, mid - 1, range);
            }
            if (mid > range[1]) {
                range[1] = mid;
                searchRange(A, target, mid + 1, right, range);
            }
        } else if (A[mid] < target) {
            searchRange(A, target, mid + 1, right, range);
        } else {
            searchRange(A, target, left, mid - 1, range);
        }
    }
}

/*Sort a list using Insertion Sort */
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode insertionSortList(ListNode head) {
        ListNode curr = head, next = null;
  // l is a fake head
  ListNode l = new ListNode(0);

  while (curr != null) {
    next = curr.next;

    ListNode p = l;
    while (p.next != null && p.next.val < curr.val)
      p = p.next;

    // insert curr between p and p.next
    curr.next = p.next;
    p.next = curr;
    curr = next;
  }

  return l.next;
    }
}
/* Divide two integers without using multiplication, modulus and divide operation / divide 2 integers*/
public class Solution {
    public int divide(int dividend, int divisor) {
        //Reduce the problem to positive long integer to make it easier.
    //Use long to avoid integer overflow cases.
    int sign = 1;
    if ((dividend > 0 && divisor < 0) || (dividend < 0 && divisor > 0))
        sign = -1;
    long ldividend = Math.abs((long) dividend);
    long ldivisor = Math.abs((long) divisor);

    //Take care the edge cases.
    if (ldivisor == 0) return Integer.MAX_VALUE;
    if ((ldividend == 0) || (ldividend < ldivisor)) return 0;

    long lans = ldivide(ldividend, ldivisor);

    int ans;
    if (lans > Integer.MAX_VALUE){ //Handle overflow.
        ans = (sign == 1)? Integer.MAX_VALUE : Integer.MIN_VALUE;
    } else {
        ans = (int) (sign * lans);
    }
    return ans;
    }
    
    private long ldivide(long ldividend, long ldivisor) {
    // Recursion exit condition
    if (ldividend < ldivisor) return 0;

    //  Find the largest multiple so that (divisor * multiple <= dividend), 
    //  whereas we are moving with stride 1, 2, 4, 8, 16...2^n for performance reason.
    //  Think this as a binary search.
    long sum = ldivisor;
    long multiple = 1;
    while ((sum+sum) <= ldividend) {
        sum += sum;
        multiple += multiple;
    }
    //Look for additional value for the multiple from the reminder (dividend - sum) recursively.
    return multiple + ldivide(ldividend - sum, ldivisor);
}
}
/* Course Schedule*/
public class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        ArrayList[] graph = new ArrayList[numCourses];
            for(int i=0;i<numCourses;i++)
                graph[i] = new ArrayList();

            boolean[] visited = new boolean[numCourses];
            for(int i=0; i<prerequisites.length;i++){
                graph[prerequisites[i][1]].add(prerequisites[i][0]);
            }

            for(int i=0; i<numCourses; i++){
                if(!dfs(graph,visited,i))
                    return false;
            }
            return true;
    }
    private boolean dfs(ArrayList[] graph, boolean[] visited, int course){
            if(visited[course])
                return false;
            else
                visited[course] = true;;

            for(int i=0; i<graph[course].size();i++){
                if(!dfs(graph,visited,(int)graph[course].get(i)))
                    return false;
            }
            visited[course] = false;
            return true;
        }
}
/* maximum product subarray / max product sub array
Loop through the array, each time remember the max and min value for the previous product, the most important thing is to update the max and min value: we have to compare among max * A[i], min * A[i] as well as A[i], since this is product, a negative * negative could be positive.
*/
public class Solution {
    public int maxProduct(int[] A) {
        if (A == null || A.length == 0) {
            return 0;
        }
        int max = A[0], min = A[0], result = A[0];
        for (int i = 1; i < A.length; i++) {
            int temp = max;
            max = Math.max(Math.max(max * A[i], min * A[i]), A[i]);
            min = Math.min(Math.min(temp * A[i], min * A[i]), A[i]);
            if (max > result) {
                result = max;
            }
        }
        return result;
    }
}
/*All gray codes of a number I Solution*/
public class Solution {
    public List<Integer> grayCode(int n) {
        List<Integer> result = new LinkedList<>();
    for (int i = 0; i < 1<<n; i++) result.add(i ^ i>>1);
    return result;
    }
}
/* All gray codes of a number II solution*/
public class Solution {
   //analyze the pattern
//n=0  -> 0
//n=1  -> 0, 1
//n=2  -> (00,  01),  (10,  11)
//n=3  -> (000, 001, 010, 011), (111, 110, 101, 100)

//so the pattern is when n=n  -> add 0 in front of all the result of (n-1)'s binary value (This is just same as all the result of (n-1)
//                               and add 1 in front of all the result of(n-1)'s binary value (This need to calculate.)


public List<Integer> grayCode(int n) {
    List<Integer> result = new ArrayList();
    result.add(0);

    for(int i=1; i<=n; i++){
        int front=1;
        //Create the correct value for binary format (10...0) which the value has i digi
        //so shift 1 to right (i-1) times
        for(int j=1; j<i; j++){
            front = front<<1;
        }

        //add the new generated value to the result list
        //the new generated value is the last result add front value
        int size=result.size();
        //we want to loop through the (n-1) result from end to start. This is just because want to make the test case match the Leetcode answer. You can use other way loop through the (n-1) result.
        for(int k=size-1; k>=0; k--){
            result.add(result.get(k)+front);
        }
    }

    return result;
}
}
/* Container with most water 
1.	Start with pointer left=0 and pointer right=length-1
2.	The max water is limited by the pointer with smaller height
3.	When moving a pointer, the width of the area decrease
4.	If we move the pointer with higher height, we will never get a greater area, the max height will be at most the one of the pointer with smaller height.
5.	So we need to move the pointer with smaller height to have a chance to get higher height at the next step.
*/
public class Solution {
    public int maxArea(int[] height) {
        int left = 0, right = height.length - 1;
    int maxArea = 0;

    while (left < right) {
        maxArea = Math.max(maxArea, Math.min(height[left], height[right])
                * (right - left));
        if (height[left] < height[right])
            left++;
        else
            right--;
    }

    return maxArea;
    }
}

/*Number of Islands */
public class Solution {
    public int numIslands(char[][] grid) {
         int count = 0;
        for(int i = 0; i < grid.length; i++){
            for(int j = 0; j < grid[i].length; j++){
                /*find a cell belong to an island, then disappear the whole 
                  island and increase count*/
                if(grid[i][j] == '1'){
                    disappear(i,j,grid);
                    count++;
                }
            }
        }
        return count;
    }
     //Use for disapearing an island
    public void disappear(int i, int j, char[][] grid){
        //array edge detect
        if(i < 0 || i >= grid.length){
            return;
        }
        if(j < 0 || j >= grid[i].length){
            return;
        }
        //island edge detect
        if(grid[i][j] == '0'){
            return;
        }

        //disapear this cell
        grid[i][j] = '0';
        //disapear other cell in the same island
        disappear(i + 1, j, grid);
        disappear(i - 1, j, grid);
        disappear(i, j + 1, grid);
        disappear(i, j - 1, grid);
    }
}
/*First N ugly numbers 
The ugly-number sequence is 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, â¦ because every number can only be divided by 2, 3, 5, one way to look at the sequence is to split the sequence to three groups as below:
(1) 1Ã2, 2Ã2, 3Ã2, 4Ã2, 5Ã2, â¦
(2) 1Ã3, 2Ã3, 3Ã3, 4Ã3, 5Ã3, â¦
(3) 1Ã5, 2Ã5, 3Ã5, 4Ã5, 5Ã5, â¦
We can find that every subsequence is the ugly-sequence itself (1, 2, 3, 4, 5, â¦) multiply 2, 3, 5.
Then we use similar merge method as merge sort, to get every ugly number from the three subsequence.
Every step we choose the smallest one, and move one step after,including nums with same value.

*/
public class Solution {
    public int nthUglyNumber(int n) {
        int[] ugly = new int[n];
        ugly[0] = 1;
        int index2 = 0, index3 = 0, index5 = 0;
        int factor2 = 2, factor3 = 3, factor5 = 5;
        for(int i=1;i<n;i++){
            int min = Math.min(Math.min(factor2,factor3),factor5);
            ugly[i] = min;
            if(factor2 == min)
                factor2 = 2*ugly[++index2];
            if(factor3 == min)
                factor3 = 3*ugly[++index3];
            if(factor5 == min)
                factor5 = 5*ugly[++index5];
        }
        return ugly[n-1];   
    }
}
/*Permutation Sequence / kth permutation for the given number*/
public class Solution {
    public String getPermutation(int n, int k) {
        LinkedList<Integer> notUsed = new LinkedList<Integer>();

    int weight = 1;

    for (int i = 1; i <= n; i++) {
        notUsed.add(i);
        if (i == n)
            break;
        weight = weight * i;
    }

    String res = "";
    k = k - 1;
    while (true) {
        res = res + notUsed.remove(k / weight);
        k = k % weight;
        if (notUsed.isEmpty())
            break;
        weight = weight / notUsed.size();
    }

    return res;
    }
}
/*Merge two lists/ merge linked list / merge list / merge 2 lists /merge 2 linked list */
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null)
      return head;

    // step 1. cut the list to two halves
    ListNode prev = null, slow = head, fast = head;

    while (fast != null && fast.next != null) {
      prev = slow;
      slow = slow.next;
      fast = fast.next.next;
    }

    prev.next = null;

    // step 2. sort each half
    ListNode l1 = sortList(head);
    ListNode l2 = sortList(slow);

    // step 3. merge l1 and l2
    return merge(l1, l2);
    }
    
    ListNode merge(ListNode l1, ListNode l2) {
    ListNode l = new ListNode(0), p = l;

    while (l1 != null && l2 != null) {
      if (l1.val < l2.val) {
        p.next = l1;
        l1 = l1.next;
      } else {
        p.next = l2;
        l2 = l2.next;
      }
      p = p.next;
    }

    if (l1 != null)
      p.next = l1;

    if (l2 != null)
      p.next = l2;

    return l.next;
  }

}
/* Additive number / Additive number is a positive integer whose digits can form additive sequence*/
public class Solution {
    public boolean isAdditiveNumber(String num) {
         String a = "";
    String b = "";
    for (int i = 0; i < num.length()/3; i++) {
        a = num.substring(0, i + 1);
        for (int j = i + 1; j < num.length(); j++) {
            b = num.substring(i + 1, j + 1);
            if (b.charAt(0) == '0' && b.length() > 1) {continue;}
            if (valid(num.substring(j + 1), Long.parseLong(a), Long.parseLong(b))) {
                return true;
            }
        }
    }
    return false;
    }
    public boolean valid(String str, long a, long b) {
    long sum = a + b;
    String tempStr = String.valueOf(sum);
    int len = tempStr.length();
    if (str.length() < len) {return false;}
    if (str.length() == len && str.equals(tempStr)) {return true;}
    if (str.substring(0, len).equals(tempStr)) {
        return valid(str.substring(len), b, sum);
    }
    return false;
}
}
/* Basic Calculator*/
public class Solution {
    public int calculate(String s) {
        int len;
    if(s==null || (len = s.length())==0) return 0;
    Stack<Integer> stack = new Stack<Integer>();
    int num = 0;
    char sign = '+';
    for(int i=0;i<len;i++){
        if(Character.isDigit(s.charAt(i))){
            num = num*10+s.charAt(i)-'0';
        }
        if((!Character.isDigit(s.charAt(i)) &&' '!=s.charAt(i)) || i==len-1){
            if(sign=='-'){
                stack.push(-num);
            }
            if(sign=='+'){
                stack.push(num);
            }
            if(sign=='*'){
                stack.push(stack.pop()*num);
            }
            if(sign=='/'){
                stack.push(stack.pop()/num);
            }
            sign = s.charAt(i);
            num = 0;
        }
    }

    int re = 0;
    for(int i:stack){
        re += i;
    }
    return re;
    }
}
/* Re-order List*/
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public void reorderList(ListNode head) {
        if(head==null||head.next==null) return;

            //Find the middle of the list
            ListNode p1=head;
            ListNode p2=head;
            while(p2.next!=null&&p2.next.next!=null){ 
                p1=p1.next;
                p2=p2.next.next;
            }

            //Reverse the half after middle  1->2->3->4->5->6 to 1->2->3->6->5->4
            ListNode preMiddle=p1;
            ListNode preCurrent=p1.next;
            while(preCurrent.next!=null){
                ListNode current=preCurrent.next;
                preCurrent.next=current.next;
                current.next=preMiddle.next;
                preMiddle.next=current;
            }

            //Start reorder one by one  1->2->3->6->5->4 to 1->6->2->5->3->4
            p1=head;
            p2=preMiddle.next;
            while(p1!=preMiddle){
                preMiddle.next=p2.next;
                p2.next=p1.next;
                p1.next=p2;
                p1=p2.next;
                p2=preMiddle.next;
            }
    }
}
/*Maximal Square / find the maximum square in a matrix filled with 0s and 1s */
public class Solution {
    public int maximalSquare(char[][] a) {
        if (a == null || a.length == 0 || a[0].length == 0)
    return 0;

  int max = 0, n = a.length, m = a[0].length;

  // dp(i, j) represents the length of the square 
  // whose lower-right corner is located at (i, j)
  // dp(i, j) = min{ dp(i-1, j-1), dp(i-1, j), dp(i, j-1) }
  int[][] dp = new int[n + 1][m + 1];

  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      if (a[i - 1][j - 1] == '1') {
        dp[i][j] = Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;
        max = Math.max(max, dp[i][j]);
      }
    }
  }

  // return the area
  return max * max;
    }
}
/*Range Sum Query â 2D / sum of a given square in matrix */
public class NumMatrix {
    private int[][] dp;
    public NumMatrix(int[][] matrix) {
        dp = matrix;
    for (int i = 0; i < dp.length; i++) {
        for (int j = 1; j < dp[0].length; j++) {
            dp[i][j] += dp[i][j - 1];
        }
    }
    }

    public int sumRegion(int row1, int col1, int row2, int col2) {
          int res = 0;
    for (int i = row1; i <= row2; i++) {
       res += dp[i][col2];
       if (col1 != 0) {// if col1 == 0, just calculate row2
          res -= dp[i][col1 - 1];
       }
    }
    return res;
    }
}


// Your NumMatrix object will be instantiated and called as such:
// NumMatrix numMatrix = new NumMatrix(matrix);
// numMatrix.sumRegion(0, 1, 2, 3);
// numMatrix.sumRegion(1, 2, 3, 4);
/* Restore IP address from a string of digits*/
public class Solution {
   
         public List<String> restoreIpAddresses(String s) {
        List<String> res = new ArrayList<String>();
        int len = s.length();
        for(int i = 1; i<4 && i<len-2; i++){
            for(int j = i+1; j<i+4 && j<len-1; j++){
                for(int k = j+1; k<j+4 && k<len; k++){
                    String s1 = s.substring(0,i), s2 = s.substring(i,j), s3 = s.substring(j,k), s4 = s.substring(k,len);
                    if(isValid(s1) && isValid(s2) && isValid(s3) && isValid(s4)){
                        res.add(s1+"."+s2+"."+s3+"."+s4);
                    }
                }
            }
        }
    return res;
}
     public boolean isValid(String s){
        if(s.length()>3 || s.length()==0 || (s.charAt(0)=='0' && s.length()>1) || Integer.parseInt(s)>255)
            return false;
        return true;
    }

}
/*Contains Duplicate / Given an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.
This problem requires to maintain a window of size k of the previous values that can be queried for value ranges. The best data structure to do that is Binary Search Tree. As a result maintaining the tree of size k will result in time complexity O(N lg K). In order to check if there exists any value of range abs(nums[i] - nums[j]) to simple queries can be executed both of time complexity O(lg K)
Here is the whole solution using TreeMap.
 */
public class Solution {
    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
        if (nums == null || nums.length == 0 || k <= 0) {
            return false;
        }

        final TreeSet<Integer> values = new TreeSet<>();
        for (int ind = 0; ind < nums.length; ind++) {

            final Integer floor = values.floor(nums[ind] + t);
            final Integer ceil = values.ceiling(nums[ind] - t);
            if ((floor != null && floor >= nums[ind])
                    || (ceil != null && ceil <= nums[ind])) {
                return true;
            }

            values.add(nums[ind]);
            if (ind >= k) {
                values.remove(nums[ind - k]);
            }
        }

        return false;
    }
}
/* Find permutation of collection of numbers /permutation of list of numbers with duplicates RECURSIVE
The idea is to try to put every number at the beginning of the array, and then do the same thing for the rest of the array
*/
public class Solution {
    public List<List<Integer>> permuteUnique(int[] nums) {
          List<List<Integer>> res = new ArrayList<List<Integer>>();
        Arrays.sort(nums);
        LinkedList<Integer> list = new LinkedList<Integer>();
        for (int num : nums) list.add(num);
        permute(list, 0, res);
        return res;
    }
   private void permute(LinkedList<Integer> nums, int start, List<List<Integer>> res){
        if (start == nums.size() - 1){
            res.add(new LinkedList<Integer>(nums));
            return;
        }
        for (int i = start; i < nums.size(); i++){
            if (i > start && nums.get(i) == nums.get(i - 1)) continue;
            nums.add(start, nums.get(i));
            nums.remove(i + 1);
            permute(nums, start + 1, res);
            nums.add(i + 1, nums.get(start));
            nums.remove(start);
        }
    }
}
/* Find permutation of collection of numbers /permutation of list of numbers with duplicates ITERATIVE */
public class Solution {
    public List<List<Integer>> permuteUnique(int[] num) {
           Set<List<Integer>> permutations = new HashSet<List<Integer>>();

        if(num.length > 0){
            permutations.add(Arrays.asList(num[0]));

            for(int index = 1; index < num.length; index++) {

                Set<List<Integer>> newPermutations = new HashSet<List<Integer>>();
                for(List<Integer> list : permutations){

                    for(int innerIndex = 0; innerIndex <= list.size(); innerIndex++){
                        List<Integer> newList = new ArrayList(list);
                        newList.add(innerIndex, num[index]);
                        newPermutations.add(newList);
                    }
                }

                permutations = newPermutations;
            }
        }
        return new ArrayList<List<Integer>>(permutations);
    }
}
/* Remove Invalid Parentheses */
public class Solution {
    public List<String> removeInvalidParentheses(String s) {
        List<String> res = new ArrayList<>();

      // sanity check
      if (s == null) return res;

      Set<String> visited = new HashSet<>();
      Queue<String> queue = new LinkedList<>();

      // initialize
      queue.add(s);
      visited.add(s);

      boolean found = false;

      while (!queue.isEmpty()) {
        s = queue.poll();

        if (isValid(s)) {
          // found an answer, add to the result
          res.add(s);
          found = true;
        }

        if (found) continue;

        // generate all possible states
        for (int i = 0; i < s.length(); i++) {
          // we only try to remove left or right paren
          if (s.charAt(i) != '(' && s.charAt(i) != ')') continue;

          String t = s.substring(0, i) + s.substring(i + 1);

          if (!visited.contains(t)) {
            // for each state, if it's not visited, add it to the queue
            queue.add(t);
            visited.add(t);
          }
        }
      }

      return res;
    }
     // helper function checks if string s contains valid parantheses
    boolean isValid(String s) {
      int count = 0;

      for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        if (c == '(') count++;
        if (c == ')' && count-- == 0) return false;
      }

      return count == 0;
    }
}
/* Palindrome Partitioning in one cut RECURSIVE*/
public class Solution {
    int[][] panMap;
    int[] map;
    public int minCut(String s) {
         panMap = new int[s.length()][s.length()];
        map = new int[s.length() + 1];
        Arrays.fill(map, Integer.MAX_VALUE);
        map[s.length()] = 0;
        return minCut(s, 0) - 1;
    }
     private int minCut(String s, int start) {
        if (map[start] != Integer.MAX_VALUE) return map[start];
        for (int i = start; i < s.length(); i++) {
            if (isPan(s, start, i)) {
                map[start] = Math.min(map[start], 1 + minCut(s, i + 1));
            }
        }
        return map[start];
    }
 private boolean isPan(String s, int start, int end) {
        if (start == end) return true;
        if (end == start - 1 && s.charAt(start) == s.charAt(end)) return true;
        if (panMap[start][end] != 0) return panMap[start][end] == 1 ? true : false;

        if (s.charAt(start) == s.charAt(end)) {
            panMap[start][end] = isPan(s, start + 1, end - 1) ? 1 : -1;
        }
        return panMap[start][end] == 1 ? true : false;
    }
}
/* Palindrome Partitioning in one cut ITERATIVE */
public class Solution {
    public int minCut(String s) {
    
        if(s==null)
            return 0;
         int i,j,n=s.length();
         int cuts[]=new int[n];   //cuts[i] will store the minimum no. of cuts required for substring [0...i];
         boolean dp[][]=new boolean[n][n];   // dp[i][j]=true if substring [i...j] can be partitioned into list of palindromes.

        for(i=0;i<n;i++)
        {
            /*since every single character is a palindrome, maximum no. of cuts for substring [0...i] will be i
             hence initiating cuts[i] with maximum possible value. */        

            cuts[i]=i; 
            for(j=0;j<=i;j++)
            { 
                if(j == i)
                   dp[j][i] = true;
                else
                {
                  if(s.charAt(i)!= s.charAt(j))
                  continue;
                  if(j==i-1)

                  dp[j][i]=true;
                  else
                  dp[j][i]=dp[j+1][i-1] ;
                }

              if(dp[j][i])
              {
                  if(j==0)
                  cuts[i]=0;
                  else
                  cuts[i]=Math.min(cuts[j-1]+1,cuts[i]);  
                 /*since dp[j][i] is a palindrome, cuts[j]+1 equals no. of cuts required in [0...i] if we include the current  word [j..i]; New cuts[i] will be equal to min of previous cuts[i] and the newly calculated cuts[i] i.e. cuts[j]+1 */
              }


            }
        }
        return cuts[n-1];

    }
}
/* Inorder successor in a tree*/
public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
    while (root != null && root.val <= p.val)
        root = root.right;
    if (root == null)
        return null;
    TreeNode left = inorderSuccessor(root.left, p);
    return (left != null && left.val > p.val) ? left : root;
}
/* Inorder Predecessor*/
public TreeNode predecessor(TreeNode root, TreeNode p) {
  if (root == null)
    return null;

  if (root.val >= p.val) {
    return predecessor(root.left, p);
  } else {
    TreeNode right = predecessor(root.right, p);
    return (right != null) ? right : root;
  }
}
/*Rotate LinkedList / Rotate linked list */
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        int size = 1;

    if(head == null)
        return null;

    ListNode current = head;

    //Count size of the list and puts current pointer at the end
    while(current.next != null)
    {   
        size++;
        current = current.next;
    }

    //To deal with the case k >= size
    k %= size;

    //Puts the head of the list next to the tail. The idea is to use this to find the new head
    current.next = head;

    //We need to iterate size - k times to find the new head.
    for(int i = 0; i < size - k; i++)
        current = current.next;

    //Sets the new head
    head = current.next;

    //Current is the tail of our new list. Thus, this sets the null as the next node
    current.next = null;

    return head;

    }
}
/* Reverse linked list by k-groups/ reverse linked list after every k nodes/ Reverse linked list by k groups*/
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode curr = head;
    int count = 0;
    while (curr != null && count != k) { // find the k+1 node
        curr = curr.next;
        count++;
    }
    if (count == k) { // if k+1 node is found
        curr = reverseKGroup(curr, k); // reverse list with k+1 node as head
        // head - head-pointer to direct part, 
        // curr - head-pointer to reversed part;
        while (count-- > 0) { // reverse current k-group: 
            ListNode tmp = head.next; // tmp - next head in direct part
            head.next = curr; // preappending "direct" head to the reversed list 
            curr = head; // move head of reversed part to a new node
            head = tmp; // move "direct" head to the next node in direct part
        }
        head = curr;
    }
    return head;
    }
}


/*Check if Edit distance between two strings is 1 or lesser*/

public boolean getEditDistance(String s1, String s2){
	if(s1.length()-s2.length()>1)	
		return false;
	int count=0;
	int i=0,j=0;
	int m = s1.length(), n = s2.length();
	while(i<m && j<n){
		if(s1.charAt(i)!=s2.charAt(j)){
			if(count==1)
				return false;
			if(m<n)
				j++;
			else if (n<m)
				i++;
			else
				i++;
				j++;
			count++;
		} else{
		}
			i++;
			j++;
	}
	if(i<m||j<n)
		count++;
	return count==1;
}

/*Reverse an array without affecting special characters*/

public char[] reverseArray(char[] arr){
	if(arr==null||arr.length==0) return arr;
	int start =0;
	int end = arr.length-1;
	char temp = null;
	while(start<end){
		char firstChar = arr[start];
		char lastChar = arr[end];
		if(Character.isLetter(firstChar) && Character.isLetter(lastChar)){
			temp = firstChar;
			arr[start] = lastChar;
			arr[end] = temp;
			start++;
			end--;
		}else if(!Character.isLetter(firstChar)){
			start++;
		}else if(!Character.isLetter(lastChar)){
			end--;
		}
	}
	return arr;
}	

/*Isomorphic strings*/

public boolean checkIsomorphism(String s1, String s2){
	if(s1.lenght()!=s2.length())
		return false;
	StringBuilder sb = new StringBuilder();
	HashMap<Character,Character> map = new HashMap<>();

	for(int i=0;i<s1.length();i++){
		if(!map.containsKey(s1.charAt(i)) && !map.containsValue(s2.charAt(i))){
			map.put(s1.charAt(i),s2.charAt(i));
		}
	}
	for(int i=0;i<s1.length();i++){
		sb.append(map.get(s1.charAt(i)));
	}
	return sb.toString().equals(s2);
}

/*Remove spaces from a string*/
/*Example: "g ee ks for   gee k s"*/
    
public static String removeSpaces(String str){
	int space = 0;
	System.out.println(space);
	int j;
	char[] s = str.toCharArray();
	for(j=0;j<s.length;j++){
		if(s[j]!=' '){
			s[space] = s[j];
			space++;
		}		
	}
	System.out.println(space);
	return String.valueOf(s).substring(0,space);
}

/*Recursively print all sentences that can be formed from list of word lists*/

public class HelloWorld{
	public static void main (String[] args) throws java.lang.Exception
	{
		String[][] input = {{"you","we"},{"have", "are"},{"sleep", "eat", "drink"}};
		formStrings(input,0,new int[input.length]);
	}
	
	public static void formStrings(String[][] input, int i, int[] output){
		if(i>=input.length){
			for(int k=0;k<input.length;k++){
				System.out.print(input[k][output[k]]+" ");
			}
			System.out.println();
			return;
		}
		for(int k=0;k<input[i].length;k++){
			output[i]=k;
			formStrings(input,i+1,output);
		}
	}
}

/*Check if robot is moving in a circular path*/
#define N 0
#define E 1
#define S 2
#define W 3
 
// This function returns true if the given path is circular, else false
bool isCircular(char path[])
{
  // Initialize starting point for robot as (0, 0) and starting
  // direction as N North
  int x = 0, y = 0;
  int dir = N;
 
  // Travers the path given for robot
  for (int i=0; path[i]; i++)
  {
      // Find current move
      char move = path[i];
 
      // If move is left or right, then change direction
      if (move == 'R')
        dir = (dir + 1)%4;
      else if (move == 'L')
        dir = (4 + dir - 1)%4;
 
      // If move is Go, then change  x or y according to
      // current direction
      else // if (move == 'G')
      {
         if (dir == N)
            y++;
         else if (dir == E)
            x++;
         else if (dir == S)
            y--;
         else // dir == W
            x--;
      }
  }
 
   // If robot comes back to (0, 0), then path is cyclic
  return (x == 0 && y == 0);
}

/*Longest substring with k unique characters*/
public static String maxSubStringKUniqueChars(String s, int k) {
	//declare a counter
	HashMap<Character, Integer> map = new HashMap<Character, Integer>();		
	int start = 0;
	int maxLen = 0;
	String maxSubstring = null;
 
	for (int i = 0; i < s.length(); i++) {
		//add each char to the counter
		char c = s.charAt(i);
		if(map.containsKey(c)){
			map.put(c, map.get(c)+1);
		}else{
			map.put(c, 1);
		}
 
		if(map.size() == k+1){
			//get maximum
			int range = i-start;
			if(range > maxLen){
				maxLen = range;
				maxSubstring = s.substring(start, i);
			}
 
			//move left cursor toward right, so that substring contains only k chars
			while(map.size()>k){
				char first = s.charAt(start);
				int count = map.get(first);
				if(count>1){
					map.put(first,count-1);
				}else{
					map.remove(first);
				}
				start++;
			}
		}
	}
 
	if (map.size() == k && maxLen == 0) {
		return s;
	}
 
	return maxSubstring;
}

/*Find maximum depth of braces*/
public class HelloWorld{
	public static void main (String[] args) throws java.lang.Exception
	{
	    System.out.println(findDepthOfBraces("( p((q)) ((s)t) )"));
	}
	
	public static int findDepthOfBraces(String s){
	    int max=0;
	    int curMax=0;
	    for(int i=0;i<s.length();i++){
	        if(s.charAt(i)=='('){
	            curMax++;
	        }else if(s.charAt(i)==')'){
	            if(curMax==-1){
	                   return -1;
	            }
	            max = Math.max(curMax,max);
	            curMax--;
	        }
	    }
	    return max;
	}
}

/*Reverse of a string using recursion*/
public String reverseString(String s){
	if(s.length()<2){
		return s;
	}
	return reverseString(s.substring(1))+s.charAt(0);
}

/*Return the first non-repeating character in a string*/
public char firstNonRepeatingChar(String s){
	if(s.length()==0||s==null) return '\0';
	HashMap<Character,Integer> map = new HashMap<>();
	for(int i=0;i<s.length();i++){
		char cur = s.charAt(i);
		map.put(cur,map.getOrDefault(cur,0)+1);
	}
	for(int i=0;i<s.length();i++){
		if(map.get(s.charAt(i))==1)
			return s.charAt(i);
	}
	return '\0';
}

/*Reverse words in a string*/
public String reverseWords(String s){
	if(s.length()==0||s==null) return s;
	String[] words = s.split("\\s+");
	StringBuilder sb = new StringBuilder();
	int i;
	for(i = words.length-1;i>0;i--){
		sb.append(words[i]).append(" ");
	}
	sb.append(words[i]);
	return sb.toString();
}

/*Length encoding*/
public String encodeStringLength(String s){
	if(s.length()==0||s==null) return s;
	char cur =s.charAt(0);
	int count =1;
	StringBuilder sb = new StringBuilder();
	for(int i=1;i<s.length();i++){
		if(s.charAt(i)==cur)
			count++;
		else{
			sb.append(cur).append(count);
			count=1;
			cur=s.charAt(i);
		}
	}
	sb.append(cur).append(count);
	return sb.toString();
}


/*Find the smallest window in a string containing all characters of another string*/
public String findSmallestWindow(String s1, String s2){
	HashMap<Character,Integer> map = new HashMap<>();

	for(int i=0;i<s2.length();i++){
		map.put(s2.charAt(i),map.getOrDefault(s.charAt(i),0)+1);
	}
	int left = 0;
	int minLeft=0;
	int minLen = s.length()-1;
	int count =0;
	for(int right=0;right<s1.length();right++){
		char cur = s1.charAt(right);
		if(map.containsKey(cur)) {
			map.put(cur,map.get(cur)-1);
		}
		if(map.get(cur)>=0){
			count++;
		}
		while(count==s2.length()){
			if(right-left+1 < minLen ){
				minLen = right-left+1;
				minLeft = left;
			}
			if(map.containsKey(s.charAt(left))){
				map.put(s.charAt(left),map.get(s.charAt(left))+1);
				if(map.get(s.charAt(left))>0)
					count--;
			}
			left++;
		}
	}

}

/*Find all permutations with repition of characters*/
private static void printPermutationOfStrings(String str){
  printPermutation(str, "");
 }
  
 private static void printPermutation(String str, String stringToPrint){
  if(stringToPrint.length()==str.length()){
   System.out.println(stringToPrint);
   return;
  }
  for (int i = 0; i < str.length(); i++) {
   printPermutation(str, stringToPrint + str.charAt(i));
  }
 }

 /*Find all permutations without repition of characters*/

  
 private  void permutation(String string) {
  printPermutation(string,"");
 }
 
 private  void printPermutation(String string, String permutation) {
   
  if(string.length()==0){
   System.out.println(permutation);
   return;
  }
   
  for (int i = 0; i < string.length(); i++) {
   char toAppendToPermutation = string.charAt(i);
   String remaining = string.substring(0, i) + string.substring(i + 1);
    
   printPermutation( remaining,  permutation + toAppendToPermutation);
  }  
 }
 
}


/*Check if interleaving two strings forms the third string*/
public class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        if(s1.length()+s2.length()!=s3.length())
            return false;
        
        boolean[][] matrix = new boolean[s2.length()+1][s1.length()+1];
        matrix[0][0] = true;
        for(int i=1;i<matrix[0].length;i++){
            matrix[0][i] = matrix[0][i-1]&&(s1.charAt(i-1)==s3.charAt(i-1));
        }
        for(int i=1;i<matrix.length;i++){
            matrix[i][0] = matrix[i-1][0] &&(s2.charAt(i-1)==s3.charAt(i-1));
        }
        
        for(int i=1;i<matrix.length;i++){
            for(int j=1;j<matrix[0].length;j++){
                matrix[i][j] = (matrix[i-1][j]&&(s2.charAt(i-1)==s3.charAt(i+j-1)))||(matrix[i][j-1]&&(s1.charAt(j-1)==s3.charAt(i+j-1)));
            }
        }
        return matrix[matrix.length-1][matrix[0].length-1];
    }
}

/*Print all the interleavings of two strings*/
public static void printInterleavings(String s1,String s2){
		ArrayList<String> result = new ArrayList<>();
  		printInterleavings(s1,s2,"",result);
  		System.out.println(result);
	}
	
	
	public static void printInterleavings(String s1,String s2,String soFar,ArrayList<String> result){
		if((s1==null||s1.length()==0) && (s2==null||s2.length() == 0))
			return;
		if(s1==null || s1.length()==0){
			result.add(soFar+s2);
			return;
		}
		if(s2==null || s2.length()==0){
			result.add(soFar+s1);
			return;
		}
		printInterleavings(s1.substring(1), s2, soFar + s1.charAt(0),result);
		printInterleavings(s1, s2.substring(1), soFar + s2.charAt(0),result);
		
	}
/*Count number of words*/
#define OUT 0
#define IN  1
 
// returns number of words in str
unsigned countWords(char *str)
{
    int state = OUT;
    unsigned wc = 0;  // word count
 
    // Scan all characters one by one
    while (*str)
    {
        // If next character is a separator, set the state as OUT
        if (*str == ' ' || *str == '\n' || *str == '\t')
            state = OUT;
 
        // If next character is not a word separator and state is OUT,
        // then set the state as IN and increment word count
        else if (state == OUT)
        {
            state = IN;
            ++wc;
        }
 
        // Move to next character
        ++str;
    }
 
    return wc;
}

/*Find all the distinct palindrome substrings*/ O(n^2)
public HashSet<String> distinctPalindromes(String s){
    	 HashSet<String> set = new HashSet<String>();
    	 String temp = "";
    	 for(int i=0;i<s.length();i++){
    		getPalindrome(s,i,i,set);
    		getPalindrome(s,i,i+1,set);
    	 }
    	 return set;
     }
     
     public void getPalindrome(String s, int begin, int end, HashSet<String> set){
    	 while(begin>=0 && end<=s.length()-1 && s.charAt(begin)==s.charAt(end)){
    		 set.add(s.substring(begin,end+1));
    		 begin--;
    		 end++;
    	 }
    	 
     }


/*Check if one string is a subsequence of another*/

  public static boolean checkSubsequence(String s1, String s2){
  	if(s1.length()>s2.length()) return false;
    
    int i=0;
    for(int j=0;j<s2.length()&&i<s1.length();j++){
    	char s1Char = s1.charAt(i);
      	char s2Char = s2.charAt(j);
      	if(s1Char==s2Char)
          i++;      
    }
    if(i<s1.length())
      	return false;
    return true;
  }
  
/*word ladder */

public class Solution {
    public int ladderLength(String beginWord, String endWord, Set<String> wordList) {
        Set<String> beginSet = new HashSet<String>(), endSet = new HashSet<String>();

    int len = 1;
    int strLen = beginWord.length();
    HashSet<String> visited = new HashSet<String>();

    beginSet.add(beginWord);
    endSet.add(endWord);
    while (!beginSet.isEmpty() && !endSet.isEmpty()) {
        if (beginSet.size() > endSet.size()) {
            Set<String> set = beginSet;
            beginSet = endSet;
            endSet = set;
        }

        Set<String> temp = new HashSet<String>();
        for (String word : beginSet) {
            char[] chs = word.toCharArray();

            for (int i = 0; i < chs.length; i++) {
                for (char c = 'a'; c <= 'z'; c++) {
                    char old = chs[i];
                    chs[i] = c;
                    String target = String.valueOf(chs);

                    if (endSet.contains(target)) {
                        return len + 1;
                    }

                    if (!visited.contains(target) && wordList.contains(target)) {
                        temp.add(target);
                        visited.add(target);
                    }
                    chs[i] = old;
                }
            }
        }

        beginSet = temp;
        len++;
    }

    return 0;
    }
}

/*Function to generate a number with equal probability*/
public static int f29() {
	int start = 0;
	int randomPick = 0;
	while (start <= 29) {
		randomPick += f1();
		start++;
	}
	return randomPick;
}

/*Unique paths from top right of matrix to bottom left / can only travel right and down*/
public class Solution {
    public int uniquePaths(int m, int n) {
        int [][]matrix = new int[m][n];
        matrix[0][0]=1;
        for(int i=0; i<m; i++)
        {
            for(int j=0; j<n ;j++)
            {
                if(i==0 &&j!=0)
                {
                    matrix[i][j]+=matrix[i][j-1];
                }
                else if(i!=0&&j==0)
                {
                    matrix[i][j]+=matrix[i-1][j];
                }
                else if(i!=0&&j!=0)
                {
                    matrix[i][j] = matrix[i][j-1]+matrix[i-1][j];
                }
            }
        }
        return matrix[m-1][n-1];
    }
}
/* Unique path sum with obstacles*/
public class Solution {
    public int uniquePathsWithObstacles(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        if(matrix[0][0]==1 || matrix[m-1][n-1]==1)
            return 0;
        else
            matrix[0][0]=-1;
        
        
        for(int i=0; i<m ;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(matrix[i][j]==1)
                    continue;
                if(i==0&&j!=0&&matrix[i][j-1]!=1)
                    matrix[i][j]+=matrix[i][j-1];
                else if(i!=0&&j==0&&matrix[i-1][j]!=1)
                    matrix[i][j]+=matrix[i-1][j];
                else if(i!=0&&j!=0)
                {
                    if(matrix[i][j-1]!=1)
                        matrix[i][j]=matrix[i][j-1];
                    if(matrix[i-1][j]!=1)
                        matrix[i][j]=matrix[i][j]+matrix[i-1][j];
                }
                    
            }
        }
        return 0-matrix[m-1][n-1];
    }
}
/*First Missing Positive /optimal solution*/
public class Solution {
    public int firstMissingPositive(int[] nums) {
        if(nums == null || nums.length ==0)
        return 1;
        int i = 0, n = nums.length;
    while (i < n) {
        // If the current value is in the range of (0,length) and it's not at its correct position, 
        // swap it to its correct position.
        // Else just continue;
        if (nums[i] >= 0 && nums[i] < n && nums[nums[i]] != nums[i])
            swap(nums, i, nums[i]);
        else
            i++;
    }
    int k = 1;

    // Check from k=1 to see whether each index and value can be corresponding.
    while (k < n && nums[k] == k)
        k++;

    // If it breaks because of empty array or reaching the end. K must be the first missing number.
    if (n == 0 || k < n)
        return k;
    else   // If k is hiding at position 0, K+1 is the number. 
        return nums[0] == k ? k + 1 : k;
    }
    private void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
}
/* Minimum size subarray sum / minimum sum subarray equals to target value*/
public class Solution {
    public int minSubArrayLen(int s, int[] nums) {
        if(nums==null || nums.length==0)
            return 0;
        int i=0, j=0, sum=0, min = Integer.MAX_VALUE;
        while(j<nums.length)
        {
            sum = sum+nums[j++];
            while(sum>=s)
            {
                min = Math.min(min, j-i);
                sum=sum-nums[i++];
            }
        }
        return min==Integer.MAX_VALUE ? 0 : min;
    }
}
/* Longest Consecutive Sequence in an array*/
public class Solution {
    public int longestConsecutive(int[] nums) {
        if(nums==null || nums.length==0)
            return 0;
        int longest = 0;
        HashMap<Integer, Integer> map = new HashMap<>();
        for(int i=0; i<nums.length;i++)
        {
            if(map.containsKey(nums[i]))
                continue;
            map.put(nums[i],1);
            
            int begin = nums[i];
            int end = nums[i];
            
            if(map.containsKey(nums[i]+1))
                end = nums[i]+ map.get(nums[i]+1);
            
            if(map.containsKey(nums[i]-1))
                begin = nums[i] - map.get(nums[i]-1);
                
            longest=Math.max(longest, end-begin+1);
            
            map.put(end, end-begin+1);
            map.put(begin, end-begin+1);
        }
        return longest;
    }
}


/*Spiral Matrix*/
public class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
    List<Integer> spiralList = new ArrayList<>();
    if(matrix == null || matrix.length == 0) return spiralList;

    // declare indices
    int top = 0;
    int bottom = matrix.length - 1;
    int left = 0;
    int right = matrix[0].length - 1;

    while(true){
        // 1. print top row
        for(int j=left; j <=right;j++){
            spiralList.add(matrix[top][j]);
        }
        top++;
        if(boundriesCrossed(left,right,bottom,top))
            break;

        // 2. print rightmost column
        for(int i=top; i <= bottom; i++){
            spiralList.add(matrix[i][right]);
        }
        right--;
        if(boundriesCrossed(left,right,bottom,top))
            break;

        // 3. print bottom row
        for(int j=right; j >=left; j--){
            spiralList.add(matrix[bottom][j]);
        }
        bottom--;
        if(boundriesCrossed(left,right,bottom,top))
            break;    

        // 4. print leftmost column
        for(int i=bottom; i >= top; i--){
            spiralList.add(matrix[i][left]);
        }
        left++;
        if(boundriesCrossed(left,right,bottom,top))
            break;    
    }// end while true

    return spiralList;
}

private boolean boundriesCrossed(int left,int right,int bottom,int top){
    if(left>right || bottom<top)
        return true;
    else
        return false;
}
}
/*Spiral Matrix / generate matrix in spiral form*/
public class Solution {
    public int[][] generateMatrix(int n) {
        int [][] matrix = new int[n][n];
    int top = 0;
    int bottom = matrix.length - 1;
    int left = 0;
    int right = n - 1;
    int count=1;
    while(true)
    {
        for(int i =left ; i<=right;i++)
        {
            matrix[top][i] = count++;
        }
        top++;
        if(boundriesCrossed(left,right,bottom,top))
            break;

        for(int i=top; i <= bottom; i++)
        {
            matrix[i][right]=count++;
        }
        right--;
        if(boundriesCrossed(left,right,bottom,top))
            break;

        // 3. print bottom row
        for(int j=right; j >=left; j--)
        {
            matrix[bottom][j]=count++;
        }
        bottom--;
        if(boundriesCrossed(left,right,bottom,top))
            break;    

        // 4. print leftmost column
        for(int i=bottom; i >= top; i--)
        {
            matrix[i][left]=count++;
        }
        left++;
        if(boundriesCrossed(left,right,bottom,top))
            break;    


    }
return matrix;
    
}

    private boolean boundriesCrossed(int left,int right,int bottom,int top){
    if(left>right || bottom<top)
        return true;
    else
        return false;
}

}
/*all Subsets of a set including empty set ITERATIVE*/
public class Solution {
    public List<List<Integer>> subsets(int[] S) {
         List<List<Integer>> res = new ArrayList<>();
        res.add(new ArrayList<Integer>());

        Arrays.sort(S);
        for(int i : S) {
            List<List<Integer>> tmp = new ArrayList<>();
            for(List<Integer> sub : res) {
                List<Integer> a = new ArrayList<>(sub);
                a.add(i);
                tmp.add(a);
            }
            res.addAll(tmp);
        }
        return res;
    }
}
/*all Subsets of a set including empty set ITERATIVE*/
public class Solution {
    public List<List<Integer>> subsets(int[] nums) {
         Arrays.sort(nums);
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> each = new ArrayList<>();
    helper(res, each, 0, nums);
    return res;
    }
    public void helper(List<List<Integer>> res, List<Integer> each, int pos, int[] n) {
    if (pos <= n.length) {
        res.add(each);
    }
    for (int i = pos; i < n.length; i++) {
        each.add(n[i]);
        helper(res, new ArrayList<>(each), i + 1, n);
        each.remove(each.size() - 1);
    }
    return;
}
}
/*Add digits until you get the single digit*/
public class Solution {
    public int addDigits(int num) {
        return (num<10)?num:((num-1)%9)+1;
    }
}
/*number of 1 bits / number of 1 digits in unsigned 32 bit number*/
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int count=0;
        while(n!=0)
        {
            count=count+(n&1);
            n=n>>>1;
        }
        return count;
    }
}
/*Next Permutation*/
public class Solution {
    public void nextPermutation(int[] nums) {
        if(nums.length<=1){
          return;
      }

      int i= nums.length-1;

      for(;i>=1;i--){

         if(nums[i]>nums[i-1]){ //find first number which is smaller than it's after number
             break;
         }
      }

      if(i!=0){
          swap(nums,i-1); //if the number exist,which means that the nums not like{5,4,3,2,1}
      }

      reverse(nums,i);    
        
    }
    private void swap(int[] a,int i){
        for(int j = a.length-1;j>i;j--){
            if(a[j]>a[i]){
                int t = a[j];
                a[j] = a[i];
                a[i] = t;
                break;
            }
        }
    }
    
     private void reverse(int[] a,int i){//reverse the number after the number we have found
        int first = i;
        int last = a.length-1;
        while(first<last){
            int t = a[first];
            a[first] = a[last];
            a[last] = t;
            first ++;
            last --;
        }
    }
}
/*search in matrix / search in a 2D array
The basic idea is from right corner, if the current number greater than target col - 1 in same row, else if the current number less than target, row + 1 in same column, finally if they are same, we find it, and return return.
*/
public class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
       if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
        return false;
    }
    int row = 0;
    int col = matrix[0].length - 1;
    while (row < matrix.length && col >= 0) {
        if (matrix[row][col] == target) {
            return true;
        } else if (matrix[row][col] < target) {
            row++;
        } else {
            col--;
        }
    }
    return false;
    }
}
/* Strobogrammatic number  SOLUTION 1
Just checking the pairs, going inwards from the ends.
*/
public boolean isStrobogrammatic(String num) {
    for (int i=0, j=num.length()-1; i <= j; i++, j--)
        if (!"00 11 88 696".contains(num.charAt(i) + "" + num.charAt(j)))
            return false;
    return true;
}
/* Strobogrammatic number SOLUTION 2 */
public boolean isStrobogrammatic(String num) {
    Map<Character, Character> map = new HashMap<Character, Character>();
    map.put('6', '9');
    map.put('9', '6');
    map.put('0', '0');
    map.put('1', '1');
    map.put('8', '8');

    int l = 0, r = num.length() - 1;
    while (l <= r) {
        if (!map.containsKey(num.charAt(l))) return false;
        if (map.get(num.charAt(l)) != num.charAt(r))
            return false;
        l++;
        r--;
    }

    return true;
}
/*Combination Sum (with duplicates)*/
public class Solution {
    public List<List<Integer>> combinationSum(int[] cand, int target) {
        ArrayList<List<Integer>> result = new ArrayList<List<Integer>>();
        Arrays.sort(cand);
        helper(result, new ArrayList<Integer>(), 0, target, cand);
        return result;
    }
    public void helper(ArrayList<List<Integer>> result, ArrayList<Integer> list, int start, int target, int [] cand)
    {
        for(int i=start; i<cand.length ; i++)
        {
            list.add(cand[i]);
            if(cand[i]<target)
                 helper(result, list, i, target-cand[i], cand);
            else if(target==cand[i])
                result.add(new ArrayList<>(list));
                
            list.remove(list.size()-1);
                
        }
    }
}
/*Combination Sum2 (without duplicates) / Combination Sum 2 (without duplicates)*/
public class Solution {
    HashSet<ArrayList<Integer>> hs = new HashSet<ArrayList<Integer>>();
    public List<List<Integer>> combinationSum2(int[] cand, int target) {
        HashSet<List<Integer>> result = new HashSet<List<Integer>>();
         
        Arrays.sort(cand);
        helper(result, new ArrayList<Integer>(), 0, target, cand);
        return new ArrayList(result);   
    }
    public void helper(HashSet<List<Integer>> result, ArrayList<Integer> list, int start, int target, int [] cand)
    {
    
         for(int i=start; i<cand.length ; i++)
        {
            list.add(cand[i]);
            if(cand[i]<target)
                 helper(result, list, i+1, target-cand[i], cand);
    
            else if(target==cand[i])
                    result.add(new ArrayList<>(list));
                list.remove(list.size()-1);
                
        }
     
    }
}
/*Bulls and Cows*/
public class Solution {
    public String getHint(String secret, String guess) {
        if(secret.length()==0) return null;
        
        HashMap<Character,Integer> map = new HashMap<>();
        int A=0;
        int B=0;
        char c;
        for(int i=0;i<secret.length();i++){
            c=secret.charAt(i);
            map.put(c,map.getOrDefault(c,0)+1);
        }
        
        for(int i=0;i<guess.length();i++){
            c=guess.charAt(i);
            Integer value = map.get(c)==null ? 0 :map.get(c);
            if(c==secret.charAt(i)){
                A++;
                if(value<=0)
                    B--;
            }else if(value>0){
                B++;
                
            }
            map.put(c,value-1);
        }
      return A+"A"+B+"B";
      
    }
}
/*Repeated DNA Sequence
All DNA is composed of a series of nucleotides abbreviated as A, C, G, and T, for example: "ACGAATTCCG". When studying DNA, it is sometimes useful to identify repeated sequences within the DNA.
Write a function to find all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule.
For example,
Given s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT",

Return:
["AAAAACCCCC", "CCCCCAAAAA"].

*/
public class Solution {
    public List<String> findRepeatedDnaSequences(String s) {
        HashSet<String> seen = new HashSet<>(), repeated = new HashSet<>();
        String c;
        for(int i=0 ; i<=s.length()-10 ; i++)
        {
            c = s.substring(i, i+10);
            if(!seen.add(c))
                repeated.add(c);
        }
        return new ArrayList(repeated);
    }
}
/*Fraction to Recurring Decimal
For example,
â¢	Given numerator = 1, denominator = 2, return "0.5".
*/
public class Solution {
    public String fractionToDecimal(int numerator, int denominator) {
        StringBuilder sb = new StringBuilder();
        String sign = numerator<0 == denominator<0 || numerator==0 ? "" : "-";
        sb.append(sign);
        long num = (long)numerator;
        long den = (long)denominator;
    
        num = Math.abs(num);
        den = Math.abs(den);
        
        sb.append(num/den);
        
        long rem = num%den;
        
        if(rem==0)
            return sb.toString();
            
        HashMap<Long, Integer> map = new HashMap<Long, Integer>();
        sb.append(".");
        
        while(rem!=0 && !map.containsKey(rem))
        {
            map.put(rem, sb.length());
            rem*=10;
            sb.append(rem/den);
            rem=rem%den;
        }
        if(map.containsKey(rem)){
        int index = map.get(rem);
        sb.insert(index, "(");
        sb.append(")");
            
        }
        return sb.toString();
    }
}
/*Word pattern
Given a pattern and a string str, find if str follows the same pattern.
Examples:
pattern = "abba", str = "dog cat cat dog" should return true.
*/
public class Solution {
    public boolean wordPattern(String pattern, String str) {
        String [] arr = str.split(" ");
HashMap<Character, String> map = new HashMap<Character, String>();
if(arr.length!=pattern.length())
	return false;
for (int i=0; i<arr.length; i++)
{
	char c = pattern.charAt(i);
	if(map.containsKey(c))
	{
		if(!map.get(c).equals(arr[i]))
			return false;
	}
	else
	{
		if(map.containsValue(arr[i]))
			return false;
		map.put(c, arr[i]);
	}
}
return true;
    }
}
/*Board game / live or dead / live / dead / matrix*/
public class Solution {
    public void gameOfLife(int[][] board) {
        int m = board.length;
        int n = board[0].length;
        
        for(int i=0 ; i<m ; i++)
        {
            for(int j=0 ; j<n ; j++)
            {
                int sum=0;
                int mn = board[i][j];
                
                sum = value(board, i-1, j-1) + value(board, i-1, j) + value(board, i-1, j+1) + value(board, i, j+1)
                        + value(board, i+1, j+1) + value(board, i+1, j) + value(board, i+1, j-1) + value(board, i, j-1);
                if(mn==0 && sum==3)
                {
                    board[i][j]=-1;
                }
                else if(mn==1 && sum<2)
                {
                    board[i][j]=-2;
                }
                else if(mn==1 && sum>3)
                {
                    board[i][j]=-2;
                }
            }
        }
        
        for(int i=0 ; i<m ;i++)
        {
            for(int j=0; j<n; j++)
            {
                int mn = board[i][j];
                if(mn==-1 || mn==-2)
                    board[i][j]  = mn+ 2;
            }
        }
    }
    public int value(int[][] board, int i, int j)
    {
        int m = board.length;
        int n = board[0].length;
        
        if(i<0 || j<0 || i>m-1 || j> n-1)
            return 0;
        else
        {
            int current = board[i][j];
            if(current==-2)
                return 1;
            else if(current==-1)
                return 0;
            else
                return current;
        }
    }
}
/*Word Search in a Matrix / check if word can be created from the matrix of characters (Using Backtracking)*/
public class Solution {
    public boolean exist(char[][] board, String word) {
        for(int i=0; i<board.length; i++)
        {
            for(int j=0; j<board[0].length; j++)
            {
                if(exist(board, i , j, word, 0))
                    return true;
            }
        }
        return false;
    }
    private boolean exist(char [][] board, int i , int j , String word, int ind)
    {
        if(ind==word.length())
            return true;
         if(i>board.length-1 || i<0 || j<0 || j>board[0].length-1 || board[i][j]!=word.charAt(ind))
            return false;
        board[i][j]='*';
        boolean result = exist(board, i-1, j, word, ind+1) || exist(board, i+1, j, word, ind+1) || exist(board, i, j-1, word, ind+1) || exist(board, i, j+1, word, ind+1);
            
        board[i][j]=word.charAt(ind);
        return result;
    }
}
/*Rotate an image 90 degree / clockwise (first transpose and then swap horizontally)*/
public class Solution {
    
        public void rotate(int[][] matrix) {
//Transpose Matrix
        for(int i = 0; i<matrix.length; i++){
            for(int j = i; j<matrix[0].length; j++){
                int temp = 0;
                temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
//Swap horizontally
        for(int i =0 ; i<matrix.length; i++){
            for(int j = 0; j<matrix.length/2; j++){
                int temp = 0;
                temp = matrix[i][j];
                matrix[i][j] = matrix[i][matrix.length-1-j];
                matrix[i][matrix.length-1-j] = temp;
            }
        }
    }
}
/* Rotate an image 90 degree / clockwise (using some technique)*/
public class Solution {
    public void rotate(int[][] M) {
        for (int i = 0; i < (M.length+1)/2; i++) {
            for (int j = 0; j < M.length/2; j++) {
                int tmp = M[i][j];
                M[i][j] = M[M.length-j-1][i];
                M[M.length-j-1][i] = M[M.length-i-1][M.length-j-1];
                M[M.length-i-1][M.length-j-1] = M[j][M.length-i-1];
                M[j][M.length-i-1] = tmp;
            }
        }
    }
}
/*Min Path Sum / minpathsum / minsumpath / min sum path / minimumsum / minimum path sum/ minimum sum of path from one corner of matrix to another corner*/
public class Solution {
    public int minPathSum(int[][] grid) {
        for(int i=0 ; i <grid.length; i++)
        {
            for(int j=0; j<grid[0].length ; j++)
            {
                if(i==0 && j==0)
                    grid[i][j]=grid[i][j];
                else if(i==0 && j!=0)
                    grid[i][j]=grid[i][j] + grid[i][j-1];
                else if(i!=0 && j==0)
                    grid[i][j]=grid[i][j] + grid[i-1][j];
                else
                    grid[i][j] += Math.min(grid[i-1][j],grid[i][j-1]);
            }
        }
        return grid[grid.length-1][grid[0].length-1];
    }
}
/*Set Matrix Zero / set rows and coloumn to zero if one element is zero/ setmatrix zero*/
public class Solution {
    public void setZeroes(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        boolean fr = false, fc=false;
        
        for(int i=0; i<m ; i++)
        {
            for(int j=0 ; j<n ; j++)
            {
                if(matrix[i][j]==0)
                {
                    if(i==0)
                        fr=true;
                    if(j==0)
                        fc=true;
                    matrix[0][j]=0;
                    matrix[i][0]=0;
                }
            }
        }
        
        for(int i=1; i<m; i++)
        {
            for(int j=1; j<n ; j++)
            {
                if(matrix[i][0]==0 || matrix[0][j]==0)
                    matrix[i][j]=0;
            }
        }
        
        if(fr)
        {
            for(int j=0 ; j<n ; j++)
                {
                    matrix[0][j]=0;
                }
        }
        
        if(fc)
        {
            for(int i=0 ; i<m ; i++)
                {
                    matrix[i][0]=0;
                }
        }
        
    }
}
/*All sorting algorithms*/
package hardik.code;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map.Entry;

public class Sorting {
	
	public static void countingSort(int[] arr, int k)
	{
		int[] counts = new int[k];
		
		for(int i =0; i<k;i++)
		{
			counts[i] = 0;
		}
		
		for(int i =0; i < arr.length; i++)
		{
			counts[arr[i]] += 1;
		}
		
		int j =0;
		for(int m=0; m < counts.length;m++)
		{
			for(int n =0; n < counts[m] && j < arr.length; j++, n++)
			{
				arr[j] = m;
			}
		}
		
	}

	public static int[] bubbleSort(int[] A, int n) {
		int temp = 0;
		for (int pass = n - 1; pass >= 0; pass++) {
			for (int i = 0; i < pass; i++) {
				if (A[i] > A[i + 1]) {
					temp = A[i];
					A[i] = A[i + 1];
					A[i + 1] = temp;
				}
			}
		}
		return A;
	}

	public static int[] mergeSort(int[] A, int[] temp, int left, int right) {
		if (left < right) {
			int mid = (left + right) / 2;
			mergeSort(A, temp, left, mid);
			mergeSort(A,temp, mid+1, right);
			//always use mid and mid+1 instead of mid-1 and mid as integer division will provide floor value
			//Eg: In array of size 2, mid-1 and mid will become -1 and 0. It will break the algorithm
			merge(A,temp, left, mid+1, right);
		}

		return A;
	}

	private static void merge(int[] A,int[] temp, int left, int mid, int right) {
		int temp_pos = left;
		int left_end = mid - 1;
		int size = right - left +1;
		while (left <= left_end && mid <= right) {
			if (A[left] <= A[mid]) {
				temp[temp_pos++] = A[left++];
			} else {
				temp[temp_pos++] = A[mid++];
			}
		}
		while (left <= left_end) {
			temp[temp_pos++] = A[left++];
		}
		while (mid <= right) {
			temp[temp_pos++] = A[mid++];
		}
		for (int i = 0; i < size; i++) {
			A[right] = temp[right];
			right--;
		}
	}

	private static int[] mergeSortedArrays(int[] A, int[] B, int[] C) {
		int size = A.length + B.length;
		int[] temp = new int[size];
		int[] result = new int[size + C.length];
		mergeArrays(A, B, temp, 0);
		mergeArrays(temp, C, result, 0);
		return result;
	}

	private static void mergeArrays(int[] A, int[] B, int[] temp,
			int temp_pointer_position) {
		int i = 0, j = 0;
		while (i < A.length && j < B.length) {
			if (A[i] < B[j]) {
				temp[temp_pointer_position++] = A[i++];
			} else {
				temp[temp_pointer_position++] = B[j++];
			}
		}
		if (i == A.length && j != B.length) {
			while (j < B.length) {
				temp[temp_pointer_position++] = B[j++];
			}
		} else if (j == B.length && i != B.length) {
			while (i < A.length) {
				temp[temp_pointer_position++] = A[i++];
			}
		}
	}

	public static void quickSort(int[] A, int low, int high) {
		if (low < high) {
			int pivot = partition(A, low, high);
			if (low < pivot-1) {
				quickSort(A, low, pivot - 1);
			}
			if (high > pivot) {
				quickSort(A, pivot, high);
			}
		}
	}

	public static int quickSortFindMedian(int[] A, int low, int high, int k) {
		if (low < high) {
			int pivot = partition(A, low, high) - 1;
			if(pivot == k)
				return A[k];
			if (pivot < k)
					return quickSortFindMedian(A, pivot+1, high, k);
			else
					return quickSortFindMedian(A, low, pivot-1, k);
		}
		return -1;
	}

	static void findMaxOccurenceInArray(int[] a) {
		HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
		for (int i : a) {
			if (!map.containsKey(i))
				map.put(i, 1);
			else {
				int count = map.get(i) + 1;
				map.put(i, count);
			}
		}
		Iterator<Entry<Integer, Integer>> itr = map.entrySet().iterator();
		int maxCount = Integer.MIN_VALUE;
		int maxNumber = Integer.MIN_VALUE;
		while (itr.hasNext()) {
			Entry<Integer, Integer> entry = itr.next();
			if (entry.getValue() > maxCount) {
				maxCount = entry.getValue();
				maxNumber = entry.getKey();
			}
		}
		System.out.println("Number is :" + maxNumber + " count is : " + maxCount);
	}
	private static int partition(int[] a, int low, int high) {
		int left = low, right = high; 
		int pivot_item = a[((low + high) / 2)];//take a random number between low and high for randomized quick sort
		while (left <= right) {
			while (a[left] < pivot_item)
				left++;
			while (a[right] > pivot_item)
				right--;
			if (left <= right) {
				int temp = a[right];
				a[right] = a[left];
				a[left] = temp;
				left++;
				right--;
			}
		}
		return left;// For median return mid = ((low + high)/2)
	}


	public static void main(String[] args) {
		
		int[] Ar = {2,1};
		int[] tempr = new int[Ar.length];
		mergeSort(Ar,tempr,0,Ar.length-1);
		
		int[] arr = new int[] {1,1,1,2,2,2,2,0,0,0,2,0,1,2,0,2,1,0,2,1,0,2,1,0,2,1 };
		countingSort(arr,3);
		
		int[] A = new int[] { 1, 3, 5, 7, 8 };
		int[] B = new int[] { 2, 3, 6, 9 };
		int[] C = new int[] { 3, 6, 8, 9 };
		int[] temp = mergeSortedArrays(A, B, C);
		for (int i : temp) {
			System.out.print(i);
		}
		System.out.println();
		int[] array = new int[] {1,9,-4,7,6,11,3,2,10};
		int mid = quickSortFindMedian(array, 0, array.length - 1, (array.length)/2);
		System.out.println(mid);
		
		 quickSort(array, 0, array.length-1); 
		 for (int i : array) {
			 System.out.print(i + " "); 
		 }
		 C = new int[] { 3, 6, 8, 9 , 9,3,5,6,1,6};
		 findMaxOccurenceInArray(C);
		 
		 	ListNode node6 = new ListNode(5, null);
			ListNode node5 = new ListNode(7, node6);
			ListNode node4 = new ListNode(9, node5);
			ListNode node3 = new ListNode(10, node4);
			ListNode node2 = new ListNode(12, node3);
			ListNode node1 = new ListNode(15, node2);
			ListNode head = new ListNode(2, node1);
			ListNode tempNode = merge_sort_LinkedList(head);
			while (tempNode != null) {
				System.out.print(tempNode.getData() + " ");
				tempNode = tempNode.getNext();
			}

	}
	
	
	public static ListNode merge_sort_LinkedList(ListNode head) {
	    if(head == null || head.getNext() == null) { return head; }
	    ListNode middle = getMiddle(head);      //get the middle of the list
	    ListNode sHalf = middle.next; middle.next = null;   //split the list into two halfs
	    
	    head = merge_sort_LinkedList(head);
	    sHalf = merge_sort_LinkedList(sHalf);

	    return merge(head,sHalf);  //recurse on that
	}

	//Merge subroutine to merge two sorted lists
	public static ListNode merge(ListNode a, ListNode b) {
	    ListNode dummyHead, curr; dummyHead = new ListNode(); curr = dummyHead;
	    while(a !=null && b!= null) {
	        if(a.data <= b.data)
	        	{ curr.next = a; a = a.next; }
	        else 
	        	{ curr.next = b; b = b.next; }
	        curr = curr.next;
	    }
	    curr.next = (a == null) ? b : a;
	    return dummyHead.next;
	}

	//Finding the middle element of the list for splitting
	public static ListNode getMiddle(ListNode head) {
	    if(head == null) { return head; }
	    ListNode slow, fast; slow = fast = head;
	    while(fast.next != null && fast.next.next != null) {
	        slow = slow.next; fast = fast.next.next;
	    }
	    return slow;
	}
}
/*String Manipulation Questions*/
package hardik.code;

import java.util.Arrays;

public class StringManipulation {

	public static void determineUniqueCharacters(String string) {
		
		//Assumption that string is ASCII
		if (string.length() > 256) {
			System.out.println("Not all characters unique");
			return;
		}
		boolean[] charArray = new boolean[256];
		boolean isUnique = true;
		for (int i=0; i < string.length() ; i++) {
			if (charArray[(string.charAt(i))]) {
				isUnique = false;
				break;
			}
			charArray[(string.charAt(i))] = true;
		}
		if (!isUnique) {
			System.out.println("Not unique characters in String");
		} else {
			System.out.println("All characters in string are unique");
		}
	}
	
	public static String stringReverse(String inputString) {
		char[] chaArray = new char[inputString.length()];
		int j =0 ;
		for (int i = (inputString.length()-1); i >=0 ; i-- ){
			chaArray[j++] = inputString.charAt(i); 
		}
		return new String(chaArray);
	}
	
	public static void stringPermutation(String actualString, String permuted) {
		char[] actualCharArray = actualString.toLowerCase().toCharArray();
		char[] permutedCharArray = permuted.toLowerCase().toCharArray();
		Arrays.sort(actualCharArray);
		Arrays.sort(permutedCharArray);
		if (Arrays.equals(actualCharArray, permutedCharArray)) {
			System.out.println("String permutation");
		} else {
			System.out.println("String not permutation");
		}
	}
	
	public static void stringReplace(String actualString, Character charToBeReplaced, Character charToReplace) {
		char[] charArray = actualString.toCharArray();
		int spaceCount = 0;
		for (int i =0 ; i <charArray.length; i++) {
			if (' ' == charArray[i]) {
				spaceCount++;
			}
		}
		int newLength = charArray.length + spaceCount * 2;
		char[] replaceCharArray = new char[newLength];
		for (int i= (actualString.length() - 1); i >= 0 ; i--) {
			if (charArray[i] == ' ') {
				replaceCharArray[--newLength] = '0';
				replaceCharArray[--newLength] = '2';
				replaceCharArray[--newLength] = '%';
			} else {
				replaceCharArray[--newLength] = charArray[i];
			}
		}
		System.out.println("Replcaed String is " + new String(replaceCharArray));
	}
	
	public static void stringReplaceByMe(String actualString, Character charToBeReplaced, Character charToReplace) {
		
		int spaceCount = 0;
		for(int i=0; i < actualString.length(); i++)
		{
			if(actualString.charAt(i) == ' ')
				spaceCount++;
		}
		
		char[] finalString = new char[actualString.length() + 2*spaceCount];
		int finalStringIndex = 0;
		
		for(int i=0; i < actualString.length(); i++)
		{
			if(actualString.charAt(i) == ' ')
			{
				finalString[finalStringIndex] = '%';
				finalStringIndex++;
				finalString[finalStringIndex] = '2';
				finalStringIndex++;
				finalString[finalStringIndex] = '0';
			}
			else
				finalString[finalStringIndex] = actualString.charAt(i);
			
			finalStringIndex++;
		}
		
		System.out.println("Replcaed String is " + new String(finalString));
	}
	
	
	public static void countOccurences(String inputString) {
		StringBuffer sb = new StringBuffer();
		char c = inputString.charAt(0);
		int count = 1;
		for (int i = 1 ; i < inputString.length() ; i++) {
			if (c == inputString.charAt(i)) {
				count++;
			} else {
				sb.append(c);
				sb.append(count);
				c = inputString.charAt(i);
				count = 1;
				
			}
		}
		sb.append(c).append(count);
		if(sb.toString().length() > inputString.length()) {
			System.out.println("Returned String is " + inputString);
		} else {
			System.out.println("Returned String is " + sb.toString());
		}
	}
	
	public static void countOccurencesByMe(String inputString) {
		
		StringBuffer str = new StringBuffer();
		char currentchar = ' ';
		int currentCount = 1;
		
		for(int i = 0; i < inputString.length(); i++)
		{
			currentchar = inputString.charAt(i);
			str.append(currentchar);
			
			i++;
			while(i < inputString.length() && currentchar == inputString.charAt(i))
			{
				i++;
				currentCount++;
			}
			
			str.append(currentCount);
			
			if(str.length() >= inputString.length())
				return;
			
			i--;
			currentCount = 1;
		}
		
		System.out.println("Returned String is " + str.toString());
	}
	
	
	public static void main(String[] args) {
		/*determineUniqueCharacters("abcda");
		System.out.println("Reverse string is " + stringReverse("abcdabcd"));
		stringPermutation("&*()", ")(&a");
		stringReplace("Mr Bean Is a Guy ", ' ', ' ');
		countOccurences("abcd");*/
		
		stringReplaceByMe("Mr Bean Is a Guy ", ' ', ' ');
		countOccurencesByMe("aabbccdd");
	}
	
	
}

/*Trees Questions of Hardik*/
package hardik.code;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Stack;

public class TreeExamples {
	
	public static int getDepthOfNode(BinaryTreeNode root, int data)
	{
		int left, right;
		if(root == null)
			return 0;
		else
		{
			if(root.getData() == data)
				return 1;
			else
			{
				left =getDepthOfNode(root.getLeft(), data);
				if(left >= 1)
					return left +1;
				right = getDepthOfNode(root.getRight(), data);
				if(right >= 1)
					return right +1;
				
				return 0;
			}
		}
	}
	
	private static int getMaxSum(BinaryTreeNode root, int sum)
	{
		int left, right;
		if(root == null)
			return sum;
		
		if(root.getData() + sum > sum)
			sum = root.getData() +sum;
		
		left = getMaxSum(root.getLeft(), sum);
		right = getMaxSum(root.getRight(), sum);
		
		
		return left>right?left:right;
	}
	
	public static void preOrder(BinaryTreeNode root) {
		Stack<BinaryTreeNode> s = new Stack<BinaryTreeNode>();
		while(true) {
			while (root != null) {
				System.out.println(root.getData());
				s.push(root);
				root = root.getLeft();
			}
			if (s.isEmpty())
				break;
			root = s.pop();
			root = root.getRight();
		}
		return;
	}
	
	public static void inOrder(BinaryTreeNode root) {
		Stack<BinaryTreeNode> s = new Stack<BinaryTreeNode>();
		while(true) {
			while (root != null) {
				s.push(root);
				root = root.getLeft();
			}
			if (s.isEmpty())
				break;
			root = s.pop();
			System.out.print(root.getData() + " ");
			root = root.getRight();
		}
	}
	
	public static void postOrder(BinaryTreeNode root) {
		Stack<BinaryTreeNode> s = new Stack<BinaryTreeNode>();
		while(true) {
			while (root != null) {
				if (root.getRight() != null)
					s.push(root.getRight());
				s.push(root);
				root = root.getLeft();
			}
			if (s.isEmpty())
				return;
			else {
				root = s.pop();
				if (root.getRight() != null && !s.isEmpty() && s.peek().equals(root.getRight())) {
					s.pop();
					s.push(root);
					root = root.getRight();
				} else {
					System.out.println(root.getData());
					root = null;
				}
			}
		}
	}
	
	public static void levelOrder(BinaryTreeNode root) {
		if (root == null) 
			return;
		Queue<BinaryTreeNode> q= new LinkedList<BinaryTreeNode>();
		q.add(root);
		while (!q.isEmpty()) {
			root = q.poll();
			System.out.print(root.getData() + " ");
			if (root.getLeft() != null) {
				q.add(root.getLeft());
			}
			if (root.getRight() != null)
				q.add(root.getRight());
		}
	}
	
	public static boolean findElement(BinaryTreeNode root, int data) {
		boolean temp; 
		if (root == null) 
			return false;
		if (root.getData() == data) {
			System.out.println("Data Found");
			return true;
		} else {
			temp = findElement(root.getLeft(), data);
			if (temp) {
				return true;
			} else {
				return findElement(root.getRight(), data);
			}
		}
	}
	
	public static int sizeofTree(BinaryTreeNode root) {
		if(root == null)
			return 0;
		else
			return (sizeofTree(root.getLeft()) + 1 + sizeofTree(root.getRight())); 
	}
	
	
	public static int hightofTreeRecursive(BinaryTreeNode root) {
		int left, right;
		if(root == null)
			return 0;
		else {
			left = hightofTreeRecursive(root.getLeft());
			right = hightofTreeRecursive(root.getRight());
			if (left >= right) 
				return (left + 1);
			else 
				return (right + 1);
		}
	}
	
	public static int hightofTreeIterative(BinaryTreeNode root) {
		int level =0;
		if(root == null)
			return 0;
		else {
			Queue<BinaryTreeNode> q = new LinkedList<BinaryTreeNode>();
			q.add(root);
			q.add(null);
			while (!q.isEmpty()) {
				root = q.poll();
				if (root == null) {
					if (!q.isEmpty()) {
						q.add(null);
					}
					level++;
				} else {
					if (root.getLeft() != null)
						q.add(root.getLeft());
					if (root.getRight() != null)
						q.add(root.getRight());
				}
			}
		}
		return level;
	}
	public static void levelOrderReverse(BinaryTreeNode root) {
		if (root == null) 
			return;
		Queue<BinaryTreeNode> q= new LinkedList<BinaryTreeNode>();
		Stack<BinaryTreeNode> s = new Stack<BinaryTreeNode>();
		q.add(root);
		while (!q.isEmpty()) {
			root = q.poll();
			s.push(root);
			if (root.getRight() != null)
				q.add(root.getRight());
			if (root.getLeft() != null) {
				q.add(root.getLeft());
			}
		}
		while (!s.isEmpty()) {
			System.out.println(s.pop().getData());
		}
	}
	
	public static BinaryTreeNode  deleteElementFromTree(BinaryTreeNode root, int data) {
		if (root == null)
			return root;
		if (root.getData() == data) {
			root = null;
			return root;
		}
			
		BinaryTreeNode lastNode = null, temp;
		Queue<BinaryTreeNode> q= new LinkedList<BinaryTreeNode>();
		q.add(root);
		lastNode = findDeepestNode(root);
		while (!q.isEmpty()) {
			temp = q.poll();
			if (temp.getData() == data) {
				System.out.println("Deepest node is :" + lastNode.getData());
				temp.setData(lastNode.getData());
				//find parent node
			}
			//System.out.println(temp.getData());
			if (temp.getLeft() != null && !temp.getLeft().equals(lastNode)) {
				q.add(temp.getLeft());
			} else if(temp.getLeft() != null && temp.getLeft().equals(lastNode)) {
				temp.setLeft(null);
			}
			if (temp.getRight() != null && !temp.getRight().equals(lastNode)) {
				q.add(temp.getRight());
			} else if(temp.getRight() != null && temp.getRight().equals(lastNode)) {
				temp.setRight(null);
			}
		}
		return root;
	}
	
	
	public static BinaryTreeNode findDeepestNode(BinaryTreeNode root) {
		if (root == null) 
			return null;
		Queue<BinaryTreeNode> q= new LinkedList<BinaryTreeNode>();
		q.add(root);
		while (!q.isEmpty()) {
			root = q.poll();
			if (root.getLeft() != null) {
				q.add(root.getLeft());
			}
			if (root.getRight() != null)
				q.add(root.getRight());
		}
		return root;
		
	}
		
	public static long getDiameter(BinaryTreeNode root) {
        if (root != null) {
            long leftDiameter = getDiameter(root.getLeft());
            long rightDiameter = getDiameter(root.getRight());
            long leftHeight = getHeight(root.getLeft());
            long rightHeight = getHeight(root.getRight());
            return Math.max(leftHeight + rightHeight + 1, Math.max(leftDiameter, rightDiameter));
        }
        return 0;
    }

    public static long getHeight(BinaryTreeNode root) {
        if (root != null) {
            long leftHeight = getHeight(root.getLeft());
            long rightHeight = getHeight(root.getRight());
            return  1 + Math.max(leftHeight, rightHeight);
        }
        return 0;
    }
    
    public static void printAllPaths(BinaryTreeNode root, int[] path, int pathLen) {
    	if (root == null) return;
    	path[pathLen++] = root.getData();
    	if (root.getLeft() == null && root.getRight() == null) {
    		for (int i = 0 ; i < pathLen; i++)
    			System.out.print(path[i]);
    		System.out.println();
    	} else {
    		printAllPaths(root.getLeft(), path, pathLen);
    		printAllPaths(root.getRight(), path, pathLen);
    	}
    	
    }
    
    static void printnPathToNode(BinaryTreeNode root, BinaryTreeNode node, int[] path, int len) {
    	if (root == null || node == null) {
    		return;
    	}
    	path[len++] = root.getData();
    	if (root == node) {
    		for (int i= 0; i < len; i++) {
    			System.out.print(path[i] + " ");
    		}
    	}
    	printnPathToNode(root.getLeft(), node, path, len);
    	printnPathToNode(root.getRight(), node, path, len);
    }
    
    public static BinaryTreeNode findLCA(BinaryTreeNode root, BinaryTreeNode node1, BinaryTreeNode node2) {
    	BinaryTreeNode left, right;
    	if (root == null)
    		return root;
    	if (root.equals(node1) || root.equals(node2)) {
    		return root;
    	}
    	left = findLCA(root.getLeft(), node1, node2);
    	right = findLCA(root.getRight(), node1, node2);
    	if (left != null && right != null)
    		return root;
    	else 
    		return (left != null ? left : right);
    }
    
    
    public static BinaryTreeNode preOrderChar(char[] ch, int i) {
    	if (ch == null) return null;
    	BinaryTreeNode node = new BinaryTreeNode();
    	node.setData(ch[i]);
    	if (ch[i] == 'L')
    		return node;
    	node.setLeft(preOrderChar(ch, ++i));
    	node.setRight(preOrderChar(ch, ++i));
    	return node;
    	
    }
    public static void zigZagTraversal(BinaryTreeNode root) {
    	if (root == null)
    		return;
    	Stack<BinaryTreeNode> s = new Stack<BinaryTreeNode>();
    	s.push(root);
    	boolean b = true;
    	while (!s.isEmpty()) {
    		Stack<BinaryTreeNode> t = new Stack<BinaryTreeNode>();
    		while (!s.isEmpty()) {
    			BinaryTreeNode temp = s.pop();
        		System.out.print(temp.getData() + "\t");
    			if (b) {
    				if (temp.getLeft() != null)
    					t.push(temp.getLeft());
    				if (temp.getRight() != null)
    					t.push(temp.getRight());
    			} else {
    				if (temp.getRight() != null)
    					t.push(temp.getRight());
    				if (temp.getLeft() != null)
    					t.push(temp.getLeft());
    			}
    		}
    		b = !b;
    		s = t;
    	}
    }
    
    public static boolean isBST(BinaryTreeNode root, int min, int max) {
    	if (root == null) return true;
    	if (root.getData() <= min || root.getData() >= max)
    		return false;
    	return (isBST(root.getLeft(), min, root.getData()) && isBST(root.getRight(), root.getData(), max));
    }
    
    public static BinaryTreeNode convertListToBST(Iterator<Integer> it, int start, int end) {
    	
    	if (start > end)
    		return null;
    	int mid = start + (end-start)/2;
    	BinaryTreeNode node = new BinaryTreeNode();
    	node.setLeft(convertListToBST(it, start, mid-1));
    	node.setData(it.next());
    	node.setRight(convertListToBST(it, mid + 1, end));
    	return node;
    	
    }
    
    public static BinaryTreeNode convertArrayToBST(int[] array, int start, int end) {
    	if (start > end) return null;
    	BinaryTreeNode node = new BinaryTreeNode();
   		int mid = start + (end - start)/2;
   		node.setLeft(convertArrayToBST(array, start, mid-1));
   		node.setData(array[mid]);
   		node.setRight(convertArrayToBST(array, mid + 1, end));
    	return node;
    }
    
    public static BinaryTreeNode convertToLL(BinaryTreeNode root, BinaryTreeNode currentNode)
    {
 	   if(root == null)
 		   return currentNode;
 	   else
 	   {
 		   currentNode = convertToLL(root.getLeft(), currentNode);
 		   if(currentNode != root)
 		   {
 			   currentNode.setRight(root);
 			   root.setLeft(currentNode);
 			   currentNode = root;
 		   }
 		   return convertToLL(root.getRight(), currentNode);
 	   }
    }
    
    public static BinaryTreeNode findPredecessor(BinaryTreeNode node)
    {
    	return null;
    	/*
        if (node == null)
            return null;
        
        if (node.getLeft() != null)
            return findMaximum(node.getLeft());
                
        TreeNode parent = node.getParent();
    
        TreeNode y = parent;
        TreeNode x = node;
        while (y != null && x == y.getLeft())
        {
            x = y;
            y = y.getParent();
        }
        
        return y;
        */
    }
    
    public static BinaryTreeNode findSuccessor(BinaryTreeNode node)
    {
    	return null;
    	/*
        if (node == null)
            return null;
        
        if (node.getRight() != null)
            return findMinimum(node.getRight());
        
        BinaryTreeNode y = node.getParent();
        BinaryTreeNode x = node;
        while (y != null && x == y.getRight())
        {
            x = y;
            y = y.getParent();
        }
        // Intuition: as we traverse left up the tree we traverse smaller values
        // The first node on the right is the next larger number
        return y;
        */
    }
    
    public static int isTreeBalanced (BinaryTreeNode root) {
    	if (root == null) {
    		return 0;
    	}
    	int leftHeight = isTreeBalanced(root.getLeft());
    	if (leftHeight == -1)
    		return -1;
    	int rightHeight = isTreeBalanced(root.getRight());
    	if (rightHeight == -1)
    		return -1;
    	if (Math.abs(leftHeight - rightHeight) > 1)
    		return -1;
    	else
    		return (Math.max(leftHeight, leftHeight) + 1);
    }
    
    public static void levelOrderLinkedList(BinaryTreeNode root, LinkedList<LinkedList<BinaryTreeNode>> list) {
		LinkedList<BinaryTreeNode> levelList = new LinkedList<BinaryTreeNode>(); 
		if (root != null)
			levelList.add(root);
		while (levelList.size() > 0) {
			list.add(levelList);
			LinkedList<BinaryTreeNode> parentLevel = levelList;
			levelList = new LinkedList<BinaryTreeNode>();
			for (BinaryTreeNode node : parentLevel) {
				if(node.getLeft() != null)
					levelList.add(node.getLeft());
				if(node.getRight() != null)
					levelList.add(node.getRight());
			}
		}
    }
    
    public static BinaryTreeNode findCommonAnsector(BinaryTreeNode root, BinaryTreeNode a, BinaryTreeNode b) {
    	if (root == null)
    		return root;
    	if (root == a || root == b)
    		return root;
    	BinaryTreeNode left = findCommonAnsector(root.getLeft(), a, b);
    	BinaryTreeNode right = findCommonAnsector(root.getRight(), a, b);
    	if (left!= null && right != null) 
    		return root;
    	else 
    		return (left != null?left : right);
    }
    
    public static boolean isSubTree(BinaryTreeNode tree1, BinaryTreeNode tree2) {
    	if (tree1 == null)
    		return false;
    	if (tree2 == null)
    		return true;
    	if (tree1.getData() == tree2.getData()) {
    		return (isSubTreeHelper(tree1, tree2));
    	} else {
    		return (isSubTree(tree1.getLeft(), tree2) || isSubTree(tree1.getRight(), tree2));
    	}
    }
	private static boolean isSubTreeHelper(BinaryTreeNode tree1,
			BinaryTreeNode tree2) {
		if (tree1 == null && tree2 == null)
			return true;
		if (tree1 == null || tree2 == null)
			return false;
		return (tree1.getData() == tree2.getData() && isSubTreeHelper(tree1.getLeft(), tree2.getLeft()) && isSubTreeHelper(tree1.getRight(), tree2.getRight()));
	}
	
	static void kThSmallest(BinaryTreeNode root, int count, int k) {
		if (root == null || k < 0) {
			return;
		}
		kThSmallest(root.getLeft(),count,k);
		--k;
		if(k == 0) {
			System.out.println("Kth smallest element is :" + root.getData());
			return;
		}
		kThSmallest(root.getRight(), count, k);
	}

	static void isCousine(BinaryTreeNode root, BinaryTreeNode node1, BinaryTreeNode node2) {
		if (node1 == null || node2 == null)
			System.out.println("Not cousine");
		if (findLevel(root, node1, 1) == findLevel(root, node2, 1)
				&& !isSiblings(root, node1, node2))
			System.out.println("Cousines of eachother");
		else 
			System.out.println("Not cousines");
	}
	
	static int findLevel(BinaryTreeNode root, BinaryTreeNode node, int level) {
		if (root == null) {
			return -1;
		}
		if (root == node)
			return level;
		int leftLevel = findLevel(root.getLeft(), node, level + 1);
		if (leftLevel != -1)
			return leftLevel;
		
		return findLevel(root.getRight(), node , level + 1);
	}
	
	static boolean isSiblings(BinaryTreeNode root, BinaryTreeNode node1, BinaryTreeNode node2) {
		if (root == null)
			return false;
		return ((root.getLeft() == node1 && root.getRight() == node2)
				||(root.getRight() == node1 && root.getLeft() == node2)
				|| isSiblings(root.getLeft(), node1, node2)
				|| isSiblings(root.getRight(), node1, node2));
	}
	
	public static void main(String[] args) {
		BinaryTreeNode root1 = new BinaryTreeNode();
		root1.setData(18);
		BinaryTreeNode root2 = new BinaryTreeNode();
		root2.setData(22);
		BinaryTreeNode root3 = new BinaryTreeNode();
		root3.setData(16);
		BinaryTreeNode root4 = new BinaryTreeNode();
		root4.setData(19);
		BinaryTreeNode root5 = new BinaryTreeNode();
		root5.setData(21);
		BinaryTreeNode root6 = new BinaryTreeNode();
		root6.setData(23);
		BinaryTreeNode root7 = new BinaryTreeNode();
		root7.setData(15);
		BinaryTreeNode root8 = new BinaryTreeNode();
		root8.setData(25);
		BinaryTreeNode root9 = new BinaryTreeNode();
		root9.setData(17);
		BinaryTreeNode root = new BinaryTreeNode();
		root.setData(20);
		root.setLeft(root1);
		root.setRight(root2);
		root1.setLeft(root3);
		root1.setRight(root4);
		root2.setLeft(root5);
		root2.setRight(root6);
		root3.setLeft(root7);
		root3.setRight(root9);
		root6.setRight(root8);
		zigZagTraversal(root);
		System.out.println("-----------Get max sum-------------");
		System.out.println(getMaxSum(root, 0));
		System.out.println("-----------Cousines-------------");
		isCousine(root, root9, root6);
		System.out.println("-----------Kth Smallest-------------");
		kThSmallest(root, 0, 1);
		System.out.println("-----------PreOrder-------------");
		preOrder(root);
		System.out.println("--------------------------------");
		System.out.println("-----------InOrder-------------");
		inOrder(root);
		System.out.println("--------------------------------");
		System.out.println("-----------PostOrder-------------");
		postOrder(root);
		System.out.println("--------------------------------");
		System.out.println("-----------LevelOrder-------------");
		levelOrder(root);
		System.out.println("--------------------------------");
		System.out.println("----------Find Element Recursive-----------");
		findElement(root, 40);
		System.out.println("--------------------------------");
		System.out.println("----------Size of tree Recursive-------------");
		System.out.println("Size of tree is " + sizeofTree(root));
		System.out.println("--------------------------------");
		System.out.println("-----------LevelOrderReverse-------------");
		levelOrderReverse(root);
		System.out.println("--------------------------------");
		System.out.println("----------Height of tree Recursive-------------");
		System.out.println("Height of tree is " + hightofTreeRecursive(root));
		System.out.println("--------------------------------");
		System.out.println("----------Height of tree Iterative-------------");
		System.out.println("Height of tree is " + hightofTreeIterative(root));
		System.out.println("--------------------------------");
		if(isBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE))
			System.out.println("It is binary search tree");
		else 
			System.out.println("Not a binary serarch tree");
		LinkedList<LinkedList<BinaryTreeNode>> result = new LinkedList<LinkedList<BinaryTreeNode>>();
		levelOrderLinkedList(root, result);
		for (LinkedList<BinaryTreeNode> l : result) {
			for (BinaryTreeNode btn : l) {
				System.out.print(btn.getData());
			}
			System.out.println();
		}
		BinaryTreeNode nd = findCommonAnsector(root, root5, root7);
		root = deleteElementFromTree(root, 17);
		levelOrder(root);
		BinaryTreeNode temp = new BinaryTreeNode();
		temp.setData(18);
		
		temp = deleteElementFromTree(temp, 18);
		levelOrder(temp);
		
		System.out.println("Diameter is " + getDiameter(root));
		printAllPaths(root, new int[256], 0);
		System.out.println("Path to node is ");
		printnPathToNode(root, root3, new int[256], 0);
		System.out.println();
		System.out.println("LCA is :" + findLCA(root, root3, root4).getData());
		System.out.println("-----------Zigzag-------------");
		zigZagTraversal(root);
		System.out.println();
		System.out.println("------------------------------");
		temp = preOrderChar(new char[] {'I', 'L', 'I', 'L', 'L'}, 0);
		levelOrder(temp);
		root7.setRight(root8);
		if(isBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE))
			System.out.println("It is binary search tree");
		else 
			System.out.println("Not a binary serarch tree");
		int[] array = new int[]{2,3,4,5,6,7,8,9,10};
		List<Integer> list = Arrays.asList(new Integer[]{2,3,4,5,6,7,8,9,10});
		BinaryTreeNode node1 = convertListToBST(list.iterator(), 0, list.size() - 1);
		levelOrder(node1);
		BinaryTreeNode node2 = convertArrayToBST(array, 0, array.length - 1);
		levelOrder(node2);
		
		BinaryTreeNode node = new BinaryTreeNode();
		node.setLeft(root1);
		//node.setRight(root2);
		root1.setLeft(root3);
		root3.setRight(root4);
		root4.setRight(root5);
		if(isTreeBalanced(node) != -1) {
			System.out.println("The Tree is balanced");
		} else {
			System.out.println("The tree is not balanced");
		}
		if (nd != null) {
			System.out.println("common ansector is : " + nd.getData());
		}
		if (isSubTree(root, node2)){
			System.out.println("Subtree of a given tree");
		} else {
			System.out.println("Not a subtree");
		}
		int[] array1 = new int[(int) getHeight(node1)];
		printPathWithSum(node1, 21 , array1, 0);
	}
	
	/*
	private static void findAllPathsOfSum(BinaryTreeNode root, int sum,
			int[] path, int level) {
		if(root == null)
			return;
		
		path[level] = root.getData();
	
		int currentSum = 0;
		for(int i = level; i >=0; i--)
		{
			currentSum += path[i];
		if(currentSum == sum)
			printPath(path, i, level);
		}
		findAllPathsOfSum(root.getLeft(),sum,  path, level +1);
		findAllPathsOfSum(root.getRight(),sum,  path, level + 1);
	}
	*/

	static void printPathWithSum(BinaryTreeNode root, int sum, int[] array, int len) {
		if (root == null) {
			return;
		} else {
			array[len] = root.getData();
			int pathSum = 0;
			for (int i = len ; i >=0 ; i--) {
				pathSum += array[i];
				if (pathSum == sum) {
					printPath(array, i, len);
				}
			}
			printPathWithSum(root.getLeft(), sum, array, len + 1);
			printPathWithSum(root.getRight(), sum, array, len + 1);
			array[len] = Integer.MIN_VALUE;
		}
		
	}
	

	private static void printPath(int[] array, int i, int len) {
		for (int j = i ; j <= len ; j++) {
			System.out.print(array[j] + " ");
		}
		System.out.println();
		
	}
	

}
/*Permute arraylist*/
public static ArrayList<ArrayList<Integer>> permuteArray(ArrayList<Integer> a){
			ArrayList<ArrayList<Integer>> arrL = new ArrayList<>();
			if(a.size()==1)
			{
				ArrayList<Integer> t = new ArrayList<>();
				t.add(a.get(0));
				arrL.add(t);
				return arrL;
			}
			int x = a.get(0);
			ArrayList<Integer> t = new ArrayList<>();
			for(int i=1;i<a.size();i++)
				t.add(a.get(i));
			ArrayList<ArrayList<Integer>> temp = permuteArray(t);
			for(int i=0;i<temp.size();i++){
				ArrayList<Integer> y = temp.get(i);
				for(int j=0;j<y.size();j++){
					ArrayList<Integer> z = new ArrayList<>();
					for(int k=0;k<y.size();k++){
						if(j==k)
							z.add(x);
						z.add(y.get(k));
					}
					arrL.add(z);
				}
				y.add(x);
				arrL.add(y);
			}
			return arrL;
		}

/*Permutation of Strings*/
public static ArrayList<String> getPermutations(String s){
			if(s==null)
				return null;
			ArrayList<String> a = new ArrayList<>();
			if(s.length()==1)
				a.add(s);
			else{
				char c = s.charAt(0);
				String str="";
				for(int j=0;j<s.length();j++)
					if(j!=0)
						str+=s.charAt(j);
				ArrayList<String> t = getPermutations(str);
				for(int j=0;j<t.size();j++){
					String string = t.get(j);
					String temp="";
					for(int k=0;k<string.length();k++){
						temp="";
						for(int l=0;l<string.length();l++){
							if(l==k)
								temp+=c;
							temp+=string.charAt(l);
						}
						a.add(temp);
					}
					a.add(string+c);
				}
			}
			return a;
		}

/*Questions related to Searching*/
package hardik.code;

public class Searching {

	//need a sorted array
	public static void searchMaxOccurence(int[] A) {
		int   currentElement = A[0], maxElement = 0;
		int currentCount = 0, maxCount = 0;
		for (int i = 0; i < A.length; i++) {
			if(A[i] == currentElement) {
				currentCount++;
			} else {
				currentElement = A[i];
				currentCount = 1;
			}
			if (currentCount > maxCount) {
				maxCount = currentCount;
				maxElement = currentElement;
			}
		}
		System.out.println("Max Element " + maxElement + "Max Count " + maxCount);
	}
	
	public static int indexOfFirstOccurence(int[] A, int left, int right, int data) {
		if(left<=right) {
			int mid = left + (right - left)/2;
			if ((A[mid] == data && mid == left) || (A[mid] == data && A[mid-1] < A[mid])) {
				return mid;
			} else if (A[mid] >= data) {
				return indexOfFirstOccurence(A, left, mid-1, data);
			} else {
				return indexOfFirstOccurence(A, mid+1, right, data);
			} 
		}
		return -1;
	}
	
	public static int singleElementWithAllOtherEven(int[] A) {
		int res = 0;
		for (int i=0; i < A.length ; i++ ) {
			res = res ^ A[i];
		}
		return res;
	}
	public static void main(String[] args) {
		int[] A = new int[] {1,2,2,2,2,3,3,3,4,4,4};
		searchMaxOccurence(A);
		System.out.println("Index of First Occurence" + indexOfFirstOccurence(A, 0, (A.length-1), 2));
		int[] B = new int[] {1,2,2,3,5,3,4,4,1};
		System.out.println("Alone element is :" + singleElementWithAllOtherEven(B));
	}
}

/*Longest palindrome in a string*/
package hardik.code;

public class LongestPalindrome {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
	String S= "abcdcba";
	printLongestPalindrome(S);
	}
	
	
	public static void printLongestPalindrome(String S)
	{
		int maxBack=-1;
		int maxFront = -1;
		int maxLength=0;
		for (int potentialCenter = 0 ; potentialCenter < S.length();potentialCenter ++ )
		{	
			int back = potentialCenter-1;
			int front = potentialCenter + 1;
			int longestPalindrome = 0;
			while(back >=0 && front<S.length() && S.charAt(back)==S.charAt(front))
			{
				back--;
				front++;
				longestPalindrome++;
				
			}
			if (longestPalindrome > maxLength)
			{
				maxLength = longestPalindrome+1;
				maxBack = back + 1;
				maxFront = front;
			}
			back = potentialCenter;
			front = potentialCenter + 1;
			longestPalindrome=0;
			while(back >=0 && front<S.length() && S.charAt(back)==S.charAt(front))
			{
				back--;
				front++;
				longestPalindrome++;
			}
			if (longestPalindrome > maxLength)
			{
				maxLength = longestPalindrome;
				maxBack = back + 1;
				maxFront = front;
			}
			
		}
		
		
		if (maxLength == 0) System.out.println("There is no Palindrome in the given String");
		else{
			System.out.println("The Longest Palindrome is " + S.substring(maxBack,maxFront) + "of " + maxLength);
		}
	}

}

/*List questions by hardik*/
package hardik.code;

import java.util.HashMap;
import java.util.Stack;

public class ListNodeExamples {

	static int findLength(ListNode head) {
		int length = 0;
		while (head != null) {
			head = head.getNext();
			length++;
		}
		return length;
	}
	
	static void printList(ListNode head) {
		while (head != null) {
			System.out.print(head.getData() + "->");
			head = head.getNext();
		}
	}
	
	public static ListNode mergeLinkedList(ListNode node1, ListNode node2)
	{
		if(node1 == null)
			return node2;
		if(node2 == null)
			return node1;
			
		ListNode head = new ListNode();
		ListNode currNode = head;
		ListNode node = null;
		while(node1 != null && node2 != null)
		{
			ListNode newNode = new ListNode();
			if(node1.getData() <= node2.getData())
			{
				newNode.setData(node1.getData());
				node1 = node1.getNext();
			}
			else
			{
				newNode.setData(node2.getData());
				node2 = node2.getNext();
			}	
			currNode.setNext(newNode);
			currNode =newNode;
		}
		
		if(node1 == null)
			 node = node2;	
		else
			 node = node1;	
		
		while(node!=null)
			{
				ListNode newNode = new ListNode();
				newNode.setData(node.getData());
				node = node.getNext();
				currNode.setNext(newNode);
				currNode =newNode;
			}
		
		node = head;
		head = head.getNext();
		currNode.next = null;
		node = null;
		
		printList(head);
		
		return head;
		
	}
	
	public static ListNode mergeSortUsingRecursion(ListNode node1, ListNode node2){
		
		ListNode result= null;
		if(node1 == null)
			return  node2;
		if(node2 == null)
			return node1;
		
		if(node1.getData() <= node2.getData())
		{
			result = node1;
			result.setNext(mergeSortUsingRecursion(node1.getNext(), node2));
		}
		else
		{
			result = node2;
			result.setNext(mergeSortUsingRecursion(node1, node2.getNext()));
		}
		
		return result;
	}
	
	public static ListNode mergeSortUsingIteration(ListNode a, ListNode b) {
	    ListNode dummyHead, curr; dummyHead = new ListNode(); curr = dummyHead;
	    while(a !=null && b!= null) {
	        if(a.data <= b.data)
	        	{ curr.next = a; a = a.next; }
	        else 
	        	{ curr.next = b; b = b.next; }
	        curr = curr.next;
	    }
	    curr.next = (a == null) ? b : a;
	    return dummyHead.next;
	}
	
	static ListNode insertElement(ListNode head, int position, ListNode newNode) {
		if (head == null) {
			head = newNode;
			return head;
		}
		if (position == 1) {
			newNode.setNext(head);
			return newNode;
		} else {
			ListNode temp = head, nextNode;
			int count = 1;
			while (count < position - 1) {
				temp = temp.getNext();
				count++;
			}
			nextNode = temp.getNext();
			newNode.setNext(nextNode);
			temp.setNext(newNode);
		}
		
		return head;
	}
	
	static void findNthNodeFromEnd(ListNode head, int n) {
		int length = findLength(head);
		if (n > length || n <=0 || head == null)
			return;
		for (int i =0 ; i < length - n ; i++) {
			head = head.getNext();
		}
		System.out.println("nth node is : " + head.getData());
	}
	
	static void findNthNodeFromEndInOneScan(ListNode head, int n) {
		if(head == null || n <0)
				return;
		ListNode intialPtr = head;
		ListNode finalPtr = head;
		
		for(int i=1; i <n; i++)
		{
			if(intialPtr!=null)
				intialPtr = intialPtr.next; 
		}
		
		if(intialPtr == null)
			System.out.println("Out of bounds");
		else
		{
			while(intialPtr.next != null)
			{
				intialPtr = intialPtr.next;
				finalPtr = finalPtr.next;
			}
			System.out.println("nth node is : " + finalPtr.getData());
		}
		
	}
	
	static int findKthNodeFromEndUsingRecursion(ListNode head, int k, Integer i) {
		if (head == null)
			return i;
		i = findKthNodeFromEndUsingRecursion(head.getNext(), k, i);
		i = i + 1;
		if (i == k) {
			System.out.println("Kth Node is :" + head.getData());
			return i;
		}
		return i;
	}
	static void findCycle(ListNode head) {
		if (head == null)
			System.out.println("No Cycle");
		ListNode fastPtr = head, slowPtr = head;
		boolean loopExists = false;
		while (fastPtr != null && fastPtr.getNext() != null) {
			fastPtr = fastPtr.getNext().getNext();
			slowPtr = slowPtr.getNext();
			if (slowPtr == fastPtr) {
				System.out.println("There is a Cycle");
				loopExists = true;
				break;
			}
		}
		if (!loopExists)
			System.out.println("No Cycle");
	}
	
	static void findStartOfCycle(ListNode head) {
		if (head == null)
			System.out.println("No Cycle");
		ListNode fastPtr = head, slowPtr = head;
		boolean loopExists = false;
		while (fastPtr != null && fastPtr.getNext() != null) {
			fastPtr = fastPtr.getNext().getNext();
			slowPtr = slowPtr.getNext();
			if (slowPtr == fastPtr) {
				System.out.println("There is a Cycle");
				loopExists = true;
				break;
			}
		}
		if (loopExists) {
			slowPtr = head;
			while (slowPtr != fastPtr) {
				slowPtr = slowPtr.getNext();
				fastPtr = fastPtr.getNext();
			}
			System.out.println("Start of the loop is : " + slowPtr.getData());
		}
			
	}
	static void findNodeCountInCycle(ListNode head) {
		if (head == null)
			System.out.println("No Cycle");
		ListNode fastPtr = head, slowPtr = head;
		boolean loopExists = false;
		while (fastPtr != null && fastPtr.getNext() != null) {
			fastPtr = fastPtr.getNext().getNext();
			slowPtr = slowPtr.getNext();
			if (slowPtr == fastPtr) {
				System.out.println("There is a Cycle");
				loopExists = true;
				break;
			}
		}
		if (loopExists) {
			int count = 1;
			fastPtr = fastPtr.getNext();
			while (slowPtr != fastPtr) {
				fastPtr = fastPtr.getNext();
				count++;
			}
			System.out.println("Node count in loop is : " + count);
		}
			
	}
	
	static void EvenOddLength(ListNode head) {
		if (head == null)
			System.out.println("No Cycle");
		ListNode fastPtr = head, slowPtr = head;
		while (fastPtr.next != null && fastPtr.getNext().getNext() != null) {
			fastPtr = fastPtr.getNext().getNext();
			slowPtr = slowPtr.getNext();
		}
		if (fastPtr.next == null) {
			System.out.println("Odd Length List");
		} else {
			System.out.println("Even Length List");
		}
	}
	
	static ListNode insertInSortedLinkedList(ListNode head, ListNode newNode) {
		if (head == null) {
			head = newNode;
			return head;
		}
		ListNode parent = head ,temp = head , nextNode;
		while (temp != null && temp.getData() < newNode.getData()) {
			parent = temp;
			temp = temp.getNext();
		}
		nextNode = parent.getNext();
		parent.setNext(newNode);
		newNode.setNext(nextNode);
		return head;
			
	}
	
	static ListNode reverseList(ListNode head) {
		ListNode temp = null, nextNode = null, current = head;
		while (current != null) {
			nextNode = current.getNext();
			current.setNext(temp);
			temp = current;
			current = nextNode;
			
		}
		return temp;
	}
	
	static void findMergingPoint(ListNode head1, ListNode head2) {
		if (head1 ==null || head2 == null) {
			System.out.println("No merging point");
			return;
		}
		int length1 = findLength(head1);
		int length2 = findLength(head2);
		int diff = Math.abs(length1 - length2);
		if (length1 > length2) {
			for (int i = 0 ; i < diff; i ++) {
				head1 = head1.getNext();
			}
		} else {
			for (int i = 0 ; i < diff; i ++) {
				head2 = head2.getNext();
			}
		}
		while (head1 != null && head2 != null) {
			if (head1 == head2) {
				System.out.println("Merging point is :" + head1.getData());
				return;
			} 
			head1 = head1.getNext();
			head2 = head2.getNext();
		}
	}
	
	static void findMiddleNode(ListNode head) {
		if (head == null)
			System.out.println("No Cycle");
		ListNode fastPtr = head, slowPtr = head;
		while (fastPtr != null && fastPtr.getNext() != null) {
			fastPtr = fastPtr.getNext().getNext();
			slowPtr = slowPtr.getNext();
		}
		if (fastPtr == null) {
			System.out.println("Middle Node- odd Length is : " + slowPtr.getData());
			return;
		}
		if (fastPtr.getNext() == null) {
			System.out.println("Middle Node - even length is : " + slowPtr.getNext().getData());
			return;
		}
			
	}
	
	static ListNode reverseListPair(ListNode head) {
		ListNode temp = null, tmp1 = null; 
		while (head != null && head.getNext() != null) {
			if (temp != null)
				temp.getNext().setNext(head.getNext());
			temp = head.getNext();
			head.setNext(temp.getNext());
			temp.setNext(head);
			if (tmp1 == null)
				tmp1 = temp;
			head = head.getNext();
		}
		return tmp1;
	}
	
	static ListNode reverseListByPairByHardik(ListNode head)
	{
		ListNode reverseFrom, reverseTo = null, currentNode, resultNode = null;
		currentNode = head;
		
		if(currentNode == null || currentNode.next == null)
			return currentNode;
		
		while(currentNode != null && currentNode.getNext() != null)
		{
			reverseTo = currentNode;
			reverseFrom = currentNode.getNext();
			
			if(resultNode == null)
				resultNode = reverseFrom;
			
			if(currentNode.getNext().getNext() != null)
			{
				currentNode = currentNode.getNext().getNext();
				reverseTo.next = currentNode.next;
			}	
				
			//reverse pair
			reverseFrom.next = reverseTo;
		}
		
		if(currentNode.next == null)
			reverseTo.next = currentNode;
		else
			reverseTo.next = null;
			
		return resultNode;
	}
	
	static void displayLinkedListReverse(ListNode head) {
		if (head == null)
			return;
		else {
			displayLinkedListReverse(head.getNext());
			System.out.print(head.getData() + "->");
		}
	}
	
	static void isListPalindrome(ListNode head) {
		if (head == null) {
			System.out.println("Not palindrom");
			return;
		}
		if (head.getNext() == null) {
			System.out.println("palindrom");
			return;
		}
		ListNode fastPtr = head, slowPtr = head;
		Stack<ListNode> stack = new Stack<ListNode>();
		while (fastPtr != null && fastPtr.getNext() != null) {
			fastPtr = fastPtr.getNext().getNext();
			slowPtr = slowPtr.getNext();
		}
		if (fastPtr == null) {
			while (slowPtr != null) {
				stack.push(slowPtr);
				slowPtr = slowPtr.getNext();
			}
		} else {
			slowPtr = slowPtr.getNext();
			while (slowPtr != null) {
				stack.push(slowPtr);
				slowPtr = slowPtr.getNext();
			}
		}
		while (!stack.isEmpty()) {
			if (head.getData() != stack.pop().getData()) {
				System.out.println("Not Palindrom");
				return;
			}
			head = head.getNext();
		}
		System.out.println("list is Palindrom");
			
	}
	
	static ListNode removeDuplicates(ListNode head) {
		if (head == null)
			return head;
		HashMap<Integer, Boolean> map = new HashMap<Integer, Boolean>();
		ListNode temp = head, previous = null;
		while (temp != null) {
			if (map.containsKey(temp.getData())) {
				previous.setNext(temp.getNext());
			} else {
				previous = temp;
				map.put(temp.getData(), true);
			}
			temp = temp.getNext();
		}
		return head;
	}
	
	static ListNode partitionList(ListNode head, int x) {
		if (head == null)
			return head;
		ListNode beforeStart = null, afterStart = null, next = null;
		while (head != null) {
			next = head.getNext();
			if (head.getData() < x) {
				head.setNext(beforeStart);
				beforeStart = head;
			} else {
				head.setNext(afterStart);
				afterStart = head;
			}
			head = next;
		}
		if (beforeStart == null)
			return afterStart;
		head = beforeStart;
		while (beforeStart.getNext() != null) {
			beforeStart = beforeStart.getNext();
		}
		beforeStart.setNext(afterStart);
		return head;
	}
	
	static ListNode removeDuplicatesWithoutBuffer(ListNode head) {
		if (head == null)
			return head;
		ListNode temp = null, current = head;
		while (current != null) {
			temp = current;
			while (temp.getNext() != null) {
				if (temp.getNext().getData() == current.getData()) {
					temp.setNext(temp.getNext().getNext());
				} else {
					temp = temp.getNext();
				}
			}
			current = current.getNext();
		}
		return head;
	}
	
	static ListNode addTwoList(ListNode head1, ListNode head2, int carry) {
		if (head1 == null && head2 ==null && carry ==0) {
			return null;
		}
		ListNode result = new ListNode();
		int value = carry;
		if (head2 != null) 
			value += head2.getData();
		if (head1 != null) 
			value += head1.getData();
		result.setData(value%10);
		if (head1 != null || head2 != null) {
			ListNode node = addTwoList(head1 != null ? head1.getNext() : null,
									   head2 != null ? head2.getNext() : null,
									   value > 9 ? 1 :0);
			result.setNext(node);
		}
		return result;
	}
	
	public static ListNode addTwoReversedList(ListNode head1,ListNode head2)
	{
		if(head1 == null)
			return head2;
		
		if(head2 == null)
			return head1;
		
		int l1 = findLength(head1);
		int l2 = findLength(head2);
		
		if(l1<l2)
			head1 = appendNode(head1, l2-l1);
		else if(l2<l1)
			head2 = appendNode(head2, l1-l2);
		
		AddObject addObject = addLinkedListRecursively(head1, head2, 0);
		
		if(addObject.carry == 0)
			return addObject.node;
		else
		{
			ListNode currentNode = new ListNode(1, addObject.node);
			return currentNode;
		}
	}
	
	private static AddObject addLinkedListRecursively(ListNode head1,
			ListNode head2, int carry) {
		
		if(head1== null && head2 == null && carry == 0)
		{
			AddObject nullObj = new AddObject();
			return nullObj;
		}
		
		AddObject previousObj = addLinkedListRecursively(head1.next, head2.next, carry);
		
		int addResult = head1.data + head2.data + previousObj.carry;
		if(addResult > 9)
			carry  = 1;
		else
			carry = 0;
		ListNode currentNode = new ListNode(addResult%10, previousObj.node);
		previousObj.node = currentNode;
		previousObj.carry = carry;
		
		return previousObj;
	}

	private static ListNode appendNode(ListNode head, int n) {
		ListNode newNode = null;
		
		for(int i = 0; i < n; i++)
		{
			newNode = new ListNode(0, head);
			head = newNode;
		}
		
		return head;
	}

	public static void main(String[] args) {
		System.out.println("----------------------Sum of linked list started-----------------------------------");
		ListNode add7 = new ListNode(4, null);
		ListNode add3 = new ListNode(3, add7);
		ListNode add2 = new ListNode(2, add3);
		ListNode add1 = new ListNode(1, add2);
		
		ListNode add6 = new ListNode(7, null);
		ListNode add5 = new ListNode(5, add6);
		ListNode add4 = new ListNode(9, add5);
		
		//ListNode sum = addTwoList(add1, add2, 0);
		ListNode sum = addTwoReversedList(add1, add4);
		while(sum != null) {
			System.out.print(sum.getData() + " ");
			sum = sum.getNext();
		}
		
		System.out.println("----------------------Sum of linked list completed-----------------------------------");
		
		ListNode node6 = new ListNode(5, null);
		ListNode node5 = new ListNode(7, node6);
		ListNode node4 = new ListNode(9, node5);
		ListNode node3 = new ListNode(10, node4);
		ListNode node2 = new ListNode(12, node3);
		ListNode node1 = new ListNode(15, node2);
		ListNode head = new ListNode(2, node1);
		
		ListNode head2node2 = new ListNode(3, null);
		ListNode head2node1 = new ListNode(2, head2node2);
		ListNode head2 = new ListNode(1, head2node1);
		
		System.out.println("----------------Merged list is ------------------");
		mergeLinkedList(head, head2);
		System.out.println();
		System.out.println("----------------Merged list using recursion ------------------");
		ListNode node = mergeSortUsingRecursion(head, head2);
		printList(node);
		System.out.println("Length is :" + findLength(head));
		EvenOddLength(head);
		printList(head);
		ListNode newNode = new ListNode(8, null);
		head = insertElement(head, 6, newNode);
		System.out.println();
		printList(head);
		ListNode temp = null;
		newNode = new ListNode(8, null);
		temp = insertElement(temp, 1, newNode);
		System.out.println();
		printList(temp);
		temp = insertElement(temp, 2, node6);
		System.out.println();
		printList(temp);
		System.out.println();
		findNthNodeFromEnd(head, 2);
		findNthNodeFromEndInOneScan(head, 15);
		System.out.println("-----------------------Using recursion------------------------------");
		findKthNodeFromEndUsingRecursion(head, 2, 0);
		System.out.println("Length is :" + findLength(head));
		EvenOddLength(head);
		findCycle(head);
		printList(head);
		System.out.println("After this head has cycle");
		node6.setNext(node3);
		newNode = new ListNode(2, node1);
		//printList(newNode);
		findCycle(newNode);
		findStartOfCycle(newNode);
		findNodeCountInCycle(newNode);
		ListNode sortedNode = new ListNode(6, null);
		ListNode sortedNode1 = new ListNode(5, null);
		ListNode sortedNode2 = new ListNode(4, sortedNode1);
		ListNode sortedHead = new ListNode(3, sortedNode2);
		sortedHead = insertInSortedLinkedList(sortedHead, sortedNode);
		printList(sortedHead);
		System.out.println();
		sortedHead = reverseList(sortedHead);
		printList(sortedHead);
		System.out.println();
		node6.setNext(null);
		sortedNode1 = new ListNode(5, node3);
		sortedNode2 = new ListNode(4, sortedNode1);
		sortedHead = new ListNode(3, sortedNode2);
		printList(sortedHead);
		System.out.println();
		printList(head);
		System.out.println();
		findMergingPoint(head, sortedHead);
		/*sortedNode2 = new ListNode(4, node3);
		sortedHead = new ListNode(3, sortedNode2);
		printList(sortedHead);*/
		System.out.println();
		findMiddleNode(head);
		displayLinkedListReverse(head);
		System.out.println("Remove duplicates ");
		sortedHead = removeDuplicatesWithoutBuffer(sortedHead);
		printList(sortedHead);
		System.out.println("List reversal in pair");
		printList(head);
		sortedHead = reverseListPair(head);
		System.out.println();
		printList(sortedHead);
		System.out.println();
		System.out.println("-------------Another approach by hardik for list reversal in pair----------------");
		printList(sortedHead);
		sortedHead = reverseListByPairByHardik(sortedHead);
		System.out.println();
		printList(sortedHead);
		System.out.println();
		ListNode d = new ListNode(4, null);
		ListNode a = new ListNode(3, d);
		ListNode b = new ListNode(3, a);
		ListNode c = new ListNode(4, b);
		isListPalindrome(c);
		
		System.out.println("---------------partition list-------------------------------");
		printList(sortedHead);
		System.out.println();
		sortedHead = partitionList(sortedHead, 8);
		printList(sortedHead);
		System.out.println();
		
		modularNode(head, 3);
		modularNodeFromEnd(head, 3);
		
		findMthPlayerByElimination(5,3);
		
		ListNode nnode10 = new ListNode(10, null);
		ListNode nnode9 = new ListNode(9, nnode10);
		ListNode nnode8 = new ListNode(8, nnode9);
		ListNode nnode7 = new ListNode(7, nnode8);
		ListNode nnode6 = new ListNode(6, nnode7);
		ListNode nnode5 = new ListNode(5, nnode6);
		ListNode nnode4 = new ListNode(4, nnode5);
		ListNode nnode3 = new ListNode(3, nnode4);
		ListNode nnode2 = new ListNode(2, nnode3);
		ListNode nnode1 = new ListNode(1, nnode2);
		ListNode headNew = new ListNode(0, nnode1);
		
		System.out.println();
		printList(headNew);
		ListNode tail =reverseByBlockSize(headNew, 1);
		System.out.println();
		printList(tail);
	}
	
	public static void modularNode(ListNode  head, int k)
	{
		printList(head);
		if(head == null)
			System.out.println("Not possible");
		
		if(k<0)
			System.out.println("Not possible");
		
		int i=1;
		ListNode modularNode = null;
		while(head != null)
		{
			if(i%k ==0)
				modularNode = head;
			
			i++;
			head =head.next;
		}
		
		System.out.println("Modular Node is " + modularNode.data);
	}
	
	public static void modularNodeFromEnd(ListNode head, int k)
	{
		if(head == null)
			System.out.println("Not possible");
		
		if(k<0)
			System.out.println("Not possible");
		ListNode fast = head;
		ListNode slow =head;
		for(int i=0; i<k; i++)
		{
			if(fast!=null)
				fast = fast.next;
		}
		
		while(fast.next!=null)
		{
			fast = fast.next;
			slow = slow.next;
		}
		
		System.out.println("Moduluar node from end is " + slow.data);
	}
	
	/* Find mth player by elemination of mth player every time from a circle*/
	public static void findMthPlayerByElimination(int n, int m)
	{
		// Create a circular linked list
		ListNode head = new ListNode();
		head.data = 1;
		
		ListNode currentNode = head;
		ListNode  newNode = null;
		for(int i =2; i <= n; i++)
		{
			newNode = new ListNode();
			newNode.data = i;
			currentNode.next = newNode;
			currentNode = newNode;
		}
		
		currentNode.next = head;
		
		//Eliminate the mth player
		 for(int i = n; i >1; i--)
		 {
			 for(int j = 1; j < m; j++)
			 {
				 currentNode = currentNode.next;
			 }
			 currentNode.next = currentNode.next.next;
		 }
		 
		 System.out.println("The final player to win is " + currentNode.getData()); 
	}

	public static ListNode reverseByBlockSize(ListNode head, int size)
	{
		if(head == null)
			return null;

		if(hasKNodes(head, size))
		{
			ListNode tail = reverse(head, size);
			head.setNext(reverseByBlockSize(head.next, size));
			return tail;
		}
		else
			return head;
	}
	
	static boolean hasKNodes(ListNode currentNode, int k)
	{
		int count = 1;
		while(currentNode.next != null && count < k)
		{
			currentNode = currentNode.next;
			count++;
		}
		
		if(count == k)
			return true;
		else
			return false;	
	}
	
	static ListNode reverse(ListNode head, int size)
	{
		ListNode previousNode = null, nextNode = null, currentNode = head;
		int count = 1;
		
		while(count <= size && currentNode != null)
		{
			nextNode = currentNode.next;
			currentNode.next = previousNode;
			previousNode = currentNode;
			currentNode = nextNode;
			count++;
		}
		head.next = currentNode;
		
		return previousNode;
	}
}

 class AddObject{
	 
	 public int carry = 0;
	 public ListNode node = null;
	
}
/*Stack of Stacks*/
package hardik.code;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class StackOfStacks<E> extends Stack<E>{

	private static final long serialVersionUID = 1L;
	List<Stack<E>> list;
	private int capacity;
	
	public StackOfStacks(int capacity) {
		this.capacity = capacity;
		list = new ArrayList<Stack<E>>(capacity);
	}
	
	private Stack<E> getLastStack() {
		if (list.size() ==0)
			return null;
		return (list.get(list.size() - 1));
	}
	
	public E push(E data) {
		Stack<E> lastStack = getLastStack();
		if (lastStack != null && lastStack.size() != capacity) {
			lastStack.push(data);
		} else {
			Stack<E> stack = new Stack<E>();
			stack.push(data);
			list.add(stack);
		}
		return data;
	}
	
	public E pop() {
		Stack<E> lastStack = getLastStack();
		if (lastStack == null) {
			return null;
		}
		E data = lastStack.pop();
		if (lastStack.size() == 0) 
			list.remove(lastStack);
		return data;
	}
	
	public boolean isEmpty() {
		return (list.size() == 0);
	}
}
/*Stack questions by hardik*/
package hardik.code;

import java.util.Stack;

public class StackExamples {
	
	static void reverseStack(Stack<Integer> s) {
		if (s.isEmpty())
			return;
		int temp = s.pop();
		reverseStack(s);
		insertAtBottom(s, temp);
	}

	private static void insertAtBottom(Stack<Integer> s, int data) {
		if (s.isEmpty()) {
			s.push(data);
			return;
		}
		int temp = s.pop();
		insertAtBottom(s, data);
		s.push(temp);
	}
	
	//working (descending order) For ascending order, reverse the sign
	static Stack<Integer> sortStackTest(Stack<Integer> s) {
		if (s.isEmpty())
			return null;
		Stack<Integer> reverseStack = new Stack<Integer>();
		while (!s.isEmpty()) {
			int temp = s.pop();
			while(!reverseStack.isEmpty() && reverseStack.peek() > temp) {
				s.push(reverseStack.pop());
			}
			reverseStack.push(temp);
		}
		return reverseStack;
	}
	
	static void sortStack(Stack<Integer> s) {
		if (s.isEmpty())
			return;
		int temp = s.pop();
		sortStack(s);
		insert(s, temp);
	}
	
	private static void insert(Stack<Integer> s, int data) {
		if(!s.isEmpty() && s.peek() < data) {
			int temp = s.pop();
			insert(s, data);
			s.push(temp);
		} else {
			s.push(data);
		}
	}
	
	public static int[] getSpanByMe(int[] arr)
	{
		if(arr.length < 0)
			return null;
		
		int[] result = new int[arr.length];
		
		result[0] =1;
		int currMax = arr[0];
		
		for(int i =1; i< arr.length; i++)
		{
			if(arr[i] < currMax)
			{
				result[i] = 1;
			}
			else
				result[i] = result[i-1] +1;
			
			currMax = arr[i];
		}
		for (int i : result) {
			System.out.print(i + " ");
		}
		return result;
	}

	static int[] findSpan(int[] array) {
		int[] spanArray = new int[array.length]; 
		for (int i = 0; i < array.length ; i++) {
			int span = 1;
			int j = i-1;
			while (j>=0 && array[j] <= array[j+1]) {
				span++;
				j--;
			}
			spanArray[i] = span;
		}
		for (int i : spanArray) {
			System.out.print(i + " ");
		}
		return spanArray;
	}
	
	public static void removeAdjacentDuplicateUsingStack(int[] arr)
	{
		if(arr == null)
			System.out.println("Array is null");
		else{

			Stack<Integer> st = new Stack<Integer>();
			st.push(arr[0]);
			boolean isDuplicate;

			for (int i = 1; i < arr.length; i++) {
				isDuplicate = false;

				while (!st.isEmpty() && arr[i] == st.peek()) {
					i++;
					isDuplicate = true;
				}

				if (isDuplicate) {
					st.pop();
					i--;
				} else
					st.push(arr[i]);
			}

			while (!st.isEmpty()) {
				System.out.print(st.pop() + "\t");
			}
		}
		
	}
	
	static void removeAdjacentDuplicates(int[] array) {
		int stackPointer = -1;
		for (int i =0; i < array.length;) {
			if (stackPointer == - 1 || array[stackPointer] != array[i]) {
				stackPointer++;
				array[stackPointer] = array[i];
				i++;
			} else {
				while(i < array.length && array[i] ==array[stackPointer]) {
					i++;
				}
				stackPointer--;
			}
		}
		for (int i = 0 ; i <=stackPointer; i ++) {
			System.out.print(array[i] + " ");
		}
		
	}
	
	public static void rectangleAreaFromHistogram()
	{
		int[] height = {2,1,2,3,2,3};
		Stack<Integer> st = new Stack<Integer>();
		int i=0;
		int max = 0;
		
		while(i<height.length)
		{
			if(st.isEmpty() || height[i] >= height[st.peek()])
			{
				st.push(i);
				i++;
			}
			else
			{
				int h = height[st.pop()];
				int w = st.empty()? i : i - st.peek() -1;
				max = Math.max(max, h*w);
			}
		}
		
		while(!st.empty())
		{
			int h = height[st.pop()];
			int w = st.empty()? i : i - st.peek() -1;
			max = Math.max(max, h*w);
		}
		
		System.out.println("The maximum area possible is " + max);
		
	}
	
	public static void main(String[] args) {
		int[] array = new int[] {1,3,2,2,0,0,3,1,0};
		removeAdjacentDuplicates(array);
		System.out.println();
		array = new int[] {1,3,2,2,0,0,3,1,0};
		removeAdjacentDuplicateUsingStack(array);
		System.out.println();
		System.out.println("-----------------Find span of stock market price------------------");
		int[] newArray = new int[] {6,3,4,5,1,2,3,6,7};
		findSpan(newArray);
		System.out.println();
		getSpanByMe(newArray);
		System.out.println();
		System.out.println("-----------------Reverse a stack------------------");
		Stack<Integer> s = new Stack<Integer>();
		s.push(2);s.push(7);s.push(6);s.push(4);s.push(1);s.push(3);s.push(9);
		reverseStack(s);
		while (!s.isEmpty())
			System.out.print(s.pop() + " ");
		System.out.println("Reverse end");
		s = new Stack<Integer>();
		s.push(2);s.push(7);s.push(6);s.push(4);s.push(1);s.push(3);s.push(9);
		Stack<Integer> stack=new Stack<Integer>();
		stack.push(3);stack.push(4);stack.push(1);stack.push(2);stack.push(2);stack.push(3);stack.push(4);stack.push(1);
		//sortStack(stack);
		stack = sortStackTest(stack);
		System.out.println("Stack sorting");
		while (!stack.isEmpty())
			System.out.print(stack.pop() + " ");
		System.out.println();
		sortStack(s);
		while (!s.isEmpty())
			System.out.print(s.pop() + " ");
		System.out.println();
		rectangleAreaFromHistogram();
	}

}

// Get minimun from stack in O(1)
class AdvancedStack {
	Stack<Integer> elementStack;
	Stack<Integer> minStack;
	
	public AdvancedStack() {
		elementStack = new Stack<Integer>();
		minStack = new Stack<Integer>();
	}
	
	public void push(int data) {
		elementStack.push(data);
		if (minStack.isEmpty() || minStack.peek() >= data) {
			minStack.push(data);
		}
	}
	
	public int pop() {
		if (elementStack.isEmpty()) {
			return -1;
		}
		int minTop = minStack.peek();
		int elementTop = elementStack.peek();
		if (minTop == elementTop)
			minStack.pop();
		return elementStack.pop();
	}
	
	public int min() {
		return minStack.peek();
	}
	
	public boolean isEmpty() {
		return elementStack.isEmpty();
	}
	
	public int peek() {
		if (elementStack.isEmpty())
			return -1;
		return elementStack.peek();
	}
}

/*Dynamic programming Hardik*/
package hardik.code;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Set;

public class DynamicProgramingAndStringAlgorithms {

	static String findLongestCommonSubString(String[] stringArray) {
		String smallestString = "";
		for (String string : stringArray) {
			if (string != null && smallestString.isEmpty())
				smallestString = string;
			else if (string != null && smallestString.length() > string.length())
				smallestString = string;
		}
		String longestCommonSubString = "";
		StringBuffer sb = new StringBuffer();
		for (int i = 0 ; i < smallestString.length() ; i++) {
			char c = smallestString.charAt(i);
			sb.append(c);
			for (String string : stringArray) {
				if (string != null && !string.contains(sb.toString())) {
					sb = sb.deleteCharAt(0);
					break;
				}
			}
			if (sb.length() != 0 && sb.length() > longestCommonSubString.length()) {
				longestCommonSubString = sb.toString();
			}
		}
		System.out.println("longest common substring is :" + longestCommonSubString);
		return longestCommonSubString;
	}
	
	
	static String findLongestCommonSubSequence(String string1, String string2) {
		int[][] lengthArray = new int[string1.length()+1][string2.length()+1];
		
		for (int i = 0 ; i < string1.length() ; i++) {
			for (int j =0 ; j < string2.length() ; j++) {
				if (string1.charAt(i) == string2.charAt(j)) {
					lengthArray[i+1][j+1] = 1 + lengthArray[i][j];
				} else {
					lengthArray[i+1][j+1] = Math.max(lengthArray[i][j+1], lengthArray[i+1][j]);
				}
			}
		}
		StringBuffer longestCommonSubSequence = new StringBuffer();
		for (int x=string1.length(), y =  string2.length(); x !=0 && y!=0;)
		{
			if (lengthArray[x][y] == lengthArray[x][y-1]) {
				y--;
			} else if (lengthArray[x][y] == lengthArray[x-1][y]) {
				x--;
			} else if (string1.charAt(x-1) == string2.charAt(y -1)) {
				longestCommonSubSequence.append(string1.charAt(x-1));
				x--;
				y--;
			}
		}
		System.out.println(longestCommonSubSequence.reverse().toString());
		return longestCommonSubSequence.reverse().toString();
	}
	
	
	//O(2^n)
	static ArrayList<ArrayList<Integer>> findSubSets(ArrayList<Integer> list, int index) {
		ArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>(); 
		if (list.size() == index) {
			result.add(new ArrayList<Integer>());
		} else {
			int set = list.get(index);
			result = findSubSets(list, index + 1);
			ArrayList<ArrayList<Integer>> subResult1 = new ArrayList<ArrayList<Integer>>();
			for (ArrayList<Integer> temp : result) {
				ArrayList<Integer> subResult2 = new ArrayList<Integer>();
				subResult2.addAll(temp);
				subResult2.add(set);
				subResult1.add(subResult2);
				
			}
			result.addAll(subResult1);
		}
		return result;
	}
	
	static ArrayList<String> findAllPermutation(String string) {
		if (string == null)
			return null;
		ArrayList<String> array = new ArrayList<String>();
		if (string.length() == 0) {
			array.add("");
			return array;
		} 
		char c = string.charAt(0);
		ArrayList<String> words = findAllPermutation(string.substring(1));
		for (String word : words) {
			for (int j = 0; j <= word.length(); j++) {
				String start = word.substring(0, j);
				start += (c + word.substring(j));
				array.add(start);
			}
		}
		return array;
	}
	
	
	static void printAllParenthesisPattern(ArrayList<String> list, char[] s, int leftRem, int righRem, int count) {
		if (leftRem < 0 || righRem < leftRem) {
			return;
		}
		if (leftRem ==0 && righRem ==0) {
			String string = String.copyValueOf(s);
			list.add(string);
		} else {
			if (leftRem > 0) {
				s[count] = '(';
				printAllParenthesisPattern(list, s, leftRem -1, righRem, count+1);
			}
			
			if (righRem > leftRem) {
				s[count] = ')';
				printAllParenthesisPattern(list, s, leftRem, righRem - 1, count+1);
			}
		}
	}
	
	public static int countWaysDP(int n, int[] map) {
		if (n < 0) {
			return 0;
		} else if (n == 0) {
			return 1;
		} else if (map[n] > -1) {
			return map[n];
		} else {
			map[n] = countWaysDP(n - 1, map) + countWaysDP(n - 2, map)
					+ countWaysDP(n - 3, map);
			return map[n];
		}
	}
	
	//O(n) if all characters are same to O(n!) if all characters are distinct
		public static void permutate(String head, String tail) {
	        if (tail.isEmpty()) {
	            System.out.println(head);
	        } else {
	            Set<Character> seen = new HashSet<Character>();
	            for (int i = 0; i < tail.length(); i++) {
	                if (!seen.contains(tail.charAt(i))) {
	                    seen.add(tail.charAt(i));
	                    permutate(head + tail.charAt(i), tail.substring(0, i) + tail.substring(i + 1, tail.length()));
	                }
	            }
	        }
	    }
		
		static int lis( int arr[], int n )
		{
		   int  i, j, max = 0;
		   int[] lis = new int[n];
		 
		   /* Initialize LIS values for all indexes */
		   for ( i = 0; i < n; i++ )
		      lis[i] = 1;
		    
		   /* Compute optimized LIS values in bottom up manner */
		   for ( i = 1; i < n; i++ )
		      for ( j = 0; j < i; j++ )
		         if ( arr[i] > arr[j] && lis[i] < lis[j] + 1)
		            lis[i] = lis[j] + 1;
		    
		   /* Pick maximum of all LIS values */
		   for ( i = 0; i < n; i++ )
		      if ( max < lis[i] )
		         max = lis[i];
		 
		   /* Free memory to avoid memory leak */
		   lis = null;
		 
		   return max;
		}
	public static void main(String[] args) {
		String[] string = new String[] {"abcdab", "abcdababc", "abcdab", "ablcdabkacd"};
		findLongestCommonSubString(string);
		findLongestCommonSubSequence("ABCBDABC", "BDCABAC");
		findLongestCommonSubSequence("abcdababc", "ablcdabkacd");
		
		ArrayList<Integer> list = new ArrayList<Integer>();
		list.add(3);list.add(4);list.add(5);
		System.out.println(findSubSets(list, 0).toString());
		System.out.println(findAllPermutation("ab").toString());
		int count = 2;
		ArrayList<String> list1 = new ArrayList<String>();
		char[] chArray = new char[count*2];
		printAllParenthesisPattern(list1, chArray, count, count, 0);
		for (String s : list1) {
			System.out.print(s + " ");
		}System.out.println();
		
		int n = 3;
		int[] map = new int[] {-1,-1,-1,-1};
		System.out.println(countWaysDP(n, map));
		int arr[] = { 10, 22, 9, 33, 21, 50, 41, 60, 80 };
		System.out.println(lis(arr,arr.length-1));
			
	}
}
/*K closest points*/
package hardik.code;

public class kClosestPoints {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		CPoints newpoint;
		CPoints[] points = new CPoints[10];
		
		for(int i = 0; i < 10; i++)
		{
			newpoint = new CPoints();
			newpoint.x = 9-i+0.5;
			newpoint.y = 9-i+0.5;
			points[i] = newpoint;
		}
		
		getKClosestPoints(points, 5);

	}
	
	public static CPoints[] getKClosestPoints(CPoints[] points, int k)
	{
		if(k >= points.length)
			return points;
		
		if(k < 1)
			return null;
		
		
		findKPoints(points, k,  0, points.length - 1);
		
		CPoints[] result = new CPoints[k]; 
		int i = 0;
		for(CPoints point :points)
		{
			System.out.println(point.x + "  " + point.y);
			result[i] = point;
			i++;
			if(i == k)
				break;
		}
		
		return result;
	}

	private static void findKPoints(CPoints[] points, int k, int start, int end) {
		if(start < end)
		{
			int pivot = doPartition(points, start, end) - 1;
			if(pivot == k)
				return;
			else
			{
				if(pivot > k)
					findKPoints(points, k,  start, pivot-1);
				else
					findKPoints(points, k,  pivot+1, end);
			}
		}
}

private static int doPartition(CPoints[] points, int start, int end) {
		int left = start;
		int right = end;
		int mid = (left + right) /2;
		
		while(left <= right)
		{
			/*while(isCurrentPointMinor(points[left], points[mid]))
				left++;
			
			while(isCurrentPointMinor(points[mid],points[right] ))
				right--;
			*/
			while(points[left].compareTo(points[mid]) < 0)
				left++;
			
			while(points[mid].compareTo(points[right]) < 0)
				right--;
			
			if(left<=right)
			{
				swapPoints(points,left, right);
				left++;
				right--;
			}
		}
		return left;
	}

private static void swapPoints(CPoints[] points, int left, int right) {
	
	CPoints temp = points[left];
	points[left] = points[right];
	points[right] = temp;
	
}

private static boolean isCurrentPointMinor(CPoints currentPoint, CPoints nextPoint)
{
	double distanceOfCurrentPoint = getDistanceFromOrigin(currentPoint);
	double distanceOfNextPoint = getDistanceFromOrigin(nextPoint);
	
	if(distanceOfCurrentPoint < distanceOfNextPoint)
		return true;
	else
		return false;
}

private static double getDistanceFromOrigin(CPoints currentPoint) {
	return Math.hypot(currentPoint.x-0.0, currentPoint.y-0.0);
}
}

class CPoints implements Comparable<CPoints>{
	
	public double x;
	public double y;
	
	@Override
	public int compareTo(CPoints point) {
		double distanceOfNextPoint = Math.hypot(point.x-0.0, point.y-0.0);
		double distanceOfThisPoint = Math.hypot(this.x-0.0, this.y-0.0);
		
		return Double.valueOf(distanceOfThisPoint).compareTo(distanceOfNextPoint);
	}
	
}

/*Heap*/
package hardik.code;

public class Heap {

	int capacity;
	int count;
	int[] array;
	
	public Heap() {};
	public Heap(int capacity) {
		this.capacity = capacity;
		this.count = 0;
		this.array = new int[capacity];
	}
	
	public int getParent(int index) {
		if (index <=0 || index >= this.count)
			return -1;
		else
			return (index-1)/2;
	}
	
	public int getLeftChild(int i) {
		int left = 2*i+1;
		if (left >= this.count)
			return -1;
		else 
			return left;
	}
	
	public int getRightChild(int i) {
		int right = 2*i+2;
		if (right >= this.count)
			return -1;
		else 
			return right;
	}
	
	public int getMax() {
		if (this.count == 0)
			return -1;
		else 
			return this.array[0];
	}
	
	public void heapify(int i) {
		int left,right,temp ,max = i;
		if(i<=0 || i>= this.count)
			return;
		left = getLeftChild(i);
		right = getRightChild(i);
		if (left != -1 && this.array[left] > this.array[max]) {
			max = left;
		}
		if (right != -1 && this.array[right] > this.array[max]) {
			max = right;
		}
		if (max != i) {
			temp = this.array [i];
			this.array[i] = this.array[max];
			this.array[max] = temp;
			heapify(max);
		}
		
	}
	
	public void insert(Heap h, int data) {
		if(this.count == this.capacity) {
			resizeArray();
		}
		this.count++;
		int i = this.count -1;
		while (i>=0 && data > array[(i-1)/2]) {
			array[i] = array[(i-1)/2];
			i = (i-1)/2;
		}
		array[i] = data;
	}

	public void resizeArray() {
		int[] old_array = new int[this.capacity];
		System.arraycopy(this.array, 0, old_array, 0, this.count);
		this.array = new int[this.capacity*2];
		for (int i=0; i< this.capacity; i++) {
			this.array[i] = old_array[i];
		}
		this.capacity = this.capacity *2;
		old_array = null;
		
	}
	
	public int deleteMax() {
		if (this.count == 0)
			return -1;
		int data = this.array[0];
		this.array[0] = this.array[this.count - 1];
		heapify(0);
		return data;
	}
	
	public void buildHeap(Heap h , int[] A, int n) {
		if(h==null) return;
		if(n > h.capacity) {
			resizeArray();
		}
		for (int i=0; i <n ; i++) {
			h.array[i] = A[i];
		}
		this.count = n;
		h.count = n;
		for (int i =(n-1)/2; i >=0; i--) {
			h.heapify(i);
		}
		
	}
	
	public void heapSort(int[] A, int n) {
		Heap h = new Heap(n);
		int temp;
		buildHeap(h, A, n);
		for (int i= n-1; i>=0; i--) {
			temp = h.array[0];
			h.array[0] = h.array[this.count-1];
			h.array[this.count-1] = temp;
			h.count--;
			h.heapify(0);
		}
		h.count = n;
		for (int i=0; i < h.array.length; i++) {
			System.out.println(h.array[i]);
			A[i] = h.array[i];
		}
	}
	
	
}

/*Heap examples by hardik which includes building maximum heap / max heap and minimum heap/min heap / find kth largest element in array / find kth smallest element in array*/
package hardik.code;


public class HeapExamples {

	public static int heapSize;
	public static int getLeft(int i) {
		return 2*i + 1;
	}
	
	public static int getRight(int i) {
		return 2*i + 2;
	}
	
	public static int getMin(int[] A) {
		return A[0];
	}
	
	public static int getMax(int[] A) {
		return A[0];
	}
	
	public static void replaceMax(int[] A, int i) {
		A[0] = i;
		maxHeapify(A, 0);
	}
	
	public static void replaceMin(int[] A, int i) {
		A[0] = i;
		minHeapify(A, 0);
	}
	public static void buildMinHeap(int[] A) {
		heapSize = A.length;
		for (int i=(A.length-1)/2; i>=0; i--) {
			minHeapify(A, i);
		}
	}
	private static void minHeapify(int[] A, int i) {
		int left = getLeft(i);
		int right = getRight(i);
		int temp, min = Integer.MIN_VALUE;
		if (left < heapSize && A[left] < A[i]) 
			min = left;
		else
			min = i;
		if (right < heapSize && A[right] < A[min])
			min = right;
		if (min != i) {
			temp = A[i];
			A[i] = A[min];
			A[min] = temp;
			minHeapify(A, min);			
		}
	}

	public static void buildMaxHeap(int[] A) {
		heapSize = A.length;
		for (int i = (A.length-1)/2; i>=0; i--) {
			maxHeapify(A, i);
		}
	}
	public static void maxHeapify(int[] A, int i) {
		int left, right, max = -1, temp;
		left = getLeft(i);
		right = getRight(i);
		if (left < heapSize && A[left] > A[i])
			max = left;
		else 
			max = i;
		if (right < heapSize && A[right] > A[max])
			max = right;
		if (max != i) {
			temp = A[i];
			A[i] = A[max];
			A[max] = temp;
			maxHeapify(A, max);
		}
 	}
	
	
	public static void heapSort(int[] A, int n) {
		int temp;
		buildMaxHeap(A);
		for (int i=A.length-1; i>=0; i--) {
			temp = A[0];
			A[0] = A[i];
			A[i] = temp;
			heapSize--;
			maxHeapify(A, 0);
			
		}
	}
	
	public static void findKthLargestElement(int[] A, int k) {
		int[] B = new int[k];
		System.arraycopy(A, 0, B, 0, k);
		buildMinHeap(B);
		for (int i =k; i < A.length ; i++) {
			if (A[i] > getMin(B))
				replaceMin(B, A[i]);
		}
		System.out.println("Kth max is " + getMin(B));
	}
	
	public static void findKthSmallestElement(int[] A, int k) {
		int[] B = new int[k];
		System.arraycopy(A, 0, B, 0, k);
		buildMaxHeap(B);
		for (int i =k; i < A.length ; i++) {
			if (A[i] < getMax(B))
				replaceMax(B, A[i]);
		}
		System.out.println("Kth min is " + getMax(B));
	}
	
	
	public static void main(String[] args) {
		int A[] = new int[]{4,1,3,2,16,9,10,14,8,7};
		/*heapSort(A, A.length);
		System.out.println(Arrays.toString(A));*/
		findKthLargestElement(A, 3);
		findKthSmallestElement(A, 3);
		
	}
}

/*Java patterns*/
/*
1
111
11111
*/
for (int i = 1 ; i <=5; i++) {
			for (int j=1; j <= i; j++) {
				if(i%2 != 0)
					System.out.print(1);
			}
			if(i%2 != 0)
			System.out.println();
		}
/*
1
12
123
1234
12345
*/
for (int i = 1 ; i <=5; i++) {
			for (int j = 1; j <=i; j++) {
				System.out.print(j);
			}
			System.out.println();
		}
/*
A
AB
ABC
ABCD
ABCDE
*/
for (int i = 'A' ; i <='E'; i++) {
			for (int j = 'A'; j <=i; j++) {
				System.out.print("" + (char)j);
			}
			System.out.println();
		}
/*
                 *
               ***
             *****
           *******
         *********
       ***********
      *************
    ***************
  *****************
*******************
*/
for(int i=1;i<=10;i++){
             for(int j=1;j<10-(i-1);j++){
                 System.out.print(" ");
             }
             for(int k=1;k<=i;k++){
                 System.out.print("*");
                 for(int k1=1;k1<k;k1+=k){

                     System.out.print("*");
                 }
             }
             System.out.println();
         }



/*Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.

For example,
Assume that words = ["practice", "makes", "perfect", "coding", "makes"].

Given word1 = "coding", word2 = "practice", return 3.
Given word1 = "makes", word2 = "coding", return 1.

Note:
You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.
*/

class Solution {
 2 public:
 3     int shortestDistance(vector<string>& words, string word1, string word2) {
 4         int n = words.size(), idx1 = -1, idx2 = -1, dist = INT_MAX;
 5         for (int i = 0; i < n; i++) {
 6             if (words[i] == word1) idx1 = i;
 7             else if (words[i] == word2) idx2 = i;
 8             if (idx1 != -1 && idx2 != -1)
 9                 dist = min(dist, abs(idx1 - idx2));
10         }
11         return dist;
12     }
13 };

/*Palindrome Permutation using HashMap*//Permutation Palindrome*/
HashMap<Character,Integer> map = new HashMap<Character, Integer>();
    for (int i = 0; i < s.length(); i++){
        if (map.containsKey(s.charAt(i))){
            map.remove(s.charAt(i));
        }else{
            map.put(s.charAt(i), 1);
        }
    }
    if (map.size() > 1) return false;
    else return true;
    
/*Find the power set of a set*/
public static <T> List<List<T>> powerset(Collection<T> list) {
  List<List<T>> ps = new ArrayList<List<T>>();
  ps.add(new ArrayList<T>());   // add the empty set
 
  // for every item in the original list
  for (T item : list) {
    List<List<T>> newPs = new ArrayList<List<T>>();
 
    for (List<T> subset : ps) {
      // copy all of the current powerset's subsets
      newPs.add(subset);
 
      // plus the subsets appended with the current item
      List<T> newSubset = new ArrayList<T>(subset);
      newSubset.add(item);
      newPs.add(newSubset);
    }
 
    // powerset is now powerset of list.subList(0, list.indexOf(item)+1)
    ps = newPs;
  }
  return ps;
}
 
/*Given a string and number to letter mapping, find the number of possible combinations*/
void getMappingDp(String str)
	{
		int arr[]=new int[str.length()];
		long Dp[]=new long[str.length()];
		
		for(int i=0;i<arr.length;i++)
		{
			arr[i]=Integer.parseInt(""+str.charAt(i));
		}
	
		Dp[0]=1;
		if(arr[0]*10+arr[1]<;27)
			Dp[1]=2;
		else
			Dp[1]=1;
		
		for(int i=2;i<arr.length;i++)
		{
			long combinedLast2didgits=0;
			if(arr[i-1]*10+arr[i]<;27)
				combinedLast2didgits=Dp[i-2];
			Dp[i]=Dp[i-1]+combinedLast2didgits;	
		}
		System.out.println("Total mapping are:"+Dp[Dp.length-1]);
	}
	
/*Check if sum of two numbers is equal to sum of other two numbers*/
public static void printVal(int[] arr) { 
if (arr.length == 0 || arr.length < 4) return; 
HashMap<Integer, ArrayList<Pair>> map = new HashMap<Integer, ArrayList<Pair>>(); 
for (int i = 0; i < arr.length - 1; i++) { 
for (int j = i + 1; j < arr.length; j++) { 
Pair p = new Pair(i,j); 
if (map.containsKey(arr[i] + arr[j])) { 
map.get(arr[i] + arr[j]).add(p); 
} else { 
ArrayList<Pair> arrList = new ArrayList<Pair>(); 
arrList.add(p); 
map.put(arr[i] + arr[j], arrList); 
} 
} 
} 

for (Integer i : map.keySet()) { 
ArrayList<Pair> list = map.get(i); 
if (list.size() == 2) { 
System.out.println(list.get(0).one + " " + list.get(0).two + " " + 
list.get(1).one + " " + list.get(1).two); 
} 
if (list.size() > 2) { 
for (int k = 0; k < list.size() - 1; k++) { 
for (int m = k + 1; m < list.size(); m++) { 
System.out.println(list.get(k).one + " " + list.get(k).two 
+ " " + list.get(m).one + " " + list.get(m).two); 
} 
} 
} 
} 
} 

public class Pair { 
int one; 
int two; 
public Pair(int o, int t) { 
one = o; 
two = t; 
} 
}
/*Create a copy of the structure of the linked list with random pointer*/
private Node deepCopy(Node original) { 
		// We use the following map to associate newly created instances 
		// of Node with the instances of Node in the original list 
		Map<Node, Node> map = new HashMap<Node, Node>(); 
		// We scan the original list and for each Node x we create a new 
		// Node y whose data is a copy of x's data, then we store the 
		// couple (x,y) in map using x as a key. Note that during this 
		// scan we set y.next and y.random to null: we'll fix them in 
		// the next scan 
		Node x = original; 
		while (x != null) { 
			Node y = new Node(); 
			y.setData(new String(x.getData())); 
			y.setNext(null); 
			y.setRandom(null); 
			map.put(x, y); 
			x = x.getNext(); 
		} 
		// Now for each Node x in the original list we have a copy y 
		// stored in our map. We scan again the original list and 
		// we set the pointers buildings the new list 
		x = original; 
		while (x != null) { 
			// we get the node y corresponding to x from the map 
			Node y = map.get(x); 
			// let x' = x.next; y' = map.get(x') is the new node 
			// corresponding to x'; so we can set y.next = y' 
			y.setNext(map.get(x.getNext())); 
			// let x'' = x.random; y'' = map.get(x'') is the new 
			// node corresponding to x''; so we can set y.random = y'' 
			y.setRandom(map.get(x.getRandom())); 
			x = x.getNext(); 
		} 
		// finally we return the head of the new list, that is the Node y 
		// in the map corresponding to the Node original 
		return map.get(original); 	
	}
	
/*Check if a string is concatenaion of  strings in a given dictionary*/
public void findConcatenations(String key){
		
		System.out.println("For Key: " + key);
		boolean[] checkArray = new boolean[key.length()+1];
		
		int startPoint = 0;
		int iterator = 1;
		boolean wordMatched = false;
		
		while(iterator<=key.length())
		{
			String subWord = key.substring(startPoint, iterator);
			if(dictionary.contains(subWord))
				{
					checkArray[iterator] = true;
					wordMatched = true;
				}else if(wordMatched)
				{
					startPoint = --iterator;
					wordMatched = false;
				}
			iterator++;
		}

		
		if(checkArray[key.length()]==true)
			System.out.println("Answer: Perfect!");
		else
			System.out.println("Answer:  :(");
	}
/*Check if two strings are one edit distance apart*/
public static boolean onlyOneEdit(String first, String second)
{
  if(first.equals(second))
  {
    return false;
  }
    
  int l1 = first.length();
  int l2 = second.length();
    
  if(l1 - l2 > 1 || l2 - l1 > 1)
  {
    // At least two edits .. no need to continue
    return false;
  }
    
  String longer = (l1 > l2)? first : second;
  String shorter = (l1 > l2)? second : first;
    
  for(int i = 0; i < shorter.length(); i++)
  {
    if(longer.charAt(i) != shorter.charAt(i))
    {
        int shift = (l1 == l2)? 0 : 1;
        return longer.substring(i + 1 + shift).equals(shorter.substring(i + 1));
    }
  }
  // No difference detected until the end of the shorter string  
  return true;
}

/*Print all nodes that are k distnace away from a a given node in a binary tree*/
/* Recursive function to print all the nodes at distance k in the
   tree (or subtree) rooted with given root. See  */
void printkdistanceNodeDown(node *root, int k)
{
    // Base Case
    if (root == NULL || k < 0)  return;
 
    // If we reach a k distant node, print it
    if (k==0)
    {
        cout << root->data << endl;
        return;
    }
 
    // Recur for left and right subtrees
    printkdistanceNodeDown(root->left, k-1);
    printkdistanceNodeDown(root->right, k-1);
}
 
// Prints all nodes at distance k from a given target node.
// The k distant nodes may be upward or downward.  This function
// Returns distance of root from target node, it returns -1 if target
// node is not present in tree rooted with root.
int printkdistanceNode(node* root, node* target , int k)
{
    // Base Case 1: If tree is empty, return -1
    if (root == NULL) return -1;
 
    // If target is same as root.  Use the downward function
    // to print all nodes at distance k in subtree rooted with
    // target or root
    if (root == target)
    {
        printkdistanceNodeDown(root, k);
        return 0;
    }
 
    // Recur for left subtree
    int dl = printkdistanceNode(root->left, target, k);
 
    // Check if target node was found in left subtree
    if (dl != -1)
    {
         // If root is at distance k from target, print root
         // Note that dl is Distance of root's left child from target
         if (dl + 1 == k)
            cout << root->data << endl;
 
         // Else go to right subtree and print all k-dl-2 distant nodes
         // Note that the right child is 2 edges away from left child
         else
            printkdistanceNodeDown(root->right, k-dl-2);
 
         // Add 1 to the distance and return value for parent calls
         return 1 + dl;
    }
 
    // MIRROR OF ABOVE CODE FOR RIGHT SUBTREE
    // Note that we reach here only when node was not found in left subtree
    int dr = printkdistanceNode(root->right, target, k);
    if (dr != -1)
    {
         if (dr + 1 == k)
            cout << root->data << endl;
         else
            printkdistanceNodeDown(root->left, k-dr-2);
         return 1 + dr;
    }
 
    // If target was neither present in left nor in right subtree
    return -1;
}


/*Binary Tree to circular doubly linked list inorder*/
// This is a modified in-order traversal adapted to this problem.
// prev (init to NULL) is used to keep track of previously traversed node.
// head pointer is updated with the list's head as recursion ends.
void treeToDoublyList(Node p, Node prev, Node head) {
  if (p==null) return;
  treeToDoublyList(p.left, prev, head);
  // current node's left points to previous node
  p.left = prev;
  if (prev!=null)
    prev.right = p;  // previous node's right points to current node
  else
    head = p; // current node (smallest element) is head of
              // the list if previous node is not available
  // as soon as the recursion ends, the head's left pointer 
  // points to the last node, and the last node's right pointer
  // points to the head pointer.
  Node right = p.right;
  head.left = p;
  p.right = head;
  // updates previous node
  prev = p;
  treeToDoublyList(right, prev, head);
}

// Given an ordered binary tree, returns a sorted circular
// doubly-linked list. The conversion is done in-place.
Node treeToDoublyList(Node root) {
  Node prev = NULL;
  Node head = NULL;
  treeToDoublyList(root, prev, head);
  return head;
}

/*Minimum sliding window/ minimum substring containing all the letters in target*/
public String minWindow(String s, String t) {
    if(s == null || s.length() < t.length() || s.length() == 0){
        return "";
    }
    HashMap<Character,Integer> map = new HashMap<Character,Integer>();
    for(char c : t.toCharArray()){
        if(map.containsKey(c)){
            map.put(c,map.get(c)+1);
        }else{
            map.put(c,1);
        }
    }
    int left = 0;
    int minLeft = 0;
    int minLen = s.length()+1;
    int count = 0;
    for(int right = 0; right < s.length(); right++){
        if(map.containsKey(s.charAt(right))){
            map.put(s.charAt(right),map.get(s.charAt(right))-1);
            if(map.get(s.charAt(right)) >= 0){
                count ++;
            }
            while(count == t.length()){
                if(right-left+1 < minLen){
                    minLeft = left;
                    minLen = right-left+1;
                }
                if(map.containsKey(s.charAt(left))){
                    map.put(s.charAt(left),map.get(s.charAt(left))+1);
                    if(map.get(s.charAt(left)) > 0){
                        count --;
                    }
                }
                left ++ ;
            }
        }
    }
    if(minLen>s.length())  
    {  
        return "";  
    }  

    return s.substring(minLeft,minLeft+minLen);
}


/*Multiplying without using multiplication operator*/
public static int bitwiseMultiply(int n1, int n2) {
    int a = n1;
    int b = n2;
    int result = 0;
    while (b != 0)
    { 
        if ((b & 1) != 0)
        {
        result = result + a;
        }
        a <<= 1;
        b >>>= 1;
    }
return result;
}
/*Divide two integers without using division operator O(logn)-If it is overflow, return MAX_INT.*/
public int divide(int dividend, int divisor) {
    //handle special cases
    if(divisor==0) return Integer.MAX_VALUE;
    if(divisor==-1 && dividend == Integer.MIN_VALUE)
        return Integer.MAX_VALUE;
 
    //get positive values
    long pDividend = Math.abs((long)dividend);
    long pDivisor = Math.abs((long)divisor);
 
    int result = 0;
    while(pDividend>=pDivisor){
        //calculate number of left shifts
        int numShift = 0;    
        while(pDividend>=(pDivisor<<numShift)){
            numShift++;
        }
 
        //dividend minus the largest shifted divisor
        result += 1<<(numShift-1);
        pDividend -= (pDivisor<<(numShift-1));
    }
 
    if((dividend>0 && divisor>0) || (dividend<0 && divisor<0)){
        return result;
    }else{
        return -result;
    }
}

/*detect conflicts in meeting rooms*/
pubic boolean isConflict(List<Interval> slots){
    Collection.sort(slots,new Comparator<Interval>(){
                                       int compareto(Interval one , Interval two){
                                           return one.getStartTime().compareTo(two.getStartTime());
                                       } 
                                    }
                                   );
     Interval prev = null;                              
   for(Inteval el:slots){
       if(prev==null){
           prev == el;
           continue;
       }
       if(el.getStartTime()< prev.getEndTime()){
           return true;
       }
       prev = el;
   }                     
   return false;   
}
/*in-place palindrome check*/
public boolean is_palindrome(String word){
    for(int i=0; i< word.length()/2;i++){
        if(word.charAt(i) != word.charAt(word.length() - 1 - i)
            	return False
            }
    return True
    }
   
/* Local maxima or local minima O(1) time*/
A[0] +/- (A[ A.length -1 ] + A.length - A[0])/2

/*Local minima in O(logn) time */
The question just asks for one local minimum. 
mid=(start+end)/2; 
1. if(A[mid-1]>=A[mid] && A[mid+1]>=A[mid]) then A[mid] is a local minimum. 
2. else if(A[mid-1]<=A[mid] && A[mid]<=A[mid+1]) end=mid, do recursive search. 
3. else if(A[mid-1]>=A[mid] && A[mid]>=A[mid+1]) start=mid, do recursive search 
it is O(logn)


/*Search in rotated sorted array*/
public class Solution {
public int search(int[] A, int target) {
    int lo = 0;
    int hi = A.length - 1;
    while (lo < hi) {
        int mid = (lo + hi) / 2;
        if (A[mid] == target) return mid;

        if (A[lo] <= A[mid]) {
            if (target >= A[lo] && target < A[mid]) {
                hi = mid - 1;
            } else {
                lo = mid + 1;
            }
        } else {
            if (target > A[mid] && target <= A[hi]) {
                lo = mid + 1;
            } else {
                hi = mid - 1;
            }
        }
    }
    return A[lo] == target ? lo : -1;
}
}
/*Search in rotated sorted array with duplicates*/
public boolean search(int[] nums, int target) {
        int start = 0, end = nums.length - 1, mid = -1;
        while(start <= end) {
            mid = (start + end) / 2;
            if (nums[mid] == target) {
                return true;
            }
            //If we know for sure right side is sorted or left side is unsorted
            if (nums[mid] < nums[end] || nums[mid] < nums[start]) {
                if (target > nums[mid] && target <= nums[end]) {
                    start = mid + 1;
                } else {
                    end = mid - 1;
                }
            //If we know for sure left side is sorted or right side is unsorted
            } else if (nums[mid] > nums[start] || nums[mid] > nums[end]) {
                if (target < nums[mid] && target >= nums[start]) {
                    end = mid - 1;
                } else {
                    start = mid + 1;
                }
            //If we get here, that means nums[start] == nums[mid] == nums[end], then shifting out
            //any of the two sides won't change the result but can help remove duplicate from
            //consideration, here we just use end-- but left++ works too
            } else {
                end--;
            }
        }

        return false;
    }
/*Inorder successor in BST*/
public TreeNode successor(TreeNode root, TreeNode p) {
  if (root == null)
    return null;

  if (root.val <= p.val) {
    return successor(root.right, p);
  } else {
    TreeNode left = successor(root.left, p);
    return (left != null) ? left : root;
  }
}

/*Inorder predecessor in BST*/
public TreeNode predecessor(TreeNode root, TreeNode p) {
  if (root == null)
    return null;

  if (root.val >= p.val) {
    return predecessor(root.left, p);
  } else {
    TreeNode right = predecessor(root.right, p);
    return (right != null) ? right : root;
  }
}

/*//On a given array with N numbers, find subset of size M (exactly M elements) that equal to SUM.*/
public static void main(String[] args) throws Exception {
    int[] a = {5,3,2,1,0,4,9,7,8};
    subSeqSumSizeM(a,3,5);
  }
  private static void subSeqSumSizeM(int[] a, int m, int sum) {
   
    if(a == null || (a.length==0) || m<=0 || m>a.length)
      return;
    
    int answer = 0;
    
    for(int i=0; i<m; i++) {
      answer = answer + a[i];
    }
    
    for(int j=1; j<a.length-m; j++) {
      if(answer == sum)
        System.out.println((j-1)+ "-" + (j+m-2));
      
      answer = answer -a[j-1] + a[j+m-1];
    }    
  }
  
  
/* Upside down Binary Tree iterative*/
public class Solution{
	public TreeNode upside(TreeNode root){
		if(root==null) return root;
		TreeNode p = root, parent = null, pRight=null;
		while(p!=null){
		TreeNode left = p.left;
		p.left=pRight;
		pRight = p.right;
		p.right = parent;
		parent = p;
		p=left;
		}
		return parent;
	}
}

/* Upside down Binary Tree recursive*/
public class Solution{
	public TreeNode upside(TreeNode root){
		if(root==null) return root;
		TreeNode p = root, left = root.left, right = root.right;
		while(left!=null){
		TreeNode ret = upside(left);
		left.left = right;
		left.right=parent;
		return ret;
		}
		return root;
	}
}
/* Check whether string is palindrome or not*/
public class Solution {
    public boolean isPalindrome(String s) {
        if(s==null || s.length()<=1)
            return true;
        String original = s.replaceAll("[^A-Za-z0-9]","").toLowerCase();
        String reverse = new StringBuffer(original).reverse().toString();
        return original.equals(reverse);
    }
}
/* Reverse the words in sentence / Reverse the words in string */
public class Solution 
{
    public String reverseWords(String s) 
    {
         String [] words = s.split(" ");
         StringBuilder sb = new StringBuilder();
         int end = words.length - 1;
         for(int i = 0; i<= end; i++)
         {
            if(!words[i].isEmpty()) 
            {
                sb.insert(0, words[i]);
                if(i < end) 
                    sb.insert(0, " ");
            }
        }
        return sb.toString();
    }
}


/* Reverse the words in sentence / Reverse the words in string  ALTERNATIVE*/
public class Solution {
    public String reverseWords(String s) {
        StringBuilder sb = new StringBuilder();
        if(s==null || s.length()<1)
            return sb.toString();
        String[] arr = s.split("\\s{1,}");
        for(int i=arr.length-1; i>=0 ; i--)
        {
            sb.append(arr[i] + " ");
        }
        return sb.toString().trim();
        
    }
}
/* get the length of last word in string/ get the length of last word in sentence  */
public class Solution {
    public int lengthOfLastWord(String s) {
 String str = s.trim();
     if (str==null) {
        return 0;
    } 
 String[] k = str.split(" ");
 return k[k.length-1].length();    
        
    }
}
/*Longest substring without repeating characters*/
public int LongestSubstring(String s) {
        int n=s.length();
        int i=0,j=0;
        int maxlength=0;
        char[] string = s.toCharArray();
        boolean[] buffer = new boolean[256];
       
        while(j<n){
            if(buffer[string[j]]){
               //maxlength = Math.max(maxlength, j-i);
               while(string[i]!=string[j]){
                   buffer[string[i]]=false;
                   i++;
               }
               i++;
               j++;
            }
            else{
                buffer[string[j]]=true;
                j++;
            }
        }
       // maxlength = Math.max(maxlength, n-i);
        return s.substring(i,j);
    }
/*Length of longest substring with non-repetitive / repeating characters  */
public class Solution {
    public int lengthOfLongestSubstring(String s) {
          int i = 0, j = 0, max = 0;
    Set<Character> set = new HashSet<>();

    while (j < s.length()) {
        if (!set.contains(s.charAt(j))) {
            set.add(s.charAt(j++));
            max = Math.max(max, set.size());
        } else {
            set.remove(s.charAt(i++));
        }
    }

    return max;
    }
}
/*find the index of string in another string / substring */
public class Solution {
    public int strStr(String haystack, String needle) {
        if(haystack == null || needle == null || needle.length() > haystack.length()){
            return -1;
        }
        for(int i = 0; i < haystack.length() - needle.length() + 1; i ++){
            if(haystack.substring(i, i + needle.length()).equals(needle)){
                return i;
            }
        }
        return -1;
    }
}
/*Simplify path */
public class Solution {
    public String simplifyPath(String path) {
        Stack<String> st = new Stack<String>();
        String [] str = path.split("/");
        for (String s:str)
        {
            if(s==null || "".equals(s) || ".".equals(s))
                continue;
        
            if("..".equals(s))
                {
                    if(!st.isEmpty())
                        st.pop();
                }
                else
                        st.push(s);
                
        }
        if(st.isEmpty())
        {
            return "/";
        }
        StringBuilder str_build = new StringBuilder("");
        for(String newStr:st)
        {
            str_build.append("/"+newStr);
        }
        return str_build.toString();
    }
}
/* Implementation of Minimum stack / min stack*/
class MinStack {
    Stack<Integer> mainStack = new Stack<Integer>();
        Stack<Integer> minStack = new Stack<Integer>();

        public void push(int x) {
            mainStack.push(x);
            if (minStack.empty()) {
                minStack.push(x);
            } else if (minStack.peek() >= x) {
                minStack.push(x);
            }
        }

        public void pop() {
            int poppedElement = mainStack.pop();
            if (poppedElement == minStack.peek()) {
                minStack.pop();
            }
        }

        public int top() {
            return mainStack.peek();
        }

        public int getMin() {
            return minStack.peek();
        }
}
/*Largest Rectangle in a histogram */
public class Solution {
    public int largestRectangleArea(int[] height) {
        if(height == null || height.length==0)
            return 0;
        int len = height.length;
        Stack<Integer> s = new Stack<Integer>();
        int maxArea = 0;
        for(int i = 0; i <= len; i++){
            int h = (i == len ? 0 : height[i]);
            if(s.isEmpty() || h >= height[s.peek()]){
                s.push(i);
            }else{
                int tp = s.pop();
                maxArea = Math.max(maxArea, height[tp] * (s.isEmpty() ? i : i - 1 - s.peek()));
                i--;
            }
        }
        return maxArea;
    }
}
/*validate parenthesis */
public class Solution {
    public boolean isValid(String s) {
         if(s==null){ return true; }

    Stack<Character> s1=new Stack<Character>();
        char[] c = s.toCharArray();
        for(int i=0;i<c.length;i++){
            if(!s1.empty()){
                if((s1.peek()=='(' && c[i]==')' )||(s1.peek()=='{' && c[i]=='}' )||(s1.peek()=='[' && c[i]==']' ) )
                    s1.pop();
                else
                    s1.push(c[i]);
            
            }else
                s1.push(c[i]);
        }
        return s1.empty();
        }
    }
    
/* Implement stack using queue*/
class MyStack {
    Queue<Integer> qu = new LinkedList<Integer>();
    
    
    // Push element x onto stack.
    public void push(int x) {
        qu.add(x);
        for(int i=0; i<qu.size()-1; i++)
        {
            qu.add(qu.remove());
        }
        
    }

    // Removes the element on top of the stack.
    public void pop() {
        qu.remove();
    }

    // Get the top element.
    public int top() {
        return qu.peek();
    }

    // Return whether the stack is empty.
    public boolean empty() {
        return qu.isEmpty();
    }
}
/*Implement queue using stack */
class MyQueue {
    // Push element x to the back of queue.
    Stack<Integer> s1 = new Stack<Integer>();
    Stack<Integer> s2 = new Stack<Integer>();
    public void push(int x) {
        s1.push(x);
    }

    // Removes the element from in front of queue.
    public void pop() {
        if(!s2.isEmpty()){
            s2.pop();
        return;
        }
        while(!s1.isEmpty()){
            s2.push(s1.pop());
        }
        s2.pop();
    }

    // Get the front element.
    public int peek() {
        if(!s2.isEmpty())
            return s2.peek();
        while(!s1.isEmpty())
        {
            s2.push(s1.pop());
        }
        return s2.peek();
    }

    // Return whether the queue is empty.
    public boolean empty() {
        return s1.isEmpty()&&s2.isEmpty();
    }
}
/* Evaluate Reverse polish notation*/
public class Solution {
    public int evalRPN(String[] tokens) {
        
        Stack<Integer> stack = new Stack<Integer>();
    int temp;
    for (int i = 0; i < tokens.length; i++) {
        switch (tokens[i]) {
        case "+":
            temp = stack.pop();
            stack.push(temp + stack.pop());
            break;
        case "-":
            temp = stack.pop();
            stack.push(stack.pop() - temp);
            break;
        case "*":
            temp = stack.pop();
            stack.push(stack.pop() * temp);
            break;
        case "/":
            temp = stack.pop();
            stack.push(stack.pop() / temp);
            break;
        default:
            stack.push(Integer.parseInt(tokens[i]));
        }
    }

    return stack.peek();
        
    }
}
/*Binary tree zig zag level order traversal */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        
        Stack<TreeNode> s1 = new Stack<TreeNode>();
        Stack<TreeNode> s2 = new Stack<TreeNode>();
        TreeNode curr = root;
        s1.push(curr);
        List<List<Integer>> arlist = new ArrayList<List<Integer>>();
        if(root==null)
            return arlist;
        while(!s1.isEmpty() || !s2.isEmpty())
        {
            List<Integer> li1 = new ArrayList<Integer>();
            List<Integer> li2 = new ArrayList<Integer>();
            int flag1 = 0;
            int flag2 = 0;
            while(!s1.isEmpty())
            {
                flag1=1;
                li1.add(s1.peek().val);
                if(s1.peek().left!=null)
                    s2.push(s1.peek().left);
                if(s1.peek().right!=null)
                    s2.push(s1.peek().right);
                s1.pop();
                
            }
            if(flag1==1)
            arlist.add(li1);
            while(!s2.isEmpty())
            {
                flag2=1;
                li2.add(s2.peek().val);
                if(s2.peek().right!=null)
                    s1.push(s2.peek().right);
                if(s2.peek().left!=null)
                    s1.push(s2.peek().left);
                s2.pop();
                
            }
            if(flag2==1)
            arlist.add(li2);
        }
        return arlist;
    }
}
/* Binary search tree iterator / BST iterator*/
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

public class BSTIterator {
private Stack<TreeNode> stack = null;
    public BSTIterator(TreeNode root) {
        stack = new Stack<>();

    TreeNode curr = root;
    while(curr!=null){
        stack.push(curr);
        curr = curr.left;
    }
    }

    /** @return whether we have a next smallest number */
    public boolean hasNext() {
        return !stack.isEmpty();
    }

    /** @return the next smallest number */
    public int next() {
        if(hasNext()){
        int ret = stack.peek().val;
        TreeNode curr = stack.pop();
        if(curr.right!=null){
            curr = curr.right;

            while(curr!=null){
                stack.push(curr);
                curr = curr.left;
            }
        }
        return ret;
    }
    return -1;
    }
}

/**
 * Your BSTIterator will be called like this:
 * BSTIterator i = new BSTIterator(root);
 * while (i.hasNext()) v[f()] = i.next();
 */
/* Basic calculator to evaluate expression / contains only ( ) + - / basic calculator to evaluate string */
public class Solution {
    public int calculate(String s) {
     Stack<Integer> stack = new Stack<Integer>();
    int result = 0;
    int number = 0;
    int sign = 1;
    for(int i = 0; i < s.length(); i++){
        char c = s.charAt(i);
        if(Character.isDigit(c)){
            number = 10 * number + (int)(c - '0');
        }else if(c == '+'){
            result += sign * number;
            number = 0;
            sign = 1;
        }else if(c == '-'){
            result += sign * number;
            number = 0;
            sign = -1;
        }else if(c == '('){
            //we push the result first, then sign;
            stack.push(result);
            stack.push(sign);
            //reset the sign and result for the value in the parenthesis
            sign = 1;   
            result = 0;
        }else if(c == ')'){
            result += sign * number;  
            number = 0;
            result *= stack.pop();    //stack.pop() is the sign before the parenthesis
            result += stack.pop();   //stack.pop() now is the result calculated before the parenthesis

        }
    }
    if(number != 0) result += sign * number;
    return result;
}
}
/* Binary tree preorder traversal iterative*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
         List<Integer> answer = new LinkedList<Integer>();
         Stack<TreeNode> stack = new Stack<TreeNode>();

         if(root==null)
         {
             return answer;
         }

         stack.push(root);
         while(stack.isEmpty()==false)
         {
             TreeNode node = stack.pop();
             answer.add(node.val);
             if(node.right!=null)
             {
                 stack.push(node.right);
             }
             if(node.left!=null)
             {
                 stack.push(node.left);
             }
         }
         return answer;
    }
}
/* Binary tree preorder traversal recursion*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
         List<Integer> list = new ArrayList<Integer>();
    if (root!=null) {
        list.add(root.val);
        list.addAll(preorderTraversal(root.left));
        list.addAll(preorderTraversal(root.right));
    }
    return list;
    }
}
/* Binary tree postorder traversal recursion*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
                List<Integer> list = new ArrayList<Integer>();
    if (root!=null) {
        
        list.addAll(postorderTraversal(root.left));
        list.addAll(postorderTraversal(root.right));
        list.add(root.val);
        
    }
    return list;

    }
}
/* Binary tree postorder traversal iterative*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> list = new ArrayList<Integer>();
    if (root == null) {
        return list;
    }
    HashMap<TreeNode,Boolean> nodesPushedToStack = new HashMap<TreeNode,Boolean>();
    Stack<TreeNode> stack = new Stack<TreeNode>();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        if (!nodesPushedToStack.containsKey(node)) {
              nodesPushedToStack.put(node,true); 
              stack.push(node);
              if (node.right != null) {
                  stack.push(node.right);
              }
              if (node.left != null) {
                  stack.push(node.left);
              }
        } 
        else {
            list.add(node.val);
        }
    }
    return list;

    }
}
/* Binary tree inorder traversal iterative*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        
        List<Integer> ans = new ArrayList<>();
                Stack<TreeNode> stack = new Stack<>();
    TreeNode cur = root;
    while (!stack.isEmpty() || cur != null) {
        while (cur != null) {
            stack.push(cur);
            cur = cur.left;
        }
        cur = stack.pop();
        ans.add(cur.val);
        cur = cur.right;
    }
    return ans;

    }
}
/* Binary tree inorder traversal recursion	*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    List<Integer> ans = new ArrayList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
        
        
     if (root == null) return ans;
   inorderTraversal(root.left);
   ans.add(root.val);
   return inorderTraversal(root.right);

    }
}

/*Contains Duplicate. Two distinct indices. Difference between i and j is at most/ atmost k*/
public class Solution {
Map<Integer, Integer> map = new HashMap<Integer, Integer>();
    for (int i = 0; i < nums.length; i++) {
        if (map.containsKey(nums[i])) {
            if (i - map.get(nums[i]) <= k) return true;
        }
        map.put(nums[i], i);
    }
    return false;
}
}
/* Check if array contains any duplicate / array duplicate*/
public class Solution {
    public boolean containsDuplicate(int[] nums) {
        
        if (nums.length==0) return false;
        HashSet<Integer> hs = new HashSet<>();
        for(int n : nums) {
            if (!hs.add(n)) return true;
        }
        return false;
        }
}
/* Majority element in the array*/
public class Solution {
    public int majorityElement(int[] nums) {
        HashMap<Integer,Integer> map = new HashMap<Integer,Integer>();
        int majority = (int)Math.floor(nums.length/2);
        int highest = 0;
        for(int i : nums){
            if(map.containsKey(i))
                map.put(i,map.get(i)+1);
            else
                map.put(i,1);
        }
        
        for(Map.Entry<Integer,Integer> result : map.entrySet()){
            if(result.getValue()>majority){
                highest = result.getKey();
                majority = result.getValue();
            }
                
        }
        return highest;    
    }
}

/*Merger Intervals*/
public List<Interval> merge(List<Interval> intervals) {
    if (intervals.size() <= 1)
        return intervals;

    // Sort by ascending starting point using an anonymous Comparator
    Collections.sort(intervals, new Comparator<Interval>() {
        @Override
        public int compare(Interval i1, Interval i2) {
            return Integer.compare(i1.start, i2.start);
        }
    });

    List<Interval> result = new LinkedList<Interval>();
    int start = intervals.get(0).start;
    int end = intervals.get(0).end;

    for (Interval interval : intervals) {
        if (interval.start <= end) // Overlapping intervals, move the end if needed
            end = Math.max(end, interval.end);
        else {                     // Disjoint intervals, add the previous one and reset bounds
            result.add(new Interval(start, end));
            start = interval.start;
            end = interval.end;
        }
    }

    // Add the last interval
    result.add(new Interval(start, end));
    return result;
}

/* merge two sorted arrays at back of other array/ at back of first array/ without using extra space*/
public class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int num1Tail = m - 1;
    int num2Tail = n - 1;
    int newTail = m + n - 1;

    while(num2Tail >= 0) {
        //nums1: {4, }
        //nums2: {1}
        //so num1Tail >= 0 is very important!!!
        if(num1Tail >= 0 && nums1[num1Tail] > nums2[num2Tail]) {
            nums1[newTail] = nums1[num1Tail];
            num1Tail--;
        }
        else {
            nums1[newTail] = nums2[num2Tail];
            num2Tail--;
        }
        newTail--;
    }
    }
}
/*Move zeros / 0 to one end*/
public class Solution {
    public void moveZeroes(int[] nums) {
        
        int p = 0;
        for(int i : nums)
        {
            if(i!=0)
            {
                nums[p]=i;
                p++;
            }
            
        }
        
        while(p<nums.length)
            {
                nums[p]=0;
                p++;
            }
    }
}
/*Pascal triangle*/
public class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
    if (numRows == 0)
        return ans;

    LinkedList<Integer> sub = new LinkedList<Integer>();
    sub.add(1);
    ans.add(sub);

    for (int i = 1; i < numRows; i++) {
        LinkedList<Integer> subAns = new LinkedList<Integer>();
        List<Integer> list = ans.get(i - 1);
        subAns.addFirst(1);
        for (int j = 1; j < i; j++)
            subAns.addFirst(list.get(j - 1) + list.get(j));
        subAns.addFirst(1);
        ans.add(subAns);
    }

    return ans;
        
    }
}
/*Plus one to the array/at MSB*/
public class Solution {
    public int[] plusOne(int[] digits) {
        int n = digits.length;
    for(int i=n-1; i>=0; i--) {
        if(digits[i] < 9) {
            digits[i]++;
            return digits;
        }

        digits[i] = 0;
    }

    int[] newNumber = new int [n+1];
    newNumber[0] = 1;
return newNumber;
    }
}
/* Remove Duplicates from sorted array without using extra space*/
public class Solution {
    public int removeDuplicates(int[] nums) {
        int j = 0;
        for (int i = 0; i < nums.length; i++) {
            if (i > 0 && nums[i - 1] == nums[i]) 
                continue;
            nums[j] = nums[i];
            j++;
        }
        return j;
    }
}
/* remove duplicates from array with at most/atmost 2 same / 2 duplicates */
public class Solution {
    public int removeDuplicates(int[] nums) {
        if(nums.length<3)
            return nums.length;
        int count=2;
        for(int i=2 ; i <nums.length; i++)
        {
            nums[count] = nums[i];  
            if(!(nums[count]==nums[count-1] && nums[count]==nums[count-2]))
                count++;
        }
        return count;
        
    }
}

/*Serialize and de-serialize a tree*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        helper(root, sb);
        return sb.toString();
    }
    private void helper(TreeNode node, StringBuilder sb)
    {
        if(node==null){
            sb.append("null").append(",");
                return;
        }
        sb.append(node.val).append(",");
        helper(node.left, sb);
        helper(node.right, sb);
    }
    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        String[]  val = data.split(",");
        int[] index = new int[]{0};
        return helperD(val, index);
    }
    TreeNode helperD(String[] val, int[] index)
    {
        if(index[0]==val.length)
            return null;
        String visiting = val[index[0]++];
        if(visiting.equals("null"))
            return null;
        TreeNode node= new TreeNode(Integer.valueOf(visiting));
        node.left=helperD(val, index);
        node.right=helperD(val, index);
        
        return node;
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));
/* Add two numbers using linked list */
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        if(l1==null)
            return l2;
        if(l2==null)
            return l1;
        ListNode head =new ListNode(0);
        ListNode p=head;
        int temp=0;
        while(l1!=null || l2!=null || temp!=0)
        {
            if(l1!=null)
            {
                temp+=l1.val;
                l1=l1.next;
            }
            if(l2!=null)
            {
                temp+=l2.val;
                l2=l2.next;
            }
            p.next = new ListNode(temp%10);
            p=p.next;
            temp = temp/10;
        }
        return head.next;
    }
}
/* Create Binary search tree from sorted linked list / create bst from sorted list*/
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode sortedListToBST(ListNode head) {
            if(head==null)
        return null;
    ListNode slow = head;
    ListNode fast = head;
    ListNode temp=null;

    //find the mid node
    while(fast.next!=null && fast.next.next!=null){
        fast = fast.next.next;
        temp = slow;
        slow = slow.next;
    }

    if(temp!=null)
        temp.next = null; //break the link
    else
        head = null;

    TreeNode root = new TreeNode(slow.val);
    root.left = sortedListToBST(head);
    root.right = sortedListToBST(slow.next);
    return root;

    }
}
/* Flatten Binary tree to linked list*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public void flatten(TreeNode root) {
        if (root == null) return;

        TreeNode left = root.left;
        TreeNode right = root.right;

        root.left = null;

        flatten(left);
        flatten(right);

        root.right = left;
        TreeNode cur = root;
        while (cur.right != null) 
            cur = cur.right;
        cur.right = right;
    }
}
/*Binary Tree maximum path sum */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    int maxValue;
    public int maxPathSum(TreeNode root) {
        maxValue = Integer.MIN_VALUE;
        maxPathDown(root);
        return maxValue;
    }
     private int maxPathDown(TreeNode node) {
        if (node == null) return 0;
        int left = Math.max(0, maxPathDown(node.left));
        int right = Math.max(0, maxPathDown(node.right));
        maxValue = Math.max(maxValue, left + right + node.val);
        return Math.max(left, right) + node.val;
    }
    
}
/* Recover binary search tree / recover BST / indentify  2 swapped elements in BST*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {

    TreeNode firstElement = null;
    TreeNode secondElement = null;
    // The reason for this initialization is to avoid null pointer exception in the first comparison when prevElement has not been initialized
    TreeNode prevElement = new TreeNode(Integer.MIN_VALUE);

    public void recoverTree(TreeNode root) {

        // In order traversal to find the two elements
        traverse(root);

        // Swap the values of the two nodes
        int temp = firstElement.val;
        firstElement.val = secondElement.val;
        secondElement.val = temp;
    }

    private void traverse(TreeNode root) {

        if (root == null)
            return;

        traverse(root.left);

        // Start of "do some business", 
        // If first element has not been found, assign it to prevElement (refer to 6 in the example above)
        if (firstElement == null && prevElement.val >= root.val) {
            firstElement = prevElement;
        }

        // If first element is found, assign the second element to the root (refer to 2 in the example above)
        if (firstElement != null && prevElement.val >= root.val) {
            secondElement = root;
        }        
        prevElement = root;

        // End of "do some business"

        traverse(root.right);
}
}
/*Populating Next Right Pointers in each node of Binary tree / left node should make an arrow towards right node ITERATIVE*/
/**
 * Definition for binary tree with next pointer.
 * public class TreeLinkNode {
 *     int val;
 *     TreeLinkNode left, right, next;
 *     TreeLinkNode(int x) { val = x; }
 * }
 */
public class Solution {

    //based on level order traversal
    public void connect(TreeLinkNode root) {

        TreeLinkNode head = null; //head of the next level
        TreeLinkNode prev = null; //the leading node on the next level
        TreeLinkNode cur = root;  //current node of current level

        while (cur != null) {

            while (cur != null) { //iterate on the current level
                //left child
                if (cur.left != null) {
                    if (prev != null) {
                        prev.next = cur.left;
                    } else {
                        head = cur.left;
                    }
                    prev = cur.left;
                }
                //right child
                if (cur.right != null) {
                    if (prev != null) {
                        prev.next = cur.right;
                    } else {
                        head = cur.right;
                    }
                    prev = cur.right;
                }
                //move to next node
                cur = cur.next;
            }

            //move to next level
            cur = head;
            head = null;
            prev = null;
        }

    }
}
/* Populating Next Right Pointers in each node of Binary tree / left node should make an arrow towards right node RECURSIVE*/
/**
 * Definition for binary tree with next pointer.
 * public class TreeLinkNode {
 *     int val;
 *     TreeLinkNode left, right, next;
 *     TreeLinkNode(int x) { val = x; }
 * }
 */
public class Solution {
    public void connect(TreeLinkNode root) {
        if (root == null) return;

        // link root's child nodes
        link(root);

        // before we recurse to the next level
        // make sure all the child nodes of the nodes at current level are linked
        TreeLinkNode curr = root.next;
        while (curr != null) {
            link(curr);
            curr = curr.next;
        }

        connect(root.left);
        connect(root.right);
    }

    // helper function
    // link root node's left and right nodes
    void link(TreeLinkNode root) {
        if (root == null) return;

        if (root.left != null) {
            root.left.next = root.right != null ? root.right : getNext(root);
        } 

        if (root.right != null) {
            root.right.next = getNext(root);
        }
    }

    // get the left most node at the next level
    TreeLinkNode getNext(TreeLinkNode node) {
        TreeLinkNode next = node.next;

        while (next != null) {
            if (next.left != null) return next.left;
            if (next.right != null) return next.right;
            next = next.next;
        }

        return null;
    }
}

/*Group Anagrams / find all anagrams in list of string and return all anagrams in list. */
public class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> li = new ArrayList<List<String>>();
        if(strs==null || strs.length==0)
            return li;
        Arrays.sort(strs);
        
        HashMap<String, List<String>> hm = new HashMap<String, List<String>>();
        for(String s : strs)
        {
            char [] ch =  s.toCharArray();
            Arrays.sort(ch);
            String str= String.valueOf(ch);
            if(!hm.containsKey(str))
                hm.put(str, new ArrayList<String>());
            hm.get(str).add(s);
        }
        for (List<String> item: hm.values())   
            li.add(item);
        return li;
        
        // above three lines can be written as  return new ArrayList<List<String>>(hm.values());
        
    }
}
/* Valid Palindrome String*/
public class Solution {
    public boolean isPalindrome(String s) {
        if(s==null || s.length()<=1)
            return true;
        String original = s.replaceAll("[^A-Za-z0-9]","").toLowerCase();
        String reverse = new StringBuffer(original).reverse().toString();
        return original.equals(reverse);
    }
}

/*Zig zag conversion of string. Convert string to zig zag pattern and then write the zig zag string */
public class Solution {
    public String convert(String s, int n) {
        if (s.length()==0 || n==1)
            return s;
        StringBuilder[] sb = new StringBuilder[n];
        for(int m=0; m<sb.length;m++)
            sb[m] = new StringBuilder("");
        int j=0;
        int f=1;
        for(int i=0 ; i<s.length() ; i++)
        {
            if(f==1){
                sb[j].append(s.charAt(i));
                j++;
                if(j==n)
                {
                    j--;
                    f=0;
                }
                    
                }
            
            else
                {
                    j--;
                    sb[j].append(s.charAt(i));
                    if(j==0){
                        f=1;
                        j++;
                        
                    }
                }
            
        }
        StringBuilder result = new StringBuilder();
            for (StringBuilder sr : sb)
                result.append(sr);
    
        return result.toString();
    }
    
}
/* Reverse Words in a string */
public class Solution {
    public String reverseWords(String s) {
        StringBuilder sb = new StringBuilder();
        if(s==null || s.length()<1)
            return sb.toString();
        String[] arr = s.split("\\s{1,}");
        for(int i=arr.length-1; i>=0 ; i--)
        {
            sb.append(arr[i] + " ");
        }
        return sb.toString().trim();
        
    }
}
/*Decode Characters (A-1, B-2,Â..Z-26) ITERATIVE*/
public class Solution {
    public int numDecodings(String s) {
        int n1 =1, n2=1, n3=0;
    if(s.length()==0||s.charAt(0)=='0') return 0;
    for(int i=2; i<=s.length(); i++)
    {
        n3=0;
        if(s.charAt(i-1)!='0') n3=n2;
        int num = Integer.parseInt(s.substring(i-2,i));
        if(num>=10 && num<=26) n3+=n1;
        n1=n2;
        n2=n3;
    }
    return n2;
    }
}
/* Decode Characters (A-1, B-2,Â..Z-26) RECURSIVE */
	
/* If a word can be segmented into one or more dictionary workds.*/
public class Solution {
    public boolean wordBreak(String s, Set<String> wordDict) {
        if (s == null && wordDict == null)
        return true;
    if (s == null || wordDict == null)
        return false;
    //dp[i] represents if s.substring(0, i+1) is wordbreakable.
    boolean[] dp = new boolean[s.length()+1];
    dp[0] = true;
    for (int i = 1; i <= s.length(); i++) {
        for (int j = 0; j < i; j++) {
            if (dp[j] && wordDict.contains(s.substring(j, i))) {
                dp[i] = true;
                break;
            }
        }
    }
    return dp[s.length()];
    }
}
/* Compute and return square root of X (sqrt(x)) */
public class Solution {
    public int mySqrt(int x) {
         if(x <= 0) return 0;
        int l = 1, r = x, res = 1;
        while(l < r) {
            int mid = (l + r) / 2;
            if(mid > x/mid) {
                r = mid;
            } else {
                res = mid;
                l = mid + 1;
            }
        }
        return res;
    }
}
/*Indexes of numbers in array which on adding forms a target value / Two Sum (INDEX IS NOT ZERO BASED)  */
public class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int[] result = new int[2];
    Map<Integer, Integer> map = new HashMap<Integer, Integer>();
    for (int i = 0; i < numbers.length; i++) {
        if (map.containsKey(target - numbers[i])) {
            result[1] = i + 1;
            result[0] = map.get(target - numbers[i]);
            return result;
        }
        map.put(numbers[i], i + 1);
    }
    return result;
    }
}
/* Rotate an image or square matrix by  90 degree WITH EXPLAINATION 
The idea is to loop through the top-left quadrant of the matrix (including the middle column for odd N), and for each element make 4-element swap (rotation). Meaning that for example if we have 5x5 M, and the current element is M[1,2] then we memorize M[1,2] into tmp and make: M[1,2] = M[2,1]; M[2,1] = M[3,2]; M[3,2] = M[2,3]; M[2,3] = tmp
*/
public class Solution {
    public void rotate(int[][] M) {
        for (int i = 0; i < (M.length+1)/2; i++) {
            for (int j = 0; j < M.length/2; j++) {
                int tmp = M[i][j];
                M[i][j] = M[M.length-j-1][i];
                M[M.length-j-1][i] = M[M.length-i-1][M.length-j-1];
                M[M.length-i-1][M.length-j-1] = M[j][M.length-i-1];
                M[j][M.length-i-1] = tmp;
            }
        }
    }
}
/* Validate Number/ validate if given string is numeric METHOD 1*/
public class Solution {
    public boolean isNumber(String s) {
        return s.matches("(\\s*)[+-]?((\\.[0-9]+)|([0-9]+(\\.[0-9]*)?))(e[+-]?[0-9]+)?(\\s*)");
    }
}
/* Validate Number/ validate if given string is numeric METHOD 2 */
public class Solution {
    public boolean isNumber(String s) {
         try {
        s = s.trim();
        int n = s.length();
        if ( n == 0 || (s.charAt(n-1) != '.' && (s.charAt(n-1) - '0' < 0 || s.charAt(n-1) - '0' > 9 )) ) {
            return false;
        }
        double i = Double.parseDouble(s);
        return true;
    }
    catch (NumberFormatException e) {
        return false;
    }
    }
}
/* Validate Number/ validate if given string is numeric METHOD 3 */
public class Solution {
    public boolean isNumber(String s) {
             s = s.trim();
    if (s.length() == 0)
        return false;
    if (s.matches("[+-]?(([0-9]*\\.?[0-9]+)|([0-9]+\\.?[0-9]*))([eE][+-]?[0-9]+)?"))
        return true;
    else
        return false;
    }
}
/* Validate Number/ validate if given string is numeric METHOD 4*/
public class Solution {
    public boolean isNumber(String s) {
    
         if (s == null) return false;

        s = s.trim();
        int n = s.length();

        if (n == 0) return false;

        // flags
        int signCount = 0;
        boolean hasE = false;
        boolean hasNum = false;
        boolean hasPoint = false;

        for (int i = 0; i < n; i++) {
            char c = s.charAt(i);

            // invalid character
            if (!isValid(c)) return false;

            // digit is always fine
            if (c >= '0' && c <= '9') hasNum = true;

            // e or E
            if (c == 'e' || c == 'E') {
                // e cannot appear twice and digits must be in front of it
                if (hasE || !hasNum) return false;
                // e cannot be the last one
                if (i == n - 1) return false;

                hasE = true;
            }

            // decimal place
            if (c == '.') {
                // . cannot appear twice and it cannot appear after e
                if (hasPoint || hasE) return false;
                // if . is the last one, digits must be in front of it, e.g. "7."
                if (i == n - 1 && !hasNum) return false;

                hasPoint = true;
            }

            // signs
            if (c == '+' || c == '-') {
                // no more than 2 signs
                if (signCount == 2) return false;
                // sign cannot be the last one
                if (i == n - 1) return false;
                // sign can appear in the middle only when e appears in front
                if (i > 0 && !hasE) return false;

                signCount++;
            }
        }

        return true;
    
    }
    boolean isValid(char c) {
        return c == '.' || c == '+' || c == '-' || c == 'e' || c == 'E' || c >= '0' && c <= '9';
    }
}
/* Justify Text / Justification / Given an array of words and a length L, format the text such that each line has exactly L characters and is fully (left and right) justified.*/
public class Solution {
    public List<String> fullJustify(String[] words, int L) {
        List<String> lines = new ArrayList<String>();

        int index = 0;
        while (index < words.length) {
            int count = words[index].length();
            int last = index + 1;
            while (last < words.length) {
                if (words[last].length() + count + 1 > L) break;
                count += words[last].length() + 1;
                last++;
            }

            StringBuilder builder = new StringBuilder();
            int diff = last - index - 1;
            // if last line or number of words in the line is 1, left-justified
            if (last == words.length || diff == 0) {
                for (int i = index; i < last; i++) {
                    builder.append(words[i] + " ");
                }
                builder.deleteCharAt(builder.length() - 1);
                for (int i = builder.length(); i < L; i++) {
                    builder.append(" ");
                }
            } else {
                // middle justified
                int spaces = (L - count) / diff;
                int r = (L - count) % diff;
                for (int i = index; i < last; i++) {
                    builder.append(words[i]);
                    if (i < last - 1) {
                        for (int j = 0; j <= (spaces + ((i - index) < r ? 1 : 0)); j++) {
                            builder.append(" ");
                        }
                    }
                }
            }
            lines.add(builder.toString());
            index = last;
        }
        return lines;
    }
}
/*Maximum numbers of points on a Line / maximum number of points that lie on the same straight line / Given n points in 2D plane METHOD 1 */
/**
 * Definition for a point.
 * class Point {
 *     int x;
 *     int y;
 *     Point() { x = 0; y = 0; }
 *     Point(int a, int b) { x = a; y = b; }
 * }
 */
public class Solution {
    public int maxPoints(Point[] points) {
         if(points.length <= 0) return 0;
        if(points.length <= 2) return points.length;
        int result = 0;
        for(int i = 0; i < points.length; i++){
            HashMap<Double, Integer> hm = new HashMap<Double, Integer>();
            int samex = 1;
            int samep = 0;
            for(int j = 0; j < points.length; j++){
                if(j != i){
                    if((points[j].x == points[i].x) && (points[j].y == points[i].y)){
                        samep++;
                    }
                    if(points[j].x == points[i].x){
                        samex++;
                        continue;
                    }
                    double k = (double)(points[j].y - points[i].y) / (double)(points[j].x - points[i].x);
                    if(hm.containsKey(k)){
                        hm.put(k,hm.get(k) + 1);
                    }else{
                        hm.put(k, 2);
                    }
                    result = Math.max(result, hm.get(k) + samep);
                }
            }
            result = Math.max(result, samex);
        }
        return result;
    }
}
/* /*Maximum numbers of points on a Line / maximum number of points that lie on the same straight line / Given n points in 2D plane METHOD 2*/
/**
 * Definition for a point.
 * class Point {
 *     int x;
 *     int y;
 *     Point() { x = 0; y = 0; }
 *     Point(int a, int b) { x = a; y = b; }
 * }
 */
public class Solution {
    public int maxPoints(Point[] points) {
         int n=points.length;
            if (n<2) return n;
            int currentL=0,maxL=2,x=0,y=0,dx=0,dy=0,overlap=0,upperB=n;
            for(int i=0; i<upperB; i++)
            {
                for(int j=i+1; j<n; j++)
                {
                    currentL=1; 
/*
 * Given two points: (a,b) and (c,d), the corresponding normal vector is (b-d,c-a)
 * If another point (s,t) is in the same line uniquely defined by (a,b) and (c,d),
 * then (s-a,t-b) dot (b-d,c-a) = 0
 */
                    x=points[i].y-points[j].y;
                    y=points[j].x-points[i].x;

/* If two points are the same, there is no need to check further, 
 * since a line has to be defined by exactly two distinct points.
 */
                    if(x==0 && y==0) 
                        overlap++;

/* Well, it might be the case that duplicates are not consecutive, 
 * but as long as we can have a non-trivial normal vector, it won't matter.
 */ 
                    else 
                    {
                        currentL++;

/*  Explaining (currentL+n-k>maxL):
 *  no further checking is necessary when there isn't enough left to make it surpass maxL. 
 */ 
                        for(int k=j+1; k<n && currentL+n-k>maxL; k++)
                        {
                            dx=points[k].x-points[i].x;
                            dy=points[k].y-points[i].y;
                            if(x*dx+y*dy==0)
                                currentL++;
                        }
                    }
                    maxL=Math.max(currentL+overlap,maxL);
                }

/* Explaining (upperB=n-maxL): 
 * it would be crystal clear as soon as you draw a table for combinations of case n>3.
 */
                upperB=n-maxL;
                overlap=0;
            }
            return maxL;
    }
}
/*Implement LRU Cache */
import java.util.*;
public class LRUCache {
    
    private LinkedHashMap<Integer, Integer> pairs;
private int capacity;
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
    this.pairs = new LinkedHashMap<Integer, Integer>() {
        protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
            return size() > capacity;
        }
    };
    }
    
    public int get(int key) {
        if (pairs.containsKey(key)) {
        int value = pairs.get(key);
        pairs.remove(key);
        pairs.put(key, value);
        return pairs.get(key);
    }
    else {
        return -1;
    }
    }
    
    public void set(int key, int value) {
        if (pairs.containsKey(key)) {
        pairs.remove(key);
    }
    pairs.put(key, value);   
    }
}
/* Substring with concatenation of all words / index of combination of words in a string.*/
public class Solution {
    public List<Integer> findSubstring(String S, String[] L) {
         List<Integer> res = new ArrayList<Integer>();
    if (S == null || L == null || L.length == 0) return res;
    int len = L[0].length(); // length of each word

    Map<String, Integer> map = new HashMap<String, Integer>(); // map for L
    for (String w : L) map.put(w, map.containsKey(w) ? map.get(w) + 1 : 1);

    for (int i = 0; i <= S.length() - len * L.length; i++) {
        Map<String, Integer> copy = new HashMap<String, Integer>(map);
        for (int j = 0; j < L.length; j++) { // checkc if match
            String str = S.substring(i + j*len, i + j*len + len); // next word
            if (copy.containsKey(str)) { // is in remaining words
                int count = copy.get(str);
                if (count == 1) copy.remove(str);
                else copy.put(str, count - 1);
                if (copy.isEmpty()) { // matches
                    res.add(i);
                    break;
                }
            } else break; // not in L
        }
    }
    return res;   
    }
}
/* Regular Expression Matching / String matching using regular expression RECURSIVE*/
public class Solution {
    public boolean isMatch(String s, String p) {
         if (p.isEmpty()) {
        return s.isEmpty();
    }

    if (p.length() == 1 || p.charAt(1) != '*') {
        if (s.isEmpty() || (p.charAt(0) != '.' && p.charAt(0) != s.charAt(0))) {
            return false;
        } else {
            return isMatch(s.substring(1), p.substring(1));
        }
    }

    //P.length() >=2
    while (!s.isEmpty() && (s.charAt(0) == p.charAt(0) || p.charAt(0) == '.')) {  
        if (isMatch(s, p.substring(2))) { 
            return true;                     
        }                                    
        s = s.substring(1);
    }

    return isMatch(s, p.substring(2));
    }
}
/* Regular Expression Matching / String matching using regular expression DP (ITERATIVE)*/
public class Solution {
    public boolean isMatch(String s, String p) {
int sL=s.length(), pL=p.length();

    boolean[][] dp = new boolean[sL+1][pL+1];
    dp[0][0] = true; // If s and p are "", isMathch() returns true;

    for(int i=0; i<=sL; i++) {

        // j starts from 1, since dp[i][0] is false when i!=0;
        for(int j=1; j<=pL; j++) {
            char c = p.charAt(j-1);

            if(c != '*') {
                // The last character of s and p should match;
                // And, dp[i-1][j-1] is true;
                dp[i][j] = i>0 && dp[i-1][j-1] && (c=='.' || c==s.charAt(i-1));
            }
            else {
                // Two situations:
                // (1) dp[i][j-2] is true, and there is 0 preceding element of '*';
                // (2) The last character of s should match the preceding element of '*';
                //     And, dp[i-1][j] should be true;
                dp[i][j] = (j>1 && dp[i][j-2]) ||
                           (i>0 && dp[i-1][j] && (p.charAt(j-2)=='.' || p.charAt(j-2)==s.charAt(i-1)));
            }
        }
    }

    return dp[sL][pL];
    }
}
/*Interleaving Strings ITERATIVE (DP)*/
public class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        int m = s1.length(), n = s2.length();
    if (n + m != s3.length()) return false;
    if (s3.length() == 0) return true;

    boolean[][] dp = new boolean[m+1][n+1];
    dp[0][0] = true;
    for (int i = 0; i <= m; i++) {
        if (s1.substring(0, i).equals(s3.substring(0, i))) 
            dp[i][0] = true;
        else 
            dp[i][0] = false;
    }
    for (int j = 0; j <= n; j++) {
        if (s2.substring(0, j).equals(s3.substring(0, j))) 
            dp[0][j] = true;
        else 
            dp[0][j] = false;
    }
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            dp[i][j] = (dp[i-1][j] && s1.charAt(i-1) == s3.charAt(i+j-1)) 
                    || (dp[i][j-1] && s2.charAt(j-1) == s3.charAt(i+j-1));
        }
    }
    return dp[m][n];
    }
}
/* Interleaving Strings RECURSIVE*/
public class Solution {
    int[][] checkedPaths;
    public boolean isInterleave(String s1, String s2, String s3) {
       if(s1.length() + s2.length() != s3.length())
            return false;       

        checkedPaths = new int[s1.length()][s2.length()];

        for(int i = 0 ; i < s1.length() ; i++){
            for(int j = 0 ; j < s2.length() ; j++){
                checkedPaths[i][j] = -1;
            }
        }

        return checkNext(s1, s2, s3);
    }
     private boolean checkNext(String s1, String s2, String s3){
        if(s3.length() == 0)
            return true;

        if(s1.length() == 0)
            return s2.equals(s3);

        if(s2.length() == 0)
            return s1.equals(s3);

        if(checkedPaths[s1.length() - 1][s2.length() - 1] == 1){
            return false;
        } else{
            checkedPaths[s1.length() - 1][s2.length() -1] = 1;
        }

        boolean s1Match = s1.charAt(0) == s3.charAt(0);
        boolean s2Match = s2.charAt(0) == s3.charAt(0);

        if(s1Match && s2Match){
            return ( checkNext(s1.substring(1), s2, s3.substring(1)) || checkNext(s1, s2.substring(1), s3.substring(1)) );
        } else if(s1Match){
            return checkNext(s1.substring(1), s2, s3.substring(1));
        } else if(s2Match){
            return checkNext(s1, s2.substring(1), s3.substring(1));
        } else {
            return false;
        }
    }
}
/*Longest Valid Parenthesis METHOD 1 */
public class Solution {
    public int longestValidParentheses(String s) {
     Stack<Integer> stack = new Stack<Integer>();
    int max=0;
    int left = -1;
    for(int j=0;j<s.length();j++){
        if(s.charAt(j)=='(') stack.push(j);            
        else {
            if (stack.isEmpty()) left=j;
            else{
                stack.pop();
                if(stack.isEmpty()) max=Math.max(max,j-left);
                else max=Math.max(max,j-stack.peek());
               }
            }
        }
    return max;   
    }
}
/* Longest Valid Parenthesis METHOD 2 */
public class Solution {
    public int longestValidParentheses(String s) {
        char[] S = s.toCharArray();
    int[] V = new int[S.length];
    int open = 0;
    int max = 0;
    for (int i=0; i<S.length; i++) {
        if (S[i] == '(') open++;
        if (S[i] == ')' && open > 0) {
            V[i] = 2 + V[i-1] + (i-2-V[i-1] > 0 ? V[i-2-V[i-1]] : 0);
            open--;
        }
        if (V[i] > max) max = V[i];
    }
    return max;
        }
}
/* Merge K sorted list RECURSION METHOD 1*/
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
         if(lists == null || lists.length == 0 ){
        return null;
    }
    return mergeKLists(lists,0,lists.length-1);
    }
    public ListNode mergeKLists(ListNode[] lists, int left, int right){
    if(left < right){
        int mid = (left + right)/2;
        return merge(mergeKLists(lists,left,mid),mergeKLists(lists,mid+1,right));
    }
    return lists[left];
}
public ListNode merge(ListNode n1, ListNode n2){
    ListNode head =  new ListNode(0);
    ListNode n = head;
    while(n1 != null && n2 != null){
        if(n1.val < n2.val){
            n.next = n1;
            n1 = n1.next;
            n = n.next;
        }else{
            n.next = n2;
            n = n.next;
            n2 = n2.next;
        }
    }
    if( n1 != null){
        n.next = n1;
    }else{
        n.next = n2;
    }
    return head.next;
}
}
/*Merge K sorted lists using RECURSION METHOD 2*/
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
 public class Solution{
public static ListNode mergeKLists(ListNode[] lists){
    return partion(lists,0,lists.length-1);
}

public static ListNode partion(ListNode[] lists,int s,int e){
    if(s==e)  return lists[s];
    if(s<e){
        int q=(s+e)/2;
        ListNode l1=partion(lists,s,q);
        ListNode l2=partion(lists,q+1,e);
        return merge(l1,l2);
    }else
        return null;
}

//This function is from Merge Two Sorted Lists.
public static ListNode merge(ListNode l1,ListNode l2){
    if(l1==null) return l2;
    if(l2==null) return l1;
    if(l1.val<l2.val){
        l1.next=merge(l1.next,l2);
        return l1;
    }else{
        l2.next=merge(l1,l2.next);
        return l2;
    }
}
}
/*Merge K sorted lists using Priority Queue */
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
      if (lists==null||lists.length==0) return null;

        PriorityQueue<ListNode> queue= new PriorityQueue<ListNode>(lists.length,new Comparator<ListNode>(){
            @Override
            public int compare(ListNode o1,ListNode o2){
                if (o1.val<o2.val)
                    return -1;
                else if (o1.val==o2.val)
                    return 0;
                else 
                    return 1;
            }
        });

        ListNode dummy = new ListNode(0);
        ListNode tail=dummy;

        for (ListNode node:lists)
            if (node!=null)
                queue.add(node);

        while (!queue.isEmpty()){
            tail.next=queue.poll();
            tail=tail.next;

            if (tail.next!=null)
                queue.add(tail.next);
        }
        return dummy.next;
}
}

/*Summary ranges */
public class Solution {
    public List<String> summaryRanges(int[] nums) {
        StringBuffer sb = new StringBuffer();
        List<String> res= new ArrayList<String>();
        if(nums == null || nums.length==0)
            return res;
        if(nums.length==1)
        {
            sb.append(nums[0]);
            res.add(sb.toString());
            return res;
        }
        int p=0;
        for (int i = 1; i < nums.length; i++) 
        {
            if (nums[i] == nums[i - 1] + 1) 
            {
                if (i == nums.length - 1) 
                {
                    res.add(nums[p] + "->" + nums[i]);
                }
            } 
            else 
            { 
                if (i == p + 1) 
                {
                    res.add(nums[p] + "");
                } 
                else 
                {
                    res.add(nums[p] + "->" + nums[i - 1]);
                }
                if (i == nums.length - 1) 
                {
                    res.add(nums[i] + "");
                }
                p = i;
            }
        }
        return res;
    }
}
/*3 Sum closest */
public class Solution {
    public int threeSumClosest(int[] nums, int target) {
        if(nums.length==3)
            return (nums[0]+nums[1]+nums[2]) ;
        Arrays.sort(nums);
        int diff = Integer.MAX_VALUE;
        int output=0;
        for(int i=0; i<nums.length-2;i++)
        {
            int low=i+1;
            int high = nums.length-1;
            while(low<high)
            {
                int sum = nums[i] + nums[low] + nums[high];
                if(Math.abs(target-sum)<diff)
                {
                    diff = Math.abs(target-sum);
                    output=sum;   
                }
                if(sum>target)
                    high--;
                else
                    low++;
            }
        }
        return output;
    }
}
/*3 Sum zero / 3sum zero / 3 numbers sum to zero*/
public class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
            List<List<Integer>> li = new ArrayList<List<Integer>>();
        Arrays.sort(nums);
        for(int i=0 ; i<=nums.length-3 ; i++)
        {
            if(i>0 && nums[i]==nums[i-1])
                continue;
            int start=i+1;
            int end= nums.length-1;
            while(start<end)
            {
                if(start>i+1 && nums[start]==nums[start-1])
                {
                    start++;
                    continue;
                }
                if(end<nums.length-1 && nums[end]==nums[end+1])
                {
                    end--;
                    continue;
                }
                int sum = nums[i]+ nums[start] +nums[end];
                if(sum==0)
                {
                    List<Integer> l = new ArrayList<Integer>();
                    l.add(nums[i]);
                    l.add(nums[start]);
                    l.add(nums[end]);
                    li.add(l);
                    start++;
                    end--;
                }
                else if(sum>0)
                    end--;
                else
                    start++;
            }
            
        }
        return li;        
    }
}

/* get the row of a pascal triangle (worst case)*/
public class Solution {
    public List<Integer> getRow(int k) {
        Integer[] arr = new Integer[k + 1];
        Arrays.fill(arr, 0);
        arr[0] = 1;

        for (int i = 1; i <= k; i++) 
            for (int j = i; j > 0; j--) 
                arr[j] = arr[j] + arr[j - 1];

        return Arrays.asList(arr);
    }
}
/* get the row of a pascal triangle (best case)*/
public class Solution {
    public List<Integer> getRow(int rowIndex) {
 List<Integer> result = new ArrayList<Integer>();
        result.add(1);
        long tmp = 1;
        for(int i=1;i<=rowIndex ; i++){
            tmp = tmp*(rowIndex-i+1)/i;
            result.add((int)(tmp));
        }
        return result;
    }
}
/* Replace element from an array and find the new length of array */
public class Solution {
    public int removeElement(int[] nums, int val) {
       int low=0;
       int high = nums.length-1;
       while(low<=high)
       {
           while(high>low && nums[high]==val)
           {
               high--;
           }
            if(nums[low]==val)
           {
               nums[low] = nums[high]; 
               high--;
           }
           low++;
       }
       return high+1;
    }
}
/* 4 Sum to a target value / 4sum target / 4 numbers sum to a given number */
public class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        Set<List<Integer>> resultSet = new HashSet<List<Integer>>();
        int a, b, c, d, start, end;
        Arrays.sort(nums);
        for(int i = 0; i < nums.length - 3; i++) {
            a = nums[i];
            for(int j = i + 1; j < nums.length - 2; j++) {
                b = nums[j];
                start = j + 1;
                end = nums.length - 1;
                while(start < end) {
                    c = nums[start];
                    d = nums[end];
                    if(a + b + c + d == target) {
                        List<Integer> quadruple = new ArrayList<Integer>();
                        quadruple.add(a);
                        quadruple.add(b);
                        quadruple.add(c);
                        quadruple.add(d);
                        resultSet.add(quadruple);
                        start++;
                        end--;
                    } else if(a + b + c + d < target)
                        start++;
                      else
                        end--;
                }
            }
        }
        List<List<Integer>> result = new ArrayList<List<Integer>>();
        result.addAll(resultSet);
        return result;
    }
}
/* index of Peak Element. Peak element is the element who is greater than his neighbours.*/
public class Solution {
    public int findPeakElement(int[] nums) {
        int max = Integer.MIN_VALUE;
        int j=0;
        for (int i=0; i<nums.length ; i++)
        {
            if(nums[i]>max)
            {
                max=nums[i];
                j=i;
            }
        }
        return j;
    }
}
/* Minimum element in rotated sorted array*/
public class Solution {
    public int findMin(int[] nums) {
         int l = 0, r = nums.length-1;
     while (l < r) {
         int mid = (l + r) / 2;
         if (nums[mid] < nums[r]) {
            //right side in order, and mid is smallest of right side,
            // min should be mid or in left.
             r = mid;   
         } else {
            //left side in order and it is the larger part,
            // min should be in right side.
             l = mid + 1; 
         }
     }
     return nums[l];
    }
}
/* First missing positive */
public class Solution {
    public int firstMissingPositive(int[] nums) {
        if(nums == null || nums.length ==0)
        return 1;
        int i = 0, n = nums.length;
    while (i < n) {
        // If the current value is in the range of (0,length) and it's not at its correct position, 
        // swap it to its correct position.
        // Else just continue;
        if (nums[i] >= 0 && nums[i] < n && nums[nums[i]] != nums[i])
            swap(nums, i, nums[i]);
        else
            i++;
    }
    int k = 1;

    // Check from k=1 to see whether each index and value can be corresponding.
    while (k < n && nums[k] == k)
        k++;

    // If it breaks because of empty array or reaching the end. K must be the first missing number.
    if (n == 0 || k < n)
        return k;
    else   // If k is hiding at position 0, K+1 is the number. 
        return nums[0] == k ? k + 1 : k;
    }
    private void swap(int[] nums, int i, int j) {
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
}
}
/*Max / Maximum jump to reach the end of array */
public class Solution {
    public boolean canJump(int[] nums) {
        int maxIndex = nums.length-1;
    int maxJump  = nums[0];
    for(int i = 0; i <= maxJump; i++)
    {
        maxJump=Math.max(maxJump,i+nums[i]);
        if(maxJump>=maxIndex) return true;
    }
    return false;
    }
}
/* Valid / validate parenthesis using stack*/
if (s.length() == 0) return true;
        Stack<Character> stack = new Stack<Character>();

        for(int i = 0; i < s.length(); ++i){
            Character c = s.charAt(i);
            if (c == '(' || c == '[' || c == '{') stack.push(c);
            else if (stack.empty()) return false;
            else{
                Character c2 = stack.pop();
                if(c2 == '(' && c != ')' || c2 == '{' && c != '}' || c2 == '[' && c != ']') return false;
            }
        }

        return stack.empty();
/* Valid / validate parenthesis using both Hashmap and stack */
public class Solution {
    public boolean isValid(String s) {
         if(s==null){ return true; }

    Stack<Character> charStack = new Stack<>();
    Map<Character, Character> charMap = initCharMap();
    for(Character ch : s.toCharArray()){
        if(charStack.isEmpty()){
            if(charMap.keySet().contains(ch)){
                return false;
            }
            else{
                charStack.push(ch);
            }
        }
        else{
            if(charStack.peek()==charMap.get(ch)){
                charStack.pop();
            }
            else{
                charStack.push(ch);
            }
        }
    }
    if(charStack.isEmpty()){
        return true;
    }
    return false;

}
private Map<Character, Character> initCharMap(){
    Map<Character, Character> charMap = new HashMap<>();
    charMap.put(')','(');
    charMap.put(']','[');
    charMap.put('}','{');
    return charMap;

        }
    }
/* Trapping Rain Water */
public class Solution {
    public int trap(int[] heights) {
        if(heights == null || heights.length < 2){ return 0; }

    int res = 0;

    int min = 0;
    int max = heights.length - 1;

    int minVal = heights[min];
    int maxVal = heights[max];

    while(max - min > 1){
        if(minVal <= maxVal){
            if(heights[min+1] > minVal){
                minVal = heights[min+1];
                min ++;
            }
            else{
                res += minVal - heights[min+1];
                min ++;
            }
        }
        else{
            if(heights[max-1] > maxVal){
                maxVal = heights[max-1];
                max --;
            }
            else{
                res += maxVal - heights[max-1];
                max --;
            }
        }
    }

    return res;

    }
}
/* Trapping Rain Water using stack*/
public class Solution {
    public int trap(int[] A) {
        Stack<Integer> stack = new Stack<Integer>();
        int sum = 0;
        int pre = 0;
        int i = -1;
        while(++i < A.length){
            if(A[i]==0){pre = 0;continue;}
            while(!stack.isEmpty() && A[i] >= A[stack.peek()]){
                sum += (A[stack.peek()] - pre) * (i-stack.peek()-1);
                pre = A[stack.pop()];
            }
            if(!stack.isEmpty()){
                sum += (A[i] - pre) * (i-stack.peek()-1);
                pre = A[i];
            }
            stack.push(i);
        }
        return sum;
    }
}

/* Min stack / Minimum stack*/
class MinStack {
    Stack<Integer> mainStack = new Stack<Integer>();
        Stack<Integer> minStack = new Stack<Integer>();

        public void push(int x) {
            mainStack.push(x);
            if (minStack.empty()) {
                minStack.push(x);
            } else if (minStack.peek() >= x) {
                minStack.push(x);
            }
        }

        public void pop() {
            int poppedElement = mainStack.pop();
            if (poppedElement == minStack.peek()) {
                minStack.pop();
            }
        }

        public int top() {
            return mainStack.peek();
        }

        public int getMin() {
            return minStack.peek();
        }
}
/*Preorder traversal of BST recursion*/
public class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<Integer>();
    if (root!=null) {
        list.add(root.val);
        list.addAll(preorderTraversal(root.left));
        list.addAll(preorderTraversal(root.right));
    }
    return list;
    }
}
/*Preorder traversal of BST iterative solution*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
         List<Integer> answer = new LinkedList<Integer>();
         Stack<TreeNode> stack = new Stack<TreeNode>();

         if(root==null)
         {
             return answer;
         }

         stack.push(root);
         while(stack.isEmpty()==false)
         {
             TreeNode node = stack.pop();
             answer.add(node.val);
             if(node.right!=null)
             {
                 stack.push(node.right);
             }
             if(node.left!=null)
             {
                 stack.push(node.left);
             }
         }
         return answer;
    }
}
/*Postorder traversal of BST iterative solution*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        LinkedList<Integer> ans = new LinkedList<>();
    Stack<TreeNode> stack = new Stack<>();
    if (root == null) return ans;

    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode cur = stack.pop();
        ans.addFirst(cur.val);
        if (cur.left != null) {
            stack.push(cur.left);
        }
        if (cur.right != null) {
            stack.push(cur.right);
        } 
    }
    return ans;
    }
}
/*Postorder traversal of BST recursive solution*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
                List<Integer> list = new ArrayList<Integer>();
    if (root!=null) {
        
        list.addAll(postorderTraversal(root.left));
        list.addAll(postorderTraversal(root.right));
        list.add(root.val);
        
    }
    return list;

    }
}
/*Inorder traversal of BST recursive solution*/

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
                   List<Integer> list = new ArrayList<Integer>();
    if (root!=null) {
        
        list.addAll(inorderTraversal(root.left));
        list.add(root.val);
        list.addAll(inorderTraversal(root.right));
        
        
    }
    return list;

    }
}
/*Inorder traversal of BST iterative solution*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        
        List<Integer> ans = new ArrayList<>();
                Stack<TreeNode> stack = new Stack<>();
    TreeNode cur = root;
    while (!stack.isEmpty() || cur != null) {
        while (cur != null) {
            stack.push(cur);
            cur = cur.left;
        }
        cur = stack.pop();
        ans.add(cur.val);
        cur = cur.right;
    }
    return ans;

    }
}
/*Binary Search tree BST Iterator*/
/**
 * Definition for binary tree
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

public class BSTIterator {
private Stack<TreeNode> stack = null;
    public BSTIterator(TreeNode root) {
        stack = new Stack<>();

    TreeNode curr = root;
    while(curr!=null){
        stack.push(curr);
        curr = curr.left;
    }
    }

    /** @return whether we have a next smallest number */
    public boolean hasNext() {
        return !stack.isEmpty();
    }

    /** @return the next smallest number */
    public int next() {
        if(hasNext()){
        int ret = stack.peek().val;
        TreeNode curr = stack.pop();
        if(curr.right!=null){
            curr = curr.right;

            while(curr!=null){
                stack.push(curr);
                curr = curr.left;
            }
        }
        return ret;
    }
    return -1;
    }
}

/**
 * Your BSTIterator will be called like this:
 * BSTIterator i = new BSTIterator(root);
 * while (i.hasNext()) v[f()] = i.next();
 */
/*Basic maths calculator using stack / evaluate arithmetic expression.*/
public class Solution {
    public int calculate(String s) {
     Stack<Integer> stack = new Stack<Integer>();
    int result = 0;
    int number = 0;
    int sign = 1;
    for(int i = 0; i < s.length(); i++){
        char c = s.charAt(i);
        if(Character.isDigit(c)){
            number = 10 * number + (int)(c - '0');
        }else if(c == '+'){
            result += sign * number;
            number = 0;
            sign = 1;
        }else if(c == '-'){
            result += sign * number;
            number = 0;
            sign = -1;
        }else if(c == '('){
            //we push the result first, then sign;
            stack.push(result);
            stack.push(sign);
            //reset the sign and result for the value in the parenthesis
            sign = 1;   
            result = 0;
        }else if(c == ')'){
            result += sign * number;  
            number = 0;
            result *= stack.pop();    //stack.pop() is the sign before the parenthesis
            result += stack.pop();   //stack.pop() now is the result calculated before the parenthesis

        }
    }
    if(number != 0) result += sign * number;
    return result;
}
}
/* Zig zag traversal of binary search tree BST */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        
        Stack<TreeNode> s1 = new Stack<TreeNode>();
        Stack<TreeNode> s2 = new Stack<TreeNode>();
        TreeNode curr = root;
        s1.push(curr);
        List<List<Integer>> arlist = new ArrayList<List<Integer>>();
        if(root==null)
            return arlist;
        while(!s1.isEmpty() || !s2.isEmpty())
        {
            List<Integer> li1 = new ArrayList<Integer>();
            List<Integer> li2 = new ArrayList<Integer>();
            int flag1 = 0;
            int flag2 = 0;
            while(!s1.isEmpty())
            {
                flag1=1;
                li1.add(s1.peek().val);
                if(s1.peek().left!=null)
                    s2.push(s1.peek().left);
                if(s1.peek().right!=null)
                    s2.push(s1.peek().right);
                s1.pop();
                
            }
            if(flag1==1)
            arlist.add(li1);
            while(!s2.isEmpty())
            {
                flag2=1;
                li2.add(s2.peek().val);
                if(s2.peek().right!=null)
                    s1.push(s2.peek().right);
                if(s2.peek().left!=null)
                    s1.push(s2.peek().left);
                s2.pop();
                
            }
            if(flag2==1)
            arlist.add(li2);
        }
        return arlist;
    }
}
/* Stack implementation using queue*/
class MyStack {
    Queue<Integer> qu = new LinkedList<Integer>();
    
    
    // Push element x onto stack.
    public void push(int x) {
        qu.add(x);
        for(int i=0; i<qu.size()-1; i++)
        {
            qu.add(qu.remove());
        }
        
    }

    // Removes the element on top of the stack.
    public void pop() {
        qu.remove();
    }

    // Get the top element.
    public int top() {
        return qu.peek();
    }

    // Return whether the stack is empty.
    public boolean empty() {
        return qu.isEmpty();
    }
}
/* queue implementation using stack*/
class MyQueue {
    // Push element x to the back of queue.
    Stack<Integer> s1 = new Stack<Integer>();
    Stack<Integer> s2 = new Stack<Integer>();
    public void push(int x) {
        s1.push(x);
    }

    // Removes the element from in front of queue.
    public void pop() {
        if(!s2.isEmpty()){
            s2.pop();
        return;
        }
        while(!s1.isEmpty()){
            s2.push(s1.pop());
        }
        s2.pop();
    }

    // Get the front element.
    public int peek() {
        if(!s2.isEmpty())
            return s2.peek();
        while(!s1.isEmpty())
        {
            s2.push(s1.pop());
        }
        return s2.peek();
    }

    // Return whether the queue is empty.
    public boolean empty() {
        return s1.isEmpty()&&s2.isEmpty();
    }
}
/* Reverse Polish Notation */
public class Solution {
    public int evalRPN(String[] tokens) {
        
        Stack<Integer> stack = new Stack<Integer>();
    int temp;
    for (int i = 0; i < tokens.length; i++) {
        switch (tokens[i]) {
        case "+":
            temp = stack.pop();
            stack.push(temp + stack.pop());
            break;
        case "-":
            temp = stack.pop();
            stack.push(stack.pop() - temp);
            break;
        case "*":
            temp = stack.pop();
            stack.push(stack.pop() * temp);
            break;
        case "/":
            temp = stack.pop();
            stack.push(stack.pop() / temp);
            break;
        default:
            stack.push(Integer.parseInt(tokens[i]));
        }
    }

    return stack.peek();
        
    }
}
/* Largest Rectangle in Histogram*/

public class Solution {
    public int largestRectangleArea(int[] height) {
        if(height == null || height.length==0)
            return 0;
        int len = height.length;
        Stack<Integer> s = new Stack<Integer>();
        int maxArea = 0;
        for(int i = 0; i <= len; i++){
            int h = (i == len ? 0 : height[i]);
            if(s.isEmpty() || h >= height[s.peek()]){
                s.push(i);
            }else{
                int tp = s.pop();
                maxArea = Math.max(maxArea, height[tp] * (s.isEmpty() ? i : i - 1 - s.peek()));
                i--;
            }
        }
        return maxArea;
    }
}
/* Simplify path to get the home directory*/

public class Solution {
    public String simplifyPath(String path) {
        Stack<String> st = new Stack<String>();
        String [] str = path.split("/");
        for (String s:str)
        {
            if(s==null || "".equals(s) || ".".equals(s))
                continue;
        
            if("..".equals(s))
                {
                    if(!st.isEmpty())
                        st.pop();
                }
                else
                        st.push(s);
                
        }
        if(st.isEmpty())
        {
            return "/";
        }
        StringBuilder str_build = new StringBuilder("");
        for(String newStr:st)
        {
            str_build.append("/"+newStr);
        }
        return str_build.toString();
    }
}
/*Zig ÃÂ Zag conversion of string*/
public class Solution {
    public String convert(String s, int n) {
        if (s.length()==0 || n==1)
            return s;
        StringBuilder[] sb = new StringBuilder[n];
        for(int m=0; m<sb.length;m++)
            sb[m] = new StringBuilder("");
        int j=0;
        int f=1;
        for(int i=0 ; i<s.length() ; i++)
        {
            if(f==1){
                sb[j].append(s.charAt(i));
                j++;
                if(j==n)
                {
                    j--;
                    f=0;
                }
                    
                }
            
            else
                {
                    j--;
                    sb[j].append(s.charAt(i));
                    if(j==0){
                        f=1;
                        j++;
                        
                    }
                }
            
        }
        StringBuilder result = new StringBuilder();
            for (StringBuilder sr : sb)
                result.append(sr);
    
        return result.toString();
    }
    
}
/*Reverse an integer number */
public class Solution {
    public int reverse(int x) {
        
        int f=0;
        if(x<0)
        {
            x=x* (-1);
            f=1;
        }
        if(x%10==x)
            return x;
        int y = x;
        int n; 
        long r=0;
        while(y>0)
        {
            r = r*10; 
            n=y%10;
            r=n+r;
            y=y/10;
        }
        if(r>Integer.MAX_VALUE || r<Integer.MIN_VALUE)
            return 0;
            if(f==1)
            return (int)r*(-1);
        else
            return (int)r;
    }
}
/*String to integer / atoi */
public class Solution {
    public int myAtoi(String str) {
        int index = 0, sign = 1, total = 0;
    //1. Empty string
    if(str.length() == 0) return 0;

    //2. Remove Spaces
     
    while(str.charAt(index) == ' ' && index < str.length())
        index ++;

    //3. Handle signs
    if(str.charAt(index) == '+' || str.charAt(index) == '-'){
        sign = str.charAt(index) == '+' ? 1 : -1;
        index ++;
    }

    //4. Convert number and avoid overflow
    while(index < str.length()){
        int digit = str.charAt(index) - '0';
        if(digit < 0 || digit > 9) break;

        //check if total will be overflow after 10 times and add digit
        if(Integer.MAX_VALUE/10 < total || Integer.MAX_VALUE/10 == total && Integer.MAX_VALUE %10 < digit)
            return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;

        total = 10 * total + digit;
        index ++;
    }
    return total * sign;
    }
}
/*check if integer is palindrome or not*/
public class Solution {
    public boolean isPalindrome(int x) {
         int xx = x;
        int reversed = 0;

        while(xx > 0) {
            reversed = reversed * 10 + xx % 10;
            xx /= 10;
        }
        return x == reversed;
    }
}
/*Roman to Integer*/
public class Solution {
    public int romanToInt(String s) {
          int result = 0;
        char[] sChar = s.toCharArray();
        HashMap<Character, Integer> map = new HashMap<Character, Integer>();
        map.put('I',1);
        map.put('V',5);
        map.put('X',10);
        map.put('L',50);
        map.put('C',100);
        map.put('D',500);
        map.put('M',1000);
        if(sChar.length == 1) return map.get(sChar[0]);
        for(int i = 0; i < sChar.length-1; i++){
            if( map.get(sChar[i]) >= map.get(sChar[i+1]) )
                result += map.get(sChar[i]);
            else
                result -= map.get(sChar[i]);
         }
         result += map.get(sChar[sChar.length-1]);
         return result;
    }
}

/*Roman to Integer -2*/
public class Solution {
    public int romanToInt(String s) {
       

        if(s == null || s.length() == 0) return 0;
        int len = s.length();
        HashMap<Character,Integer> map = new HashMap<Character,Integer>();
        map.put('I',1);
        map.put('V',5);
        map.put('X',10);
        map.put('L',50);
        map.put('C',100);
        map.put('D',500);
        map.put('M',1000);
        int result = map.get(s.charAt(len -1));
        int pivot = result;
        for(int i = len -2; i>= 0;i--){
            int curr = map.get(s.charAt(i));
            if(curr >=  pivot){
                result += curr;
            }else{
                result -= curr;
            }
            pivot = curr;
        }
        return result;
    }
}
/*Prefix string among all strings*/
public class Solution {
    public String longestCommonPrefix(String[] strs) {
      StringBuilder result = new StringBuilder();

        if (strs!= null && strs.length > 0){

            Arrays.sort(strs);

            char [] a = strs[0].toCharArray();
            char [] b = strs[strs.length-1].toCharArray();

            for (int i = 0; i < a.length; i ++){
                if (b.length > i && b[i] == a[i]){
                    result.append(b[i]);
                }
                else {
                    return result.toString();
                }
            
            }    
    }
        return result.toString();
    }
}
/*Remove Nth node from last in List / Linked List / LinkedList*/
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        if(head == null)
            return head ;
        ListNode result= new ListNode(0);
        result.next = head;
        
        ListNode fast = result;
        ListNode slow = result;
        for(int i=0 ; i<n ; i++)
        {
            if(fast==null)  
                return null;
            fast= fast.next;
        }
        while(fast.next!=null)
            {
                fast=fast.next;
                slow=slow.next;
            }
            slow.next = slow.next.next;
    
        return result.next;
    }
    
}
/*check for valid parenthesis */
public class Solution {
    public boolean isValid(String s) {
         if(s==null){ return true; }

    Stack<Character> s1=new Stack<Character>();
        char[] c = s.toCharArray();
        for(int i=0;i<c.length;i++){
            if(!s1.empty()){
                if((s1.peek()=='(' && c[i]==')' )||(s1.peek()=='{' && c[i]=='}' )||(s1.peek()=='[' && c[i]==']' ) )
                    s1.pop();
                else
                    s1.push(c[i]);
                    }else
                s1.push(c[i]);
        }
        return s1.empty();
        }
    }
/*Merge two sorted lists iteratively */
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1==null)
            return l2;
        if(l2==null)
            return l1;
        ListNode l3 = new ListNode(Integer.MIN_VALUE);
        ListNode result= l3;
       
        while(l1!=null && l2!=null)
        {
            if(l1.val>l2.val)
            {
                l3.next = new ListNode(l2.val);
                l2=l2.next;
                l3=l3.next;
            }
            else
            {
                l3.next = new ListNode(l1.val);
                l1 = l1.next;
                l3=l3.next;
            }
    }
    if(l1!=null)
    {
        while(l1!=null)
        {
            l3.next = new ListNode(l1.val);
            l1=l1.next;
            l3=l3.next;
        }
    }
    if(l2!=null)
    {
        while(l2!=null)
        {
            l3.next = new ListNode(l2.val);
            l2=l2.next;
            l3=l3.next;
        }
    }
    return result.next;
}
}
/*Merge two sorted lists recursively */
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if(l1==null && l2==null) return null;
        else if(l1==null) return l2;
        else if(l2==null) return l1;
        
        if(l1.val<=l2.val){
            l1.next = mergeTwoLists(l1.next,l2);
            return l1;
        }
        else{
            l2.next = mergeTwoLists(l1,l2.next);
            return l2;
        }
    
    }
    
}

/*Remove duplicates from sorted array */
public class Solution {
    public int removeDuplicates(int[] nums) {
        int j = 0;
        for (int i = 0; i < nums.length; i++) {
            if (i > 0 && nums[i - 1] == nums[i]) 
                continue;
            nums[j] = nums[i];
            j++;
        }
        return j;
    }
}
/*remove all instances of that value in place and return the new length */
public class Solution {
    public int removeElement(int[] nums, int val) {
       int low=0;
       int high = nums.length-1;
       while(low<=high)
       {
           while(high>low && nums[high]==val)
           {
               high--;
           }
            if(nums[low]==val)
           {
               nums[low] = nums[high]; // replacing low value with the last because order can be changed
               high--;
           }
           low++;
       }
       return high+1;
    }
}
/*check if suduko sudoko is valid or not */
public class Solution {
    public boolean isValidSudoku(char[][] board) {
        HashSet[] row = new HashSet[9];
        HashSet[] column = new HashSet[9];
        HashSet[] ceil = new HashSet[9];
    
    for(int i=0; i<9; i++)
    {
        row[i] = new HashSet<Character>();
        column[i] = new HashSet<Character>();
        ceil[i] = new HashSet<Character>();
    }
    
    for(int i=0 ; i<9 ; i++)
    {
        for(int j=0 ; j<9; j++)
        {
            if(board[i][j]!='.'){
                if(row[i].contains(board[i][j]) || column[j].contains(board[i][j]) || ceil[3 *(i/3)+(j/3)].contains(board[i][j]))
                {
                    return false;
                }
                else
                {
                    row[i].add(board[i][j]);
                    column[j].add(board[i][j]);
                    ceil[3*(i/3)+(j/3)].add(board[i][j]);
                }
            }
        }
    }
return true;
        
    }
}
/*count and say iterative like 1, 11, 21, 1211ÃÂ */
public class Solution {
    public String countAndSay(int n) {
        String result = "1";
        for(int i=1; i<n; i++)
        {
            StringBuilder sb= new StringBuilder();
            int  j=0;
            while(j<result.length())
            {
                char temp = result.charAt(j);
                int count=0;
                while(j<result.length()&&result.charAt(j)==temp)
                {
                    j++;
                    count++;
                }
                sb.append(count);
                sb.append(temp);
            }
            result=sb.toString();
        }
        return result;
    }
}
/*count and say recursive like 1, 11, 21, 1211ÃÂ */
	public class Solution {
    public String countAndSay(int n) {
        return helper("1", n);
    }
     public String helper(String step, int count) {
        if(count <= 1) {
            return step;
        }

        // process step
        char currentChar = step.charAt(0);
        int currentCount = 0;
        StringBuilder result = new StringBuilder();
        for(char ch : step.toCharArray()) {
            if(ch != currentChar) {
                // hitting a different sequence
                // need to add to result
                result.append(currentCount).append(currentChar);

                currentChar = ch;
                currentCount = 1;
            } else {
                currentCount++;
            }
        }

        result.append(currentCount).append(currentChar);

        return helper(result.toString(), count-1);
    }

}
/* Length of last word in string / sentence*/
public class Solution {
    public int lengthOfLastWord(String s) {
 String str = s.trim();
     if (str==null) {
        return 0;
    } 
 String[] k = str.split(" ");
 return k[k.length-1].length();    
        
    }
}
/*plus one to the digit */
public class Solution {
    public int[] plusOne(int[] digits) {
        int n = digits.length;
    for(int i=n-1; i>=0; i--) {
        if(digits[i] < 9) {
            digits[i]++;
            return digits;
        }

        digits[i] = 0;
    }

    int[] newNumber = new int [n+1];
    newNumber[0] = 1;
return newNumber;
    }
}
/*Add binary numbers / sum of binary numbers */
public class Solution {
    public String addBinary(String a, String b) {
        int na = a.length()-1;
        int nb = b.length()-1;
        int sum=0 ;
        int carry =0;
        StringBuilder sb =new StringBuilder();
        while(na>=0 || nb>=0)
        {
            int x = na>=0 ? a.charAt(na) - '0' : 0;
            int y = nb>=0 ? b.charAt(nb) - '0' : 0;
            sum=x^y^carry;
            carry = x+y+carry>1 ? 1 : 0;
            sb.insert(0, sum);
            na--;
            nb--;
        }
        if(carry==1)
            sb.insert(0, 1);
        
        return sb.toString();
        
    }
    
}
/*climbing stairs in distinct ways */
public class Solution {
    public int climbStairs(int n) {
        if(n==0 || n==1 || n==2)
            return n;
        int sum=2, prev=1, current=0;
        for(int i=2;i<n;i++)
        {
            current=sum;
            sum=sum+prev;
            prev=current;
        }
        return sum;
    }
}
/* Remove duplicates from sorted list */
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode deleteDuplicates(ListNode head) {
     if(head==null)
        return head;
     ListNode current = head;   
     ListNode comingPointer;
     while(current.next!=null)
     {
         comingPointer = current.next;
         if(current.val==comingPointer.val)
         {
          current.next = comingPointer.next;
         }
         else
         {
             current=current.next;
         }
     }
     return head;
    }
}
/* check if trees are equal*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p==null && q==null)
            return true;
        if(p==null || q==null)
            return false;
        if(p.val!=q.val)
            return false;
        return (isSameTree(p.left, q.left) && isSameTree(p.right, q.right));
    }
}
/*check if tree is symmetric or not / mirror/ mirror image of tree*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root==null)
            return true;
        return (isSymSubtree(root.left, root.right));
        }
        
        public boolean isSymSubtree(TreeNode left, TreeNode right)
        {
            if(left==null)
                return (right==null);
            if(right==null)
                return false;
            return (left.val==right.val && isSymSubtree(left.left, right.right) && isSymSubtree(left.right, right.left));
        }
}
/* Tree level order traversal iterative*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<List<Integer>>();
    if(root==null) return result;
    ArrayList<TreeNode> level = new ArrayList<TreeNode>();
    level.add(root);

    while(!level.isEmpty()){
        ArrayList<Integer> values = new ArrayList<Integer>();
        for(int i=0; i<level.size(); i++){
            values.add(level.get(i).val);
        }
        result.add(values);
        ArrayList<TreeNode> nextlevel = new ArrayList<TreeNode>();
        for(int j=0 ;j<level.size(); j++){
            if(level.get(j).left!=null) nextlevel.add(level.get(j).left);
            if(level.get(j).right!=null) nextlevel.add(level.get(j).right);
        }
        level = nextlevel;
    }
    return result;
     }
}
/* Tree level order traversal recursive*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> list = new ArrayList<List<Integer>>();
        helper(root, list, 0);
        return list;

    }
    private void helper(TreeNode root,List<List<Integer>> list, int level){
        if(root==null) return;
        if(list.size()==level) list.add(new ArrayList<Integer>());
        list.get(level).add(root.val);
        helper(root.left, list, level+1);
        helper(root.right, list, level+1);

    }
}
/* Compare version numbers*/
public class Solution {
    public int compareVersion(String version1, String version2) {
     String [] v1 = version1.split("\\.");
     String [] v2 = version2.split("\\.");
     
     for(int i=0; i<Math.max(v1.length, v2.length); i++)
     {
         int n1 = i<v1.length ? Integer.parseInt(v1[i]) : 0;
         int n2 = i<v2.length ? Integer.parseInt(v2[i]) : 0;
         
         if(n1>n2)
            return 1;
        if(n2>n1)
            return -1;
     }
     return 0;
    }
}
/*Rotate an array*/
public class Solution {
    public void rotate(int[] nums, int k) {
        if(nums == null || nums.length < 2){
        return;
    }

    k = k % nums.length;
    reverse(nums, 0, nums.length - k - 1);
    reverse(nums, nums.length - k, nums.length - 1);
    reverse(nums, 0, nums.length - 1);

    }
    private void reverse(int[] nums, int i, int j){
    int tmp = 0;       
    while(i < j){
        tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
        i++;
        j--;
    }
}
    
}
/*Excel sheet column title*/
public class Solution {
    public String convertToTitle(int n) {
        StringBuilder sb = new StringBuilder();
        while(n!=0)
        {
            sb.insert(0, (char)('A'+(n-1)%26));
            n=(n-1)/26;
        }
        return sb.toString();
    }
}
/*first bad version*/
/* The isBadVersion API is defined in the parent class VersionControl.
      boolean isBadVersion(int version); */

public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
       
  int l = 1, r = n, mid;
        while (l <= r) {
            mid = l + (r-l) / 2;
            if (isBadVersion(mid))
                r = mid - 1;
            else
                l = mid + 1;
        }
        return l;
    }
}
/*Design a stack that supports push, pop, top, and retrieving the minimum element in constant time / Min Stack*/
class MinStack {
    Stack<Integer> mainStack = new Stack<Integer>();
        Stack<Integer> minStack = new Stack<Integer>();

        public void push(int x) {
            mainStack.push(x);
            if (minStack.empty()) {
                minStack.push(x);
            } else if (minStack.peek() >= x) {
                minStack.push(x);
            }
        }

        public void pop() {
            int poppedElement = mainStack.pop();
            if (poppedElement == minStack.peek()) {
                minStack.pop();
            }
        }

        public int top() {
            return mainStack.peek();
        }

        public int getMin() {
            return minStack.peek();
        }
}
/*Summary ranges*/
public class Solution {
    public List<String> summaryRanges(int[] nums) {
        StringBuffer sb = new StringBuffer();
        List<String> res= new ArrayList<String>();
        if(nums == null || nums.length==0)
            return res;
        if(nums.length==1)
        {
            sb.append(nums[0]);
            res.add(sb.toString());
            return res;
        }
        int p=0;
        for (int i = 1; i < nums.length; i++) 
        {
            if (nums[i] == nums[i - 1] + 1) 
            {
                if (i == nums.length - 1) 
                {
                    res.add(nums[p] + "->" + nums[i]);
                }
            } 
            else 
            { 
                if (i == p + 1) 
                {
                    res.add(nums[p] + "");
                } 
                else 
                {
                    res.add(nums[p] + "->" + nums[i - 1]);
                }
                if (i == nums.length - 1) 
                {
                    res.add(nums[i] + "");
                }
                p = i;
            }
        }
        return res;
    }
}
/*All paths in binary tree / binary tree paths*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        
        List<String> list = new ArrayList<String>();
        if(root!=null)
        {
            if(root.left==null && root.right==null)
            {
                list.add(root.val+"");
            }
            else
            {
                if(root.left!=null)
                {
                    list.addAll(binaryTreePaths(root.left));
                }
                if(root.right!=null)
                {
                    list.addAll(binaryTreePaths(root.right));
                }
                for(int i=0;i<list.size();i++)
                {
                    list.set(i, root.val + "->" +list.get(i));
                }
            }
        }
        return list;
    }
}
/*Remove a given element / value from a linked list */
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */

public class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode store = new ListNode(0);
        store.next = head;
        ListNode current = store;
        while(current.next!=null)
        {
            if(current.next.val == val)
                current.next = current.next.next;
            else
                current=current.next;
        }
        return store.next;
    }
}
/* count prime numbers / prime nos exclusive the given number*/
public class Solution {
    public int countPrimes(int n) {
     
     boolean [] m = new boolean[n];
     int count=0;
     for(int i=2; i<n ; i++)
     {
         if(m[i])
            continue;
        count++;
        for(int j=i ; j<n ; j+=i)
            m[j] = true;
     }
     return count; 
    }
}
/* Nim Game*/
public class Solution {
    public boolean canWinNim(int n) {
        return ((n%4)!=0);
    }
}
/* Maximum depth of binary tree / max depth of binary tree*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null)
            return 0;
        return (Math.max(maxDepth(root.left) + 1,maxDepth(root.right)+1));
    }   
}
/*Delete node in a linkedList / linked list */
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public void deleteNode(ListNode node) {
        node.val = node.next.val;
        node.next = node.next.next;
    }
}
/*Invert Binary Tree recursion */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root==null)
            return root;
            
        TreeNode temp = root.left;
        root.left = invertTree(root.right);
        root.right = invertTree(temp);
        
        return root;
    }
}
/*Invert Binary Tree iterative */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) return root;

    Queue q = new LinkedList<TreeNode>();
    q.add(root);

    while(!q.isEmpty()){
        TreeNode node = (TreeNode)q.remove();
        TreeNode tempRight = null, tempLeft = null;
        if(node.right != null){
            q.add(node.right);
            tempRight = node.right; 
        } 
        if(node.left != null){
            q.add(node.left);
            tempLeft = node.left;
        }
        node.left = tempRight;  
        node.right = tempLeft;
    }

    return root;
    }
}
/*Excel sheet column Number*/
public class Solution {
    public int titleToNumber(String s) {
         {
        int sum = 0;
        s = s.toUpperCase();
        for (int i = 0; i < s.length(); i++)
        {
            sum = 26 * sum + (s.charAt(i) - 'A'+1);
        }
        return sum;
    }
    }
}
/* Lowest common ancestors in Binary search tree */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null || p==root || q==root)
            return root;
        if((p.val<root.val && q.val>root.val) || (p.val>root.val && q.val<root.val))
            return root;
        else if(p.val<root.val && q.val<root.val)
            return lowestCommonAncestor(root.left, p, q);
        else
            return lowestCommonAncestor(root.right, p, q);
     
            
    }
}
/* check if two strings are anagram ( less optimize)*/
public class Solution {
    public boolean isAnagram(String s, String t) {
        if(s==null || t==null)
            return true;
        if(s.length()!=t.length())
            return false;
        char [] c1 = s.toCharArray();
        Arrays.sort(c1);
        char [] c2 = t.toCharArray();
        Arrays.sort(c2);
        
        String s1 = String.valueOf(c1);
        String s2 = String.valueOf(c2);
        
        if(s1.equals(s2))
            return true;
        else
            return false;
    }
}
/* check if two strings are anagram (more optimize using map)*/
public class Solution {
    public boolean isAnagram(String s, String t) {
        if(s.length() != t.length() ){
            return false;
        }

        if(s == null && t == null){
            return false;
        }

        if(s.equals(t)){
            return true;
        }

        Map<Character, Integer> map = new HashMap<Character, Integer>();

        for(char a : s.toCharArray()){
            map.put(a, map.getOrDefault(a, 0) + 1);
        }

        for(char b : t.toCharArray()){
            if(map.containsKey(b)){
                map.put(b, map.get(b) - 1);
                if(map.get(b) == 0){
                    map.remove(b);
                }
            }else{
                map.put(b, map.getOrDefault(b, 0) + 1);
            }
        }

        if(map.isEmpty()){
            return true;
        }else{
            return false;
        }
    }
}
/*Ugly Number */
public class Solution {
    public boolean isUgly(int num) {
        if(num<=0)
            return false;
        if(num==1)
            return true;
        while(num%5==0)
            num/=5;
        while(num%3==0)
             num/=3;
        while(num%2==0)
             num/=2;
            
        return (num==1);
    }
}
/*happy number */
public class Solution {
    public boolean isHappy(int n) {
        int result = 0;
        while (n > 9) {
            result += Math.pow(n % 10, 2);
            n = n / 10;
        }
        result += Math.pow(n, 2);
        if (result > 9) {return isHappy(result);}
        if (result == 1) {
            return true;
        } else {
            return false;
        }
    }
}
/* Minimum Depth of binary tree / min depth of binary tree */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int minDepth(TreeNode root) {
        if(root==null)
            return 0;
        if(root.left==null && root.right==null)
            return 1;
        if(root.right==null)
            return 1+minDepth(root.left);
        if(root.left==null)
            return 1+minDepth(root.right);
        return (Math.min(minDepth(root.left) , minDepth(root.right)))+1 ;
    }
}
/* Intersection of 2 linked lists*/
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        
        if(headA==null || headB==null)  //boundary check
            return null;
        ListNode a = headA;
        ListNode b = headB;
        
        //if a and b have different lengths, then we will stop the loop after the second iteration
        while(a!=b) 
        {
            //for the end of first iteration, we just reset the pointer to the head of another linkedlist
            a= a==null? headB : a.next;
            b= b==null? headA : b.next;
        }
    return a;
    }
}
/* Balanced Binary Tree*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean isBalanced(TreeNode root) {
        if(root==null || (root.left==null&&root.right==null))
            return true;
        return Math.abs(height(root.left)-height(root.right))<=1 && isBalanced(root.left) && isBalanced(root.right)? true : false;
    }
    public int height(TreeNode node)
    {
        if (node==null)
            return 0;
        return 1+Math.max(height(node.left), height(node.right));
    }
}
/* check if strings are isomorphic or not */
public class Solution {
    public boolean isIsomorphic(String s, String t) {
       
       if(s.length()!=t.length())
            return false;
       
       if(s.length()==0)
            return true;
            
        Map<Character, Integer> m1 = new HashMap<Character, Integer>();
        Map<Character, Integer> m2 = new HashMap<Character, Integer>();
        
        for(int i=0; i<s.length(); i++)
        {
            if(!m1.containsKey(s.charAt(i)))
                m1.put(s.charAt(i), i);
            if(!m2.containsKey(t.charAt(i)))
                m2.put(t.charAt(i), i);
                
            if(m1.size()!=m2.size())
                return false;
            else
                if(m1.get(s.charAt(i))!=m2.get(t.charAt(i)))
                    return false;
        }
        return true;
    }
}
/*check if the number is power of two / power of 2*/
public class Solution {
    public boolean isPowerOfTwo(int n) {
        if(n==1)
            return true;
        if(n%2 != 0)
            return false;
        int sum = 1;
        for(int i=0 ; i<n/2 ; i++)
        {
            if(sum>n)
                return false;
            if(sum==n)
                return true;
            sum *= 2;
        }
        if(sum == n)
            return true;
        return false;
    }
}
/* Level order traversal of binary tree in reverse order */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> list1 = new ArrayList<List<Integer>>();
        helper(root, list1, 0);
        Collections.reverse(list1);
        return list1;
        
        //List reversal can also be done like this.
        /*
        
        List<List<Integer>> list2 = new ArrayList<List<Integer>>();
        int n= list1.size();
        for(int i=0 ; i< n ;i++)
        {
           list2.add(list1.get(n-1-i));
        }
        */
    }
        private void helper(TreeNode root,List<List<Integer>> list, int level){
        if(root==null) return;
        if(list.size()==level) list.add(new ArrayList<Integer>());
        list.get(level).add(root.val);
        helper(root.left, list, level+1);
        helper(root.right, list, level+1);

    }

}
/* house  Robber*/
public class Solution {
    public int rob(int[] num) {
       if(num.length==0)
        return 0;
        if(num.length==1)
            return num[0];
        num[1] = Math.max(num[0], num[1]);
        for(int i=2 ; i<num.length; i++)
            num[i] = Math.max(num[i]+num[i-2], num[i-1]);
        return num[num.length-1];
    }
}
/* Check if sum of node of path in binary tree equals a given number / All paths in Binary tree*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if(root==null)
            return false;
        if(root.left==null && root.right==null)
            return root.val==sum;
        int subSum = sum - root.val;
        return (hasPathSum(root.left, subSum) ||  hasPathSum(root.right, subSum));
        
    }
}
/*Trailing zeros in factorial of a number */
public class Solution {
    public int trailingZeroes(int n) {
        int count=0;
        while(n>1)
        {
            count = count+ (n/5);
            n=n/5;
        }
        return count;
    }
}
/*Rectangle Area ÃÂ two rectangles are combined to find the total area*/
public class Solution {
    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {
         int space = 0;
         int space1 = (Math.abs(A-C)*Math.abs(B-D));
         int space2 = (Math.abs(E-G)*Math.abs(F-H));
         
         int left = Math.max(A,E);
         int top = Math.min(D,H);
         int right  = Math.min(C,G);
         int bottom = Math.max(B,F);
         if(top>=bottom && right>=left){
             space = (Math.abs(bottom-top) * Math.abs(left-right));
         }
         return space1+space2-space;
    }
}
/* Reverse a linked list iterative*/
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode reverseList(ListNode head) {
         ListNode prev = null;
    while (head != null) {
        ListNode temp = head.next;
        head.next = prev;
        prev = head;
        head = temp;
    }
    return prev;
    }
}
/* Reverse a linked list iterative recursive*/
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode reverseList(ListNode head) {
       if(head == null ||head.next == null){
            return head;
        }

        ListNode root = reverseList(head.next);

        head.next.next = head;
        head.next = null;
        return root;
    }
}
/* check if linked list is palindrome or not iterative*/
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null)
            return true;
        ListNode fast = head, slow = head, prev = null;
        while (fast != null && fast.next != null) {
            prev = slow;
            slow = slow.next;
            fast = fast.next.next;
    }
        prev.next = null;
        slow = reverseList(slow);
        while (head != null && slow != null) {
            if (head.val != slow.val)
                return false;
            head = head.next;
            slow = slow.next;
    }
    return true;
}
    public ListNode reverseList(ListNode head) {
    ListNode prev = null;
    while (head != null) {
        ListNode temp = head.next;
        head.next = prev;
        prev = head;
        head = temp;
    }
    return prev;
    }
}
/* check if  linked list is palindrome or not recursive */
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    ListNode h;
    public boolean isPalindrome(ListNode head) {
        if (head == null) 
            return true;

        if (h == null) 
            h = head;

        boolean tmp = true;        
        if (head.next != null) 
            tmp &= isPalindrome(head.next);

        tmp &= (head.val == h.val);
        h = h.next;
        return tmp;
    }
}
/*Merge N sorted arrays / n-sorted array*/
public int[] mergeNArrays(int[][] arrays, int n)
{
    int result[];
    for(int i=0; i<n ; i++)
    {
       result[] = Merge(result, arrays[i]);
    }
    
    return result;
}
/*find the single number in the array with all numbers two times except one*/
public class Solution {
    public int singleNumber(int[] nums) {
        int n = 0;
        for(int i= 0 ; i<nums.length ; i++)
        {
            n = n ^ nums[i];
        }
        return n;
    }
}
/*Best time to buy and sell stocks with single transaction */
public class Solution {
    public int maxProfit(int[] prices) {
        int max = 0;
        int min = Integer.MAX_VALUE;
        for(int i =0 ; i< prices.length; i++)
        {
            min = Math.min(min, prices[i]);
            max = Math.max(max, prices[i]-min);
        }
    
        return max;
    }
}
/* Best time to buy and sell stock with multiple transactions*/
public class Solution {
    public int maxProfit(int[] prices) {
        int profit = 0;
        for(int i=1; i<prices.length; i++)
        {
            if(prices[i]-prices[i-1]<=0)
                continue;
            profit += prices[i] - prices[i-1];
        }
        return profit;
    }
}
/* find the single number in the array with all numbers three times except one */
public class Solution {
    public int singleNumber(int[] nums) {
        if(nums==null || nums.length==0)
            return 0;
        HashMap <Integer, Integer> hm = new HashMap<Integer, Integer>();
        for(int i= 0; i <nums.length ; i++)
            hm.put(nums[i], hm.getOrDefault(nums[i], 0)+1);
        for(Map.Entry<Integer, Integer> en : hm.entrySet())
        {
            if(en.getValue()!=3)
                return en.getKey();
        }
        return -1;
    }
}
/* find the single number / two numbers in the array with all numbers two times except two elements which occur one time */
public class Solution {
    public int[] singleNumber(int[] nums) {
        Set<Integer> set = new HashSet<Integer>();
    for(int i:nums){
         if(set.add(i)==false)
         set.remove(i);
    }
    int a[]= new int [set.size()];
    int c=0;
    for(int b:set){
        a[c]=b;
        c++;
    }
    return a;
        
    }
}
/*Product of array except itself */
public class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length; 
        int[] output = new int[n];
        int temp = 1;
        output[0] = 1;
        for(int i = 1; i<n ; i++)
        {
            output[i] = output[i-1] * nums[i-1];
        }
        for(int i=n-1 ; i>=0; i--)
        {
            output[i]= temp*output[i];
            temp = temp*nums[i];
            
        }
        return output;  
    }
}
/*check if linked list / linkedlist has a cycle */
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        if(head==null)
            return false;
        ListNode fast = head;
        ListNode slow = head;
        while((fast!= null && fast.next!=null))
        {
            fast = fast.next.next;
            slow= slow.next;
            if(fast==slow)
                break;
        }
        if(fast== null || fast.next==null)
            return false;
        else
            return true;
    }
}
/*find the missing value in the array of integers */
public class Solution {
    public int missingNumber(int[] nums) {
        
        int n = nums.length;
        int expectedOutput = (n*(n+1))/2;
        
        for(int i=0;i<n;i++)
        {
            expectedOutput-=nums[i];
        }
        return expectedOutput;
        
    }
}
/*Populating Next Right Pointers in each node of Binary search tree / left node should make an arrow towards right node */
/**
 * Definition for binary tree with next pointer.
 * public class TreeLinkNode {
 *     int val;
 *     TreeLinkNode left, right, next;
 *     TreeLinkNode(int x) { val = x; }
 * }
 */
public class Solution {
    public void connect(TreeLinkNode root) {
        if(root==null)
        {
            return;
        }
        if(root.left!=null)
        {
            root.left.next = root.right;
            if(root.next!=null)
                root.right.next = root.next.left;
        }
        if(root.left!=null)
            connect(root.left);
        if(root.right!=null)
            connect(root.right);
    }
} 
/* Search insert position of a target value in a sorted array, if already present, return its index */
public class Solution {
    public int searchInsert(int[] nums, int target) {
        for(int i=0; i<nums.length ; i++)
        {
            if(nums[i]>=target)
                return i;
        }
        return nums.length;
    }
}
/* Integer to roman less optimized solution iteratively without using enum*/
int [] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
        String [] str = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};
        
        StringBuilder sb = new StringBuilder();
        for(int i=0; i<values.length; i++)
        {
            while(num>=values[i])
            {
                num-= values[i];
                sb.append(str[i]);
            }
        }
        return sb.toString();
/* Integer to roman less optimized solution iteratively using enum*/
public class Solution {
    
    public enum Type{
    M(1000),CM(900),D(500),CD(400),C(100),XC(90),L(50),XL(40),X(10),IX(9),V(5),IV(4),I(1);
    private final int value;
    Type(int value) {
        this.value = value;
    }
};
    
    public String intToRoman(int num) {
      
          StringBuilder output = new StringBuilder();
    for (Type t:Type.values()) {
        while (num>=t.value) {
            output.append(t);
            num -= t.value;
        }
    }
    return output.toString();
    }
    
}
/* Integer to roman more optimized solution recursively */
public class Solution {
    public String intToRoman(int num) {
       if (num>=1000) {
            return ("M"+intToRoman(num-1000));
        } else if (num>=900) {
            return ("CM"+intToRoman(num-900));
        } else if (num>=500) {
            return ("D"+intToRoman(num-500));
        } else if (num>=400) {
            return ("CD"+intToRoman(num-400));
        } else if (num>=100) {
            return ("C"+intToRoman(num-100));
        } else if (num>=90) {
            return ("XC"+intToRoman(num-90));
        } else if (num>=50) {
            return ("L"+intToRoman(num-50));
        } else if (num>=40) {
            return ("XL"+intToRoman(num-40));
        } else if (num>=10) {
            return ("X"+intToRoman(num-10));
        } else if (num>=9) {
            return ("IX"+intToRoman(num-9));
        } else if (num>=5) {
            return ("V"+intToRoman(num-5));
        } else if (num>=4) {
            return ("IV"+intToRoman(num-4));
        } else if (num>=1) {
            return ("I"+intToRoman(num-1));
        }
        return ("");
    }
}
/* Maximum subarray / Maximum sub array/ Maximum sub-array/ sum of sub array which has maximum sum*/
public class Solution {
    public int maxSubArray(int[] nums) {
        int max = nums[0];
        int [] arr = new int[nums.length];
        arr[0] = nums[0];
        for(int i=1 ; i<nums.length; i++)
        {
            arr[i] = Math.max(nums[i], nums[i]+arr[i-1]);
            max= Math.max(max, arr[i]);
        }
        return max;
    }
}
/*Convert a sorted array to binary search tree / convert a sorted array to BST recursive*
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        if(nums == null || nums.length==0)
            return null;
            
        return getTreeNode(nums, 0 , nums.length-1);
    }
    private TreeNode getTreeNode(int [] nums, int start, int end )
    {
        if(start>end)
            return null;
        int middle = start + (end-start)/2 ;
        TreeNode n = new TreeNode(nums[middle]);
        n.left = getTreeNode(nums, start, middle-1);
        n.right = getTreeNode(nums, middle+1, end);
    
        return n;
    }
}
/* Convert a sorted array to binary search tree / convert a sorted array to BST iterative */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        int len = nums.length;
        if ( len == 0 ) { return null; }

        // 0 as a placeholder
        TreeNode head = new TreeNode(0); 

        Deque<TreeNode> nodeStack       = new LinkedList<TreeNode>() {{ push(head);  }};
        Deque<Integer>  leftIndexStack  = new LinkedList<Integer>()  {{ push(0);     }};
        Deque<Integer>  rightIndexStack = new LinkedList<Integer>()  {{ push(len-1); }};

        while ( !nodeStack.isEmpty() ) {
            TreeNode currNode = nodeStack.pop();
            int left  = leftIndexStack.pop();
            int right = rightIndexStack.pop();
            int mid   = left + (right-left)/2; // avoid overflow
            currNode.val = nums[mid];
            if ( left <= mid-1 ) {
                currNode.left = new TreeNode(0);  
                nodeStack.push(currNode.left);
                leftIndexStack.push(left);
                rightIndexStack.push(mid-1);
            }
            if ( mid+1 <= right ) {
                currNode.right = new TreeNode(0);
                nodeStack.push(currNode.right);
                leftIndexStack.push(mid+1);
                rightIndexStack.push(right);
            }
        }
        return head;    
    }
}
/* Find minimum in a rotated sorted array */
public class Solution {
    public int findMin(int[] nums) {
         int l = 0, r = nums.length-1;
     while (l < r) {
         int mid = (l + r) / 2;
         if (nums[mid] < nums[r]) {
            //right side in order, and mid is smallest of right side,
            // min should be mid or in left.
             r = mid;   
         } else {
            //left side in order and it is the larger part,
            // min should be in right side.
             l = mid + 1; 
         }
     }
     return nums[l];
    }
}
/* Generate Parenthesis / generate all combination of parenthesis*/
public class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> li = new ArrayList<String>();
        if(n<0)
            return li;
        generate("", li, n, n);
        return li;
    }
    public void generate(String s, List<String> list, int left, int right)
    {
        if(left>right)
            return;
        if(left>0)
            generate(s+"(", list, left-1, right);
        if(right>0)
            generate(s+")", list, left , right-1);
        if(left==0&&right==0)
        {
            list.add(s);
            return;
        }
    }
}
/* sort colors / dutch flag problem / sort 0 1 2*/
public class Solution {
    public void sortColors(int[] nums) {
        int r = 0;
        int w = 0 ;
        int b = 0;
        for(int i : nums){
            if(i==0)
                r++;
            if(i==1)
                w++;
            if(i==2)
                b++;
        }
        int i=0;
        while(r>0)
        {
            nums[i++] = 0;
                r--;
        }
        while(w>0)
        {
            nums[i++] = 1;
                w--;
        }
        while(b>0)
        {
            nums[i++] = 2;
                b--;
        }
    }
}
/* Swap nodes in pairs in linked list.*/
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
public class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head==null || head.next==null)
            return head;
        ListNode current = head;
        ListNode next;
        ListNode result = new ListNode(-1);
        ListNode prev = result;
        while(current!=null && current.next!=null)
        {
            next = current.next;
            prev.next = next;
            current.next = next.next;
            next.next = current;
            prev = current;
            current = current.next;
        }
        return result.next;
    }
}
/* Find permutations of collection of numbers [Iterative]*/
public class Solution {
public List<List<Integer>> permute(int[] num) {
    LinkedList<List<Integer>> res = new LinkedList<List<Integer>>();
    res.add(new ArrayList<Integer>());
    for (int n : num) {
        int size = res.size();
        for (; size > 0; size--) {
            List<Integer> r = res.pollFirst();
            for (int i = 0; i <= r.size(); i++) {
                List<Integer> t = new ArrayList<Integer>(r);
                t.add(i, n);
                res.add(t);
            }
        }
    }
    return res;
}
}
/* Find permutations of collection of numbers [first solution]*/
public class Solution {
    public List<List<Integer>> permute(int[] nums) {
         List<List<Integer>> result = new ArrayList<List<Integer>>();
        permute(result, nums, 0);
        return result;
    }
     private void permute(List<List<Integer>> result, int[] array, int start) {
        if (start >= array.length) {
            List<Integer> current = new ArrayList<Integer>();
            for (int a : array) {
                current.add(a);
            }
            result.add(current);
        } else {
            for (int i=start; i<array.length; i++) {
                swap(array, start, i);
                permute(result, array, start+1);
                swap(array, start, i);
            }
        }
    }
     private void swap(int[] array, int i, int j) {
        int temp = array[i];
        array[i] = array[j];
        array[j] = temp;
    }
}
/* Find permutations of collection of numbers [second solution]*/
public class Solution {
    public List<List<Integer>> permute(int[] nums) {
        
        List<List<Integer>> permutations = new ArrayList<>();
        if(nums.length==0)
            return permutations;
        
        generate(nums, 0 , new ArrayList<>(), permutations);
        return permutations;
        
    }
        public void generate(int[] nums, int start, List<Integer> permutation, List<List<Integer>> permutations)
        {
            if(permutation.size()==nums.length){
                permutations.add(permutation);
                return;
            }
            for(int i=0 ;i<=permutation.size();i++)
            {
                List<Integer> newPermutation = new ArrayList<>(permutation);
                newPermutation.add(i, nums[start]);
                generate(nums, start+1, newPermutation, permutations);
            }
        }
}
/* Kth smallest element in BST recursive*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    
    public int kthSmallest(TreeNode root, int k) {
      ArrayList<Integer>buffer = new ArrayList<Integer>();
      inOrderSearch(root, buffer, k);
      return buffer.get(k-1);
    }
    public void inOrderSearch(TreeNode node, ArrayList<Integer> buffer, int k)
    {
        if(buffer.size()>k)
            return;
        if(node.left!=null)
        {
            inOrderSearch(node.left, buffer, k);
        }
        buffer.add(node.val);
        if(node.right!=null)
        {
            inOrderSearch(node.right, buffer, k);
        }
    }
}
/* Kth smallest element in BST iterative*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    
    public int kthSmallest(TreeNode root, int k) {
      Stack<TreeNode> stack=new Stack<TreeNode>();
        int c=0;
        TreeNode cur=root;
        while(cur!=null){
            stack.push(cur);
            cur=cur.left;
        }
        while(!stack.isEmpty()){
            TreeNode ptr=stack.pop();
            c++;
            if(c==k)return ptr.val;
            TreeNode rt=ptr.right;
            while(rt!=null){
                stack.push(rt);
                rt=rt.left;
            }
        }
        return 0;
    }
}
/* zig-zag / zig zag traversal of BST using recursion*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
       List<List<Integer>> res = new ArrayList<List<Integer>>();
        dfs(res, root, 0);
        return res; 
       }
        private void dfs(List<List<Integer>> res, TreeNode root, int level){
        if (root == null) return;
        if (level >= res.size()){
            res.add(new LinkedList<Integer>());
        }
        LinkedList<Integer> list = (LinkedList<Integer>) res.get(level);
        if (level % 2 == 0){
            list.add(root.val);
        } else {
            list.addFirst(root.val);
        }
        dfs(res, root.left, level + 1);
        dfs(res, root.right, level + 1);
    }
}
/* Sum of root to leaf numbers in a binary search tree*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int sumNumbers(TreeNode root) {
        if(root==null)
            return 0;
        if(root.left==null && root.right==null)
            return root.val;
        List<Integer> li = new ArrayList<Integer>();
        StringBuilder sb = new StringBuilder();
        binaryTree(root, sb, li);
        int sum=0;
        for(int i: li)
            sum=sum+i;
        return sum;
    }
    public void binaryTree(TreeNode root, StringBuilder sb, List<Integer> li)
    {
        if(root==null)
            return;
        StringBuilder result = new StringBuilder(sb);
        result.append(root.val);
        if(root.left==null && root.right==null)
        {
            li.add(Integer.parseInt(result.toString()));
        }
        binaryTree(root.left, result , li);
        binaryTree(root.right, result , li);
    }
}
/* Construct binary tree from inorder and postorder traversal */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
     if(inorder.length==0)
        return null;
     
     int head = postorder[postorder.length-1];
     TreeNode root = new TreeNode(head);
     int i = findIndex(inorder, head);
     int[] inleft = Arrays.copyOfRange(inorder, 0, i);
     int[] postleft = Arrays.copyOfRange(postorder, 0, i);
     int[] inright = Arrays.copyOfRange(inorder, i+1, inorder.length);
     int[] postright = Arrays.copyOfRange(postorder, i, inorder.length-1);
     
     root.left = buildTree(inleft, postleft);
     root.right = buildTree(inright, postright);
    return root;
        
    }
    public static int findIndex(int[] a, int d)
    {
        for(int i= 0 ; i<a.length; i++)
        {
            if(a[i]==d)
                return i;
        }
        return -1;
    }
}
/*Construct binary tree from preorder and inorder traversal */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
         if(inorder.length==0)
        return null;
     
     int head = preorder[0];
     TreeNode root = new TreeNode(head);
     int i = findIndex(inorder, head);
     int[] inleft = Arrays.copyOfRange(inorder, 0, i);
     int[] inright = Arrays.copyOfRange(inorder, i+1, inorder.length);
     
     int[] preleft = Arrays.copyOfRange(preorder, 1, i+1);
     int[] preright = Arrays.copyOfRange(preorder, i+1, inorder.length);
     
     root.left = buildTree(preleft, inleft);
     root.right = buildTree(preright, inright);
    return root;
        
    }
    public static int findIndex(int[] a, int d)
    {
        for(int i= 0 ; i<a.length; i++)
        {
            if(a[i]==d)
                return i;
        }
        return -1;
    }
}
/*count number of nodes in a complete binary tree (Time limit exceeded) / not a good solution*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int countNodes(TreeNode root) {
        if(root==null)
            return 0;
        return 1+countNodes(root.left) + countNodes(root.right);
    }
}
/* count the number of nodes in a complete binary tree / optimal solution */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public int countNodes(TreeNode root) {
        if(root==null)
            return 0;
        int leftDepth = getDepth(root,'l');
        int rightDepth = getDepth(root,'r');
        
        if(leftDepth==rightDepth)
            return (1<<leftDepth)-1;
        else
            return 1+countNodes(root.left)+countNodes(root.right);
    }
    public int getDepth(TreeNode node, char d)
    {
        int depth =0;
        while(node!=null)
        {
            if(d == 'l')
                 node=node.left;
            else
                node=node.right;
            depth++;
            
        }
        return depth;
    }
}
/* Check if the given tree is a binary search tree / Validate Binary search Tree / Validate BST (Bad solution) / (Wrong solution)*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean isValidBST(TreeNode root) {
        if(root==null)
            return true;
          return isValidateBST(root.left)&&isValidateBST(root.right); 
    }
}
/* Check if the given tree is a binary search tree / Validate Binary search Tree / Validate BST (correct solution) / (perfect solution) */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public boolean isValidBST(TreeNode root) {
        if(root==null)
            return true;
            
        return checkBST(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }

    public boolean checkBST(TreeNode root, long min, long max)
    {
        if(root==null)
            return true;
        if(root.val<=min || root.val>=max)
            return false;
        return checkBST(root.left, min, root.val)&&checkBST(root.right, root.val, max);
    }
}
/* Right side view of the tree iterative*/
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> result = new LinkedList<Integer>();
        if(root==null)
            return result;
        List<TreeNode> candidate = new LinkedList<TreeNode>();
        candidate.add(root);
        while(!candidate.isEmpty())
        {
            List<TreeNode> temp = new LinkedList<TreeNode>();
            result.add(candidate.get(0).val);
            for(TreeNode n : candidate)
            {
                if(n.right!=null)
                    temp.add(n.right);
                if(n.left!=null)
                    temp.add(n.left);
            }
            candidate = temp;
        }
        return result;
    }
}
/* Right side view of the tree recursive */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        ArrayList list = new ArrayList();
        rightSideView(root, 0, list);

        return list;
    }
    public void rightSideView(TreeNode root, int level, ArrayList list) {
        if(root == null) return;

        if(list.size() == level)
            list.add(root.val);

        rightSideView(root.right, level + 1, list);
        rightSideView(root.left, level + 1, list);
    }
}
/* Lowest common ancestor in a binary tree */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null || root == p || root==q)
            return root;
        TreeNode left = lowestCommonAncestor(root.left, p , q);
        TreeNode right = lowestCommonAncestor(root.right, p , q);
        
        if(left!=null && right!=null)
            return root;
        
        return left!=null ? left : right;
    }
}

/*Closest Binary Search Tree/BST value*/
public class Solution{
	public int closestValue(TreeNode root, double target){
		int a = root.val;
		TreeNode kid = target < a ? root.left : root.right;
		if(kid==null) return a;
		int b = closestValue(kid,target);
		return Math.abs(a-target) < Math.abs(b-target) ? a:b;
	}
}

/*Cows and Bulls problem
The idea is to iterate over the numbers in secret and in guess and count all bulls right away. For cows maintain an array that stores count of the number appearances in secret and in guess. Increment cows when either number from secret was already seen in guest or vice versa.
*/
public class Solution {
    public String getHint(String secret, String guess) {
        int bulls = 0;
    int cows = 0;
    int[] numbers = new int[10];
    for (int i = 0; i<secret.length(); i++) {
        int s = Character.getNumericValue(secret.charAt(i));
        int g = Character.getNumericValue(guess.charAt(i));
        if (s == g) bulls++;
        else {
            if (numbers[s] < 0) cows++;
            if (numbers[g] > 0) cows++;
            numbers[s] ++;
            numbers[g] --;
        }
    }
    return bulls + "A" + cows + "B";
    }
}
/* Integer to English words / numbers to words*/
public class Solution {
    public String numberToWords(int num) {
         if (num == 0) return "Zero";
    String[] big= {"", "Thousand", "Million", "Billion"};
    String[] small = {"Ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"};
    String[] tens = {"Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"};
    String[] ones = {"", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"};
    StringBuilder res = new StringBuilder();
    int count = 0;
    while (num != 0) {
        int cur = num % 1000;
        int o = cur % 10, t = (cur / 10) % 10, h = cur / 100;
        StringBuilder tmp = new StringBuilder();
        if (h != 0) tmp.append(ones[h] + " Hundred ");
        if (t == 1) tmp.append(small[o] + " ");
        else {
            if (t > 1) tmp.append(tens[t-2] + " ");
            if (o > 0) tmp.append(ones[o] + " ");
        }
        if(tmp.length() != 0) tmp.append(big[count] + " ");
        res.insert(0, tmp);
        num /= 1000;
        count++;
    }
    return res.toString().trim();
    }
}
/*N-queen Problem */
public class Solution {
    public List<List<String>> solveNQueens(int n) {
        List<List<String>> ans = new ArrayList<>();
    char[][] board = new char[n][n];
    for (int i = 0; i < n; i++)
        Arrays.fill(board[i], '.');
    solve(board, n, 0, ans);
    return ans;
    }
    private void solve(char[][] board, int n, int row, List<List<String>> ans) {
    if (row == n) {
        List<String> li = new ArrayList<String>();
        for (char[] rowChars : board) {
            li.add(new String(rowChars));
        }
        ans.add(li);
        return;
    }
    for (int col = 0; col < n; col++) {
        if (board[row][col] == '.' && isValid(board, n, row, col)) {
            board[row][col] = 'Q';
            solve(board, n,  row + 1, ans);
            board[row][col] = '.';

        }
    }
}
private boolean isValid(char[][] board, int n, int i, int j) {
    for (int row = 0; row < n; row++)
        if (board[row][j] == 'Q')
            return false;
    for (int col = 0; col < n; col++)
        if (board[i][col] == 'Q')
            return false;

    // check diagonal.
    int row = i, col = j;
    while (row >= 0 && col >= 0) {
        if (board[row--][col--] == 'Q')
            return false;
    }
    row = i;
    col = j;
    while (row < n && col < n) {
        if (board[row++][col++] == 'Q')
            return false;
    }

    // check other diagonal.
    row = i;
    col = j;
    while (row >= 0 && col < n) {
        if (board[row--][col++] == 'Q')
            return false;
    }
    row = i;
    col = j;
    while (row < n && col >= 0) {
        if (board[row++][col--] == 'Q')
            return false;
    }

    return true;
}
}
/*Number of solution possible in N-Queen Problem using DFS*/
public class Solution {
    HashSet<Integer> cols = new HashSet<Integer>();  // Used columns
HashSet<Integer> diag1 = new HashSet<Integer>(); // 45Â° diagonal
HashSet<Integer> diag2 = new HashSet<Integer>(); // 135Â° diagonal 
    public int totalNQueens(int n) {
         return DFS(0, 0, n);
    }
    int DFS(int row, int count, int n) {
    if (row == n) 
        return count + 1;

    for (int col = 0; col < n; col++) {
        if (cols.contains(col) || diag1.contains(row - col) || diag2.contains(row + col)) 
            continue;
        cols.add(col);
        diag1.add(row - col); 
        diag2.add(row + col);
        count = DFS(row + 1, count, n);
        cols.remove(col); 
        diag1.remove(row - col); 
        diag2.remove(row + col);
    }
    return count;
}
}
/* Kth largest element in an unsorted array O(N LogN)*/
public class Solution {
    public int findKthLargest(int[] nums, int k) {
        Arrays.sort(nums);
        return nums[nums.length-k];
    }
}
/* Kth largest element in an unsorted array O(N LogK) (Min Heap)*/
public class Solution {
    public int findKthLargest(int[] nums, int k) {
        PriorityQueue<Integer> largeK = new PriorityQueue<Integer>(k + 1);

                for(int el : nums) {
                    largeK.add(el);
                    if (largeK.size() > k) {
                        largeK.poll();
                    }
                }

                return largeK.poll();
    }
}
/* Kth largest element in an unsorted array O(N) (Quick SORT)
It is a bit like quick sort.
First we randomly select a pivot, do as what quick sort does to get the index of the pivot.
If index == k - 1, which means we've got the kth element;
If index < k - 1, the kth element is to the right of the index, we need to search from index to right.
If index > k - 1, the kth element is to the left of the index, we need to search from left to index.
*/
public class Solution {
    public int findKthLargest(int[] nums, int k) {
       return quickSelect(nums, k - 1, 0, nums.length - 1);
       
    }
    private int quickSelect(int[] arr, int k, int left, int right){
    int pivot = arr[(left + right) / 2];
    int orgL = left, orgR = right;
    while(left <= right){
        while(arr[left] > pivot){
            left ++;
        }
        while(arr[right] < pivot){
            right --;
        }

        if(left <= right){
            swap(arr, left, right);
            left ++;
            right --;
        }
    }

    if(orgL < right && k <= right) return quickSelect(arr, k, orgL, right);
    if(left < orgR && k >= left) return quickSelect(arr, k, left, orgR);
    return arr[k];

}

private void swap(int[] arr, int idx1, int idx2){
    int tmp = arr[idx1] + arr[idx2];
    arr[idx1] = tmp - arr[idx1];
    arr[idx2] = tmp - arr[idx2];

}
}
/* Multiply two strings / multiply 2 strings*/
public class Solution {
    public String multiply(String num1, String num2) {
       int n1 = num1.length(), n2 = num2.length();
        int[] products = new int[n1 + n2];
        for (int i = n1 - 1; i >= 0; i--) {
            for (int j = n2 - 1; j >= 0; j--) {
                int d1 = num1.charAt(i) - '0';
                int d2 = num2.charAt(j) - '0';
                products[i + j + 1] += d1 * d2;
            }
        }
        int carry = 0;
        for (int i = products.length - 1; i >= 0; i--) {
            int tmp = (products[i] + carry) % 10;
            carry = (products[i] + carry) / 10;
            products[i] = tmp;
        }
        StringBuilder sb = new StringBuilder();
        for (int num : products) sb.append(num);
        while (sb.length() != 0 && sb.charAt(0) == '0') sb.deleteCharAt(0);
        return sb.length() == 0 ? "0" : sb.toString();
        
    }
}
/* Longest Palindromic Substring / Longest palindrome in a string*/
public class Solution {
    public String longestPalindrome(String s) {
         String res = "";
        int currLength = 0;
        for(int i=0;i<s.length();i++){
            if(isPalindrome(s,i-currLength-1,i)){
                res = s.substring(i-currLength-1,i+1);
                currLength = currLength+2;
            }
            else if(isPalindrome(s,i-currLength,i)){
                res = s.substring(i-currLength,i+1);
                currLength = currLength+1;
            }
        }
        return res;
    }
      public boolean isPalindrome(String s, int begin, int end){
        if(begin<0) return false;
        while(begin<end){
            if(s.charAt(begin++)!=s.charAt(end--)) return false;
        }
        return true;
    }
}
/*Perfect Squares / find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...) which sum to n*/
/*Time Complexity: n * sqrt(n) */
/*Space Complexity: n  */
public class Solution {
    public int numSquares(int n) {
        int dp[] = new int[n+1];
        int nearest;
        for(int i=1 ;i <=n ; i++)
        {
            nearest = (int)Math.sqrt(i);
            int min = dp[i-1];
            for(int j=nearest ; j>0 ; j--)
            {
                if(dp[i-j*j]<min)
                min = dp[i-j*j];
            }
            dp[i] = min+1;
        }
        return dp[n];
    }
}
/* Shortest palindrome / Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation ITERATIVE*/
public class Solution {
    public String shortestPalindrome(String s) {
        int n = s.length();
    if(n<=1){
        return s;
    }
    int idx = 0;
    for(int center = n/2; center>=0; center--){
        if(valid(s, center, 1)){   //is the longest valid palindrome? (assume length is even)
            idx = 2*center+1;
            break;
        }
        if(valid(s, center, 0)){  //assume length is odd
            idx = 2*center;
            break;
        }

    }
    String suffix = s.substring(idx+1);
    StringBuilder b = new StringBuilder(suffix);
    return b.reverse().toString()+s;
    }
    
    boolean valid(String s, int center, int shift){
    int i = center, j = center+shift;
    while(i>=0 && j<s.length()){
        if(s.charAt(i)!=s.charAt(j)){
            break;
        }
        i--;
        j++;
    }
    return i<0;
}
    
}
/* /* Shortest palindrome / Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation RECURSIVE 


The idea is to use two anchors j and i to compare the String from beginning and end. If jcan reach the end, the String itself is Palindrome. Otherwise, we divide the String by j, and getmid = s.substring(0, j) and suffix.
We reverse suffix as beginning of result and recursively call shortestPalindrome to get result of mid then appedn suffix to get result

*/
public class Solution {
    public String shortestPalindrome(String s) {
       int j = 0;
    for (int i = s.length() - 1; i >= 0; i--) {
        if (s.charAt(i) == s.charAt(j)) { j += 1; }
    }
    if (j == s.length()) { return s; }
    String suffix = s.substring(j);
    return new StringBuffer(suffix).reverse().toString() + shortestPalindrome(s.substring(0, j)) + suffix;
}
    
}
/* Largest Number / Given a list of non negative integers, arrange them such that they form the largest number / For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330 */
public class Solution {
    public String largestNumber(int[] nums) {
          if(nums.length==0)
                return new String();
                
            //Convert to string array.
            List<String> t = new ArrayList<String>();
            int count = 0;
            for(int i=0; i<nums.length;i++){
                if(nums[i]==0)
                    count++;
                t.add(Integer.toString(nums[i]));
            }
            if(count==nums.length)
                return Integer.toString(0);

             //sort based on the criterion whichever generates a bigger number in descending order.
            Collections.sort(t, new Comparator<String>(){
                @Override
                public int compare(String s1, String s2){
                    String front = s1+s2;
                    String end = s2+s1;
                    return front.compareTo(end)*(-1);

                }
            });

            //output the result.
            StringBuilder sb = new StringBuilder();
            for(String s : t)
                sb.append(s);
            return sb.toString();

    }
}
/*Combination Sum	/ Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. 
The same repeated number may be chosen from C unlimited number of times. RECURSIVE
 */
public class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        
        return combinationSum(candidates, target, 0);   
    }
     public List<List<Integer>> combinationSum(int[] candidates, int target, int start) {

        List<List<Integer>> res = new ArrayList<List<Integer>>();
        Arrays.sort(candidates);
        for (int i = start; i < candidates.length; i++) {
            if (candidates[i] <target) {
                for (List<Integer> ar : combinationSum(candidates, target - candidates[i], i)) {
                    ar.add(0, candidates[i]);
                    res.add(ar);
                }
            } else if (candidates[i] == target) {
                List<Integer> lst = new ArrayList<>();
                lst.add(candidates[i]);
                res.add(lst);
            } else
                break;
        }
        return res;
    }
}
/* Combination Sum	/ Given a set of candidate numbers (C) and a target number (T), find all unique combinations in C where the candidate numbers sums to T.  The same repeated number may be chosen from C unlimited number of times. ITERATIVE (DP)
*/
public class Solution {
    public List<List<Integer>> combinationSum(int[] cands, int t) {
        Arrays.sort(cands); // sort candidates to try them in asc order
        List<List<List<Integer>>> dp = new ArrayList<>();
        for (int i = 1; i <= t; i++) { // run through all targets from 1 to t
            List<List<Integer>> newList = new ArrayList(); // combs for curr i
            // run through all candidates <= i
            for (int j = 0; j < cands.length && cands[j] <= i; j++) {
                // special case when curr target is equal to curr candidate
                if (i == cands[j]) newList.add(Arrays.asList(cands[j]));
                // if current candidate is less than the target use prev results
                else for (List<Integer> l : dp.get(i-cands[j]-1)) {
                    if (cands[j] <= l.get(0)) {
                        List cl = new ArrayList<>();
                        cl.add(cands[j]); cl.addAll(l);
                        newList.add(cl);
                    }
                }
            }
            dp.add(newList);
        }
        return dp.get(t-1);
    }
}
/*Palindrome Partitioning / Palindrome partitioning / Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.
 */
public class Solution 
{
    public List<List<String>> partition(String s) 
    {
        List<List<String>> res=new ArrayList<List<String>>();
        if(s.length()==0)return res;
        recur(res,new ArrayList<String>(),s);
        return res;   
    }
     public void recur(List<List<String>> res,List<String> temp, String s)
     {
        if(s.length()==0)
        {
            res.add(new ArrayList<String>(temp));
            return;
        }
        for(int i=0;i<s.length();i++)
        {
            if(isPalin(s.substring(0,i+1))){
                temp.add(s.substring(0,i+1));
                recur(res,temp,s.substring(i+1));
                temp.remove(temp.size()-1);
            }
        }
    }
    public boolean isPalin(String s)
    {
        for(int i=0;i<s.length()/2;i++)
        {
            if(s.charAt(i)!=s.charAt(s.length()-1-i))return false;
        }
        return true;
    }
}
/* Pow(x. m) / Calculate power function*/
public class Solution {
    public double myPow(double x, int m) {
        double temp=x;
            if(m==0)
            return 1;
            temp=myPow(x,m/2);
            if(m%2==0)
            return temp*temp;
            else 
            {
            if(m > 0)
                return x*temp*temp;
            else
                return (temp*temp)/x;
            }
    }
}

/*Minimum Sliding Window*/
public class Solution {
    public String minWindow(String s, String t) {
        if(s == null || s.length() < t.length() || s.length() == 0){
        return "";
    }
    HashMap<Character,Integer> map = new HashMap<Character,Integer>();
    for(char c : t.toCharArray()){
        if(map.containsKey(c)){
            map.put(c,map.get(c)+1);
        }else{
            map.put(c,1);
        }
    }
    int left = 0;
    int minLeft = 0;
    int minLen = s.length()+1;
    int count = 0;
    for(int right = 0; right < s.length(); right++){
        if(map.containsKey(s.charAt(right))){
            map.put(s.charAt(right),map.get(s.charAt(right))-1);
            if(map.get(s.charAt(right)) >= 0){
                count ++;
            }
            while(count == t.length()){
                if(right-left+1 < minLen){
                    minLeft = left;
                    minLen = right-left+1;
                }
                if(map.containsKey(s.charAt(left))){
                    map.put(s.charAt(left),map.get(s.charAt(left))+1);
                    if(map.get(s.charAt(left)) > 0){
                        count --;
                    }
                }
                left ++ ;
            }
        }
    }
    if(minLen>s.length())  
    {  
        return "";  
    }  

    return s.substring(minLeft,minLeft+minLen);   
    }
}
/* Scramble String / String to tree and back to string*/
public class Solution {
    public boolean isScramble(String s1, String s2) {
         if (s1.equals(s2)) return true; 

        int[] letters = new int[26];
        for (int i=0; i<s1.length(); i++) {
            letters[s1.charAt(i)-'a']++;
            letters[s2.charAt(i)-'a']--;
        }
        for (int i=0; i<26; i++) if (letters[i]!=0) return false;

        for (int i=1; i<s1.length(); i++) {
            if (isScramble(s1.substring(0,i), s2.substring(0,i)) && isScramble(s1.substring(i), s2.substring(i))) 
                return true;
            if (isScramble(s1.substring(0,i), s2.substring(s2.length()-i)) && isScramble(s1.substring(i), s2.substring(0,s2.length()-i))) return true;
        }
        return false;
    }
}
/* Find the minimum set of ranges for a target range
This should run in O(nlogn) time. The bottleneck is in sorting the array. The rest of the algorithm runs in O(n) */*/
List<Interval> smallestSetOfRanges(List<Interval> ranges, Interval R) {
	List<Interval> result;
	int target, i, maxTarget, maxIndex;
	boolean match=false;

	if (R.first == R.second) {
		for (i = 0; i < ranges.size(); i++) {
			if (ranges.get(i).first <= R.first && ranges.get(i).second >= R.second) {
				result.add(ranges.get(i);
				break;
			}
		}
		return result;
	}

	Collections.sort(ranges, new Comparator<Interval>(){
		@Override
		public int compare(Interval i1, Interval i2){
			return Integer.compare(i1.first,i2.first);
		}
	});

	target = R.first;
	maxIndex = 0;
	while (target < R.second) {
		match = false;
		maxTarget = target;
		for (i = maxIndex; i < ranges.size(); i++) {
			if (ranges.get(i).first <= target && ranges.get(i).second >= maxTarget) {
				match = true;
				maxTarget = ranges.get(i).second;
				maxIndex = i;
			} else if (ranges.get(i).first > target) {
				break;
			}
		}
		if (match == false) {
			result.clear();
			break;
		}
		result.add(ranges.get(maxIndex);
		target = maxTarget;
		maxIndex++;
	}

	return result;
}
/* Find the minimum set of ranges for a target range
This should run in O(nlogn) time. The bottleneck is in sorting the array. The rest of the algorithm runs in O(n) */
import java.util.*;

class SmallestRangingSet {
    static class Interval implements Comparable<Interval>{
        Integer min;
        Integer max;
        public Interval(int min, int max) {
            this.min = min;
            this.max = max;
        }

        boolean intersects(int num) {
            return (min <= num && max >= num);
        }

        //Overrides the compareTo method so it will be sorted
        //in order relative to the min value
        @Override
        public int compareTo(Interval obj) {
            if (min > obj.min) return 1;
            else if (min < obj.min) return -1;
            else return 0;
        }
    }

    public static Set<Interval> smallestIntervalSet(Interval[] set, Interval target) {
        //Bottle neck is here. The array is sorted, giving this algorithm O(nlogn) time
        Arrays.sort(set);

        //Create a set to store our ranges in
        Set<Interval> smallSet = new HashSet<Interval>();
        //Create a variable to keep track of the most optimal range, relative
        //to the range before it, at all times.
        Interval bestOfCurr = null;
        //Keep track of the specific number that any given range will need to
        //intersect with. Initialize it to the target-min-value.
        int currBestNum = target.min;
        //Go through each element in our sorted array.
        for (int i = 0; i < set.length; i++) {
            Interval currInterval = set[i];
            //If we have already passed our target max, break.
            if (currBestNum >= target.max)
                break;
            //Otherwise, if the current interval intersects with
            //our currBestNum
            if (currInterval.intersects(currBestNum)) {
                //If the current interval, which intersects currBestNum
                //has a greater max, then our current bestOfCurr
                //Update bestOfCurr to be equal to currInterval.
                if (bestOfCurr == null || currInterval.max >= bestOfCurr.max) {
                    bestOfCurr = currInterval;
                }
            }
            //If our range does not intersect, we can assume that the most recently
            //updated bestOfCurr is probably the most optimal new range to add to 
            //our set. However, if bestOfCurr is null, it means it was never updated,
            //because there is a gap somewhere when trying to fill our target range.
            //So we must check for null first.
            else if (bestOfCurr != null) {
                //If it's not null, add bestOfCurr to our set
                smallSet.add(bestOfCurr);
                //Update currBestNum to look for intervals that
                //intersect with bestOfCurr.max
                currBestNum = bestOfCurr.max;
                //This line is here because without it, it actually skips over
                //the next Interval, which is problematic if your sorted array
                //has two optimal Intervals next to eachother.
                i--;
                //set bestOfCurr to null, so that it won't run
                //this section of code twice on the same Interval.
                bestOfCurr = null;
            }

        }

        //Now we should just make sure that we have in fact covered the entire
        //target range. If we haven't, then we are going to return an empty list.
        if (currBestNum < target.max)
            smallSet.clear();
        return smallSet;
    }

    public static void main(String[] args) {
        //{(1, 4), (30, 40), (20, 91) ,(8, 10), (6, 7), (3, 9), (9, 12), (11, 14)}
        Interval[] interv = {
                new Interval(1, 4),
                new Interval(30, 40),
                new Interval(20, 91),
                new Interval(8, 10),
                new Interval(6, 7),
                new Interval(3, 9),
                new Interval(9, 12),
                new Interval(11, 14)
        };
        Set<Interval> newSet = smallestIntervalSet(interv, new Interval(3,14));
        for (Interval intrv : newSet) {
            System.out.print("(" + intrv.min + ", " + intrv.max + ") ");
        }

    }
}

/* Sum to target in an array (consecutive)*/
public static boolean solution(int[] nums, int target) {
        if(nums.length == 0) {
            return target == 0;
        }
        int start = 0;
        int end = 0;
        int sum = nums[0];
        if (sum == target) {
            return true;
        }
        while(end < nums.length) {
            if(sum > target) {
                sum -= nums[start];
                start++;
            } else {
                end++;
                if(end < nums.length) {
                    sum += nums[end];
                }
            }
            if (sum == target) {
                return true;
            }
        }
        return false;
    }

/* determine the number of steps in which one word / one string to other*/
int count=0;
public int convert(String changing, String end, Set<String> wordDict) {
        if (changing.equals(end)) return count;

        int i = 0;

        for (char c : end.toCharArray()) {
            char[] changingArray = changing.toCharArray();

            if (changingArray[i] != c) {
                char temp = changingArray[i];
		changingArray[i] = c;

                if (dictionary.contains(new String(changingArray))) {
			count++;
                    return convert(new String(changingArray), end);

                }
		Else
		{
			changingArray[i] = temp;
		}
            }
            i++;

        }
        return count;
    }

/* Sort object based on the index 
Example: array[] = {C,D,E,F,G};
Example: index[] = {3,0,4,1,2};
*/
public static void sortByIndex(char[] array, int[] indexes) {
		if (array.length != indexes.length) return;

		for (int i = 0; i < array.length; i++) {
			// swap value
			char temp = array[indexes[i]]; 
			array[indexes[i]] = array[i];
			array[i] = temp;
			// swap index
			int tInd = indexes[indexes[i]];
			indexes[indexes[i]] = indexes[i];
			indexes[i] = tInd;
		}
	}

/* Given an array find all pairs of numbers such that they differ / difference exactly by target value*/
public static void computeDifference(int[] arr, int k){
		for(int i = 0,j = 1; j < arr.length && i < j; ){
			if((arr[j] - arr[i]) == k){
				System.out.println(arr[j]+" "+arr[i]);
				j++;
			}else if((arr[j] - arr[i]) > k){
				i++;
			}else if((arr[j] - arr[i]) < k){
				j++;
				
			}
		}
	}

/* Maximum drop between the two array elements*/
Same as the stock profit


